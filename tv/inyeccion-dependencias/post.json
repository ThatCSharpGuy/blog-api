{	
	"id" : "/tv/inyeccion-dependencias/",
	"tv" : true,
	"date": "2016-09-05 13:00:00 -0500",
	"title" : "La inyección de dependencias",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//tv/di/featured.jpg",
	"tags" : ["Meta","Tv"],
	  
	"content": '"Antes de hablar de la inyección de dependencias es necesario conocer dos conceptos:  \n\n - Los patrones de diseño  \n - El principio de inversión    \n\n# Patrón de diseño de software  \nEn el mundo de desarrollo de software, cuando hablamos de un patrón de diseño, nos referimos a una forma de resolver un \"problema\" recurrente a la hora de diseñar una aplicación. Podemos ver un patrón como una plantilla genérica, independiente del lenguaje de programación que usemos, en la que podemos basarnos para comenzar a escribir el código de una app.  \n\nSon los programadores quienes deciden qué es un patrón de diseño y qué no, es decir, no existe una especie de organismo que diga qué sí es y qué no... así que generalmente para que algo sea considerado un patrón debe ser una solución comprobada por su efectividad en sus usos previos. Pero siempre recuerda que\n\n > Los patrones de diseño son una opción, no un requerimiento\n\n### El principio de inversión  \n\n\nEste principio, inicialmente definido en el artículo <a href=\"http://www.laputan.org/drc/drc.html\" target=\"_blank\">Designing Reusable Classes</a> de Ralph Johnson y Brian Foote en 1988, consiste en intentar eliminar las dependencias de un módulo de un programa con el resto.  \n\nPiensa en un programa *tradicional*, en el programa decide **qué sucede**, **cómo sucede** y **cuándo sucede**. Para que un programa así funcione, los módulos deben tener conocimiento total sobre aquellos otros submódulos que utiliza para funcionar, lo cual genera un acoplamiento fuerte.\n\nMientras que uno que implementa la inversión de control **no debe saber cómo suceden las cosas**, solamente qué sucede y cuándo, alguien más (generalmente un framework) le entrega instancias o referencias de los módulos con los que tiene que trabajar, obteniendo así un acoplamiento débil.  \n\nPor poner un ejemplo, un poco absurdo pero que creo que funciona: imagínate que tú eres un programa y de pronto te da hambre de una pizza.  \n\nSi fueras un programa *tradicional* **dependerías** que saber cómo preparar una pizza, desde obtener los ingredientes, mezclarlos del modo adecuado y esperar el tiempo necesario en el horno.  \n\nPero si fueras un programa que implementa el principio de inversión de control, existirían dos opciones para conseguirla:\n\n - Tendrías que saber en dónde conseguir la pizza (<a href=\"https://en.wikipedia.org/wiki/Service_locator_pattern\" target=\"_blank\">Patrón de ubicación de servicios</a>)  \n - Alguien más te la entregaría (inyección de dependencias)\n\nDe ambas formas se reduce **dependencia** a saber cómo prepararla tu mismo.  \n\nY no solo eso, si más adelante quieres otro tipo de comida (por ejemplo, una hamburguesa), podrías obtenerla sin problema, mientras que de la forma tradicional tendrías que aprender a prepararlas.  \n\n## Inyección de dependencias  \n\nAhora sí, hablemos del tema. En la inyección de dependencias, cuyo nombre <a href=\"http://www.martinfowler.com/articles/injection.html#FormsOfDependencyInjection\" target=\"_blank\">se le atribuye a Martin Fowler</a>, podemos encontrar cuatro roles:  \n\n- Las interfaces que definen las operaciones de los servicios - no necesariamente tienen que ser interfaces (como en C#), sino que puede ser una clase abstracta\n- Los servicios, que implementan las interfaces anteriores, que se van inyectar \n- Los clientes que usarán los servicios\n- El inyector, que es el encargado de construir e inyectar los servicios en los clientes  \n\nEstos roles no son completamente exclusivos, es decir, un cliente puede ser un servicio que deba ser inyectado a otro cliente.  \n\nBasándonos en los roles anteriores, el flujo de programación de una aplicación que implementa la inyección de dependencias es el siguiente:  \n\n1. Creas las abstracciones que definen el comportamiento de los servicios. Siguiendo con el ejemplo de los alimentos, imagínate una interfaz `IAlimento`, que defina la propiedad `Nombre` o, el método `Consumir()`:  \n  \n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\n\n2. Implementas dicho comportamiento para cada servicio, digamos que  tenemos los alimentos `Pizza` y `Hamburguesa`, que implementan la interfaz \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\n\n3. Creas los clientes que consumirán dichos servicios, por ejemplo, `Persona`, siempre especificando una manera de inyectar las dependencias, ya sea a través del constructor o un método.    \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\n4. Se configura el inyector, el inyector es el único que tiene conocimiento sobre todas las dependencias, ya sea que usemos un framework o lo hagamos \"a mano\" \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\nEn este proceso me parece que hay dos partes que requieren de un poco de trabajo:  \n\n- A la hora de diseñar tu app: definir la interfaz de los servicios  \n- A la hora de escribir el código: configurar el inyector de dependencias\n\nPara la primera no hay más que diseñar bien la app, para la segunda nos podemos ayudar de un framework  \n\n### Frameworks  \n\nPara implementar la DI hay muchos frameworks que realizan la tarea del inyector. Sin embargo, a estos frameworks usualmente se les conoce como Contenedores de DI, porque implementan una especie de contenedor o almacén en donde se guardan las dependencias para cuando necesiten ser resueltas en tiempo de ejecución. \n\nEntre los frameworks, por ejemplo, para C# está Autofac, Ninject y Unity, para Java existe Silk, Guice y PicoContainer, para Swift está Swinject, Cleanse o Typhoon… \n\n### Ventajas y desventajas\n\nEntre las ventajas de la inyección de dependencias podemos encontrar algunos como el hecho de que **tu código se vuelve más modular y menos acoplado**, ya que los submódulos no necesitan saber detalles de la implementación de otros en tu código. Producto de esta modularidad es que **podemos hacer tests unitarios más fácilmente**, cada parte del programa se puede aislar porque para realizar pruebas no tenemos que proveer a nuestros programas de las referencias reales, sino que podemos fingirlas.\n\nY una vez configurado, usar la inyección de dependencias puede **hacer que escribas código más rápido** y te quita preocupaciones de tener que instanciar objetos tu mismo.\n\nEs de nuevo importante señalar que no todo son beneficios cuando usamos la inyección de dependencias, usar este patrón también tiene desventajas:  \n\nComenzar a usarla puede ser tedioso, ya que **necesitas escribir una abstracción de tus servicios** además de su implementación, a veces podrías pensar que escribes código innecesariamente. Y no solo eso, porque luego de eso tienes que configurar tú el inyector. Sin mencionar que, si usas alguna librería, **es muy probable que tengas que ejecutar tu aplicación para verificar que todas las dependencias se resuelvan correctamente** en tiempo de ejecución.\n\n### Código  \nEn <a href=\"https://github.com/ThatCSharpGuy/patterns\" target=\"_blank\">este enlace</a> puedes encontrar un ejemplo de DI para C#.\n\n"'   
}