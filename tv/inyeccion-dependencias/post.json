{	
	"id" : "/tv/inyeccion-dependencias/",
	"tv" : true,
	"date": "2016-09-05 13:00:00 -0500",
	"title" : "La inyección de dependencias",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//tv/di/featured.jpg",
	"tags" : ["Meta","Tv"],
	"content": "<p>Antes de hablar de la inyección de dependencias es necesario conocer dos conceptos:</p>\n\n<ul>\n  <li>Los patrones de diseño</li>\n  <li>El principio de inversión</li>\n</ul>\n\n<h1 id=\"patrn-de-diseo-de-software\">Patrón de diseño de software</h1>\n<p>En el mundo de desarrollo de software, cuando hablamos de un patrón de diseño, nos referimos a una forma de resolver un “problema” recurrente a la hora de diseñar una aplicación. Podemos ver un patrón como una plantilla genérica, independiente del lenguaje de programación que usemos, en la que podemos basarnos para comenzar a escribir el código de una app.</p>\n\n<p>Son los programadores quienes deciden qué es un patrón de diseño y qué no, es decir, no existe una especie de organismo que diga qué sí es y qué no… así que generalmente para que algo sea considerado un patrón debe ser una solución comprobada por su efectividad en sus usos previos. Pero siempre recuerda que</p>\n\n<blockquote>\n  <p>Los patrones de diseño son una opción, no un requerimiento</p>\n</blockquote>\n\n<h3 id=\"el-principio-de-inversin\">El principio de inversión</h3>\n\n<p>Este principio, inicialmente definido en el artículo <a href=\"http://www.laputan.org/drc/drc.html\" target=\"_blank\">Designing Reusable Classes</a> de Ralph Johnson y Brian Foote en 1988, consiste en intentar eliminar las dependencias de un módulo de un programa con el resto.</p>\n\n<p>Piensa en un programa <em>tradicional</em>, en el programa decide <strong>qué sucede</strong>, <strong>cómo sucede</strong> y <strong>cuándo sucede</strong>. Para que un programa así funcione, los módulos deben tener conocimiento total sobre aquellos otros submódulos que utiliza para funcionar, lo cual genera un acoplamiento fuerte.</p>\n\n<p>Mientras que uno que implementa la inversión de control <strong>no debe saber cómo suceden las cosas</strong>, solamente qué sucede y cuándo, alguien más (generalmente un framework) le entrega instancias o referencias de los módulos con los que tiene que trabajar, obteniendo así un acoplamiento débil.</p>\n\n<p>Por poner un ejemplo, un poco absurdo pero que creo que funciona: imagínate que tú eres un programa y de pronto te da hambre de una pizza.</p>\n\n<p>Si fueras un programa <em>tradicional</em> <strong>dependerías</strong> que saber cómo preparar una pizza, desde obtener los ingredientes, mezclarlos del modo adecuado y esperar el tiempo necesario en el horno.</p>\n\n<p>Pero si fueras un programa que implementa el principio de inversión de control, existirían dos opciones para conseguirla:</p>\n\n<ul>\n  <li>Tendrías que saber en dónde conseguir la pizza (<a href=\"https://en.wikipedia.org/wiki/Service_locator_pattern\" target=\"_blank\">Patrón de ubicación de servicios</a>)</li>\n  <li>Alguien más te la entregaría (inyección de dependencias)</li>\n</ul>\n\n<p>De ambas formas se reduce <strong>dependencia</strong> a saber cómo prepararla tu mismo.</p>\n\n<p>Y no solo eso, si más adelante quieres otro tipo de comida (por ejemplo, una hamburguesa), podrías obtenerla sin problema, mientras que de la forma tradicional tendrías que aprender a prepararlas.</p>\n\n<h2 id=\"inyeccin-de-dependencias\">Inyección de dependencias</h2>\n\n<p>Ahora sí, hablemos del tema. En la inyección de dependencias, cuyo nombre <a href=\"http://www.martinfowler.com/articles/injection.html#FormsOfDependencyInjection\" target=\"_blank\">se le atribuye a Martin Fowler</a>, podemos encontrar cuatro roles:</p>\n\n<ul>\n  <li>Las interfaces que definen las operaciones de los servicios - no necesariamente tienen que ser interfaces (como en C#), sino que puede ser una clase abstracta</li>\n  <li>Los servicios, que implementan las interfaces anteriores, que se van inyectar</li>\n  <li>Los clientes que usarán los servicios</li>\n  <li>El inyector, que es el encargado de construir e inyectar los servicios en los clientes</li>\n</ul>\n\n<p>Estos roles no son completamente exclusivos, es decir, un cliente puede ser un servicio que deba ser inyectado a otro cliente.</p>\n\n<p>Basándonos en los roles anteriores, el flujo de programación de una aplicación que implementa la inyección de dependencias es el siguiente:</p>\n\n<ol>\n  <li>Creas las abstracciones que definen el comportamiento de los servicios. Siguiendo con el ejemplo de los alimentos, imagínate una interfaz <code>IAlimento</code>, que defina la propiedad <code>Nombre</code> o, el método <code>Consumir()</code>:</li>\n</ol>\n\n<pre class=\"csharp\">\n\n</pre>\n\n<ol>\n  <li>Implementas dicho comportamiento para cada servicio, digamos que  tenemos los alimentos <code>Pizza</code> y <code>Hamburguesa</code>, que implementan la interfaz</li>\n</ol>\n\n<pre class=\"csharp\">\n\n</pre>\n\n<ol>\n  <li>Creas los clientes que consumirán dichos servicios, por ejemplo, <code>Persona</code>, siempre especificando una manera de inyectar las dependencias, ya sea a través del constructor o un método.</li>\n</ol>\n\n<pre class=\"csharp\">\n\n</pre>\n\n<ol>\n  <li>Se configura el inyector, el inyector es el único que tiene conocimiento sobre todas las dependencias, ya sea que usemos un framework o lo hagamos “a mano”</li>\n</ol>\n\n<pre class=\"csharp\">\n\n</pre>\n\n<p>En este proceso me parece que hay dos partes que requieren de un poco de trabajo:</p>\n\n<ul>\n  <li>A la hora de diseñar tu app: definir la interfaz de los servicios</li>\n  <li>A la hora de escribir el código: configurar el inyector de dependencias</li>\n</ul>\n\n<p>Para la primera no hay más que diseñar bien la app, para la segunda nos podemos ayudar de un framework</p>\n\n<h3 id=\"frameworks\">Frameworks</h3>\n\n<p>Para implementar la DI hay muchos frameworks que realizan la tarea del inyector. Sin embargo, a estos frameworks usualmente se les conoce como Contenedores de DI, porque implementan una especie de contenedor o almacén en donde se guardan las dependencias para cuando necesiten ser resueltas en tiempo de ejecución.</p>\n\n<p>Entre los frameworks, por ejemplo, para C# está Autofac, Ninject y Unity, para Java existe Silk, Guice y PicoContainer, para Swift está Swinject, Cleanse o Typhoon…</p>\n\n<h3 id=\"ventajas-y-desventajas\">Ventajas y desventajas</h3>\n\n<p>Entre las ventajas de la inyección de dependencias podemos encontrar algunos como el hecho de que <strong>tu código se vuelve más modular y menos acoplado</strong>, ya que los submódulos no necesitan saber detalles de la implementación de otros en tu código. Producto de esta modularidad es que <strong>podemos hacer tests unitarios más fácilmente</strong>, cada parte del programa se puede aislar porque para realizar pruebas no tenemos que proveer a nuestros programas de las referencias reales, sino que podemos fingirlas.</p>\n\n<p>Y una vez configurado, usar la inyección de dependencias puede <strong>hacer que escribas código más rápido</strong> y te quita preocupaciones de tener que instanciar objetos tu mismo.</p>\n\n<p>Es de nuevo importante señalar que no todo son beneficios cuando usamos la inyección de dependencias, usar este patrón también tiene desventajas:</p>\n\n<p>Comenzar a usarla puede ser tedioso, ya que <strong>necesitas escribir una abstracción de tus servicios</strong> además de su implementación, a veces podrías pensar que escribes código innecesariamente. Y no solo eso, porque luego de eso tienes que configurar tú el inyector. Sin mencionar que, si usas alguna librería, <strong>es muy probable que tengas que ejecutar tu aplicación para verificar que todas las dependencias se resuelvan correctamente</strong> en tiempo de ejecución.</p>\n\n<h3 id=\"cdigo\">Código</h3>\n<p>En <a href=\"https://github.com/ThatCSharpGuy/patterns\" target=\"_blank\">este enlace</a> puedes encontrar un ejemplo de DI para C#.</p>\n\n"
}