{	
	"id" : "/post/c-sharp-obj-c/",
	"tv" : false,
	"date": "2016-04-04 14:00:00 -0500",
	"title" : "Xamarin.iOS, C# y Objective-C",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//xamarin-ios/featured_obj.png",
	"tags" : ["Xamarin"],
	"content": "Cuando conocí <a href=\"http://thatcsharpguy.com/tag/Xamarin\">Xamarin</a> por primera vez, una de mis primeras preguntas era: ¿Cómo demonos se supone que voy a escribir apps para iOS en C#? Simplemente no se me ocurría cómo es que eso era posible... \r\n\r\nPues bien, hace poco tuve que realizar un proyecto en el que requería mostrar un control tipo *checkbox* para permitir al usuario seleccionar varios items de un conjunto, si estás familiarizado con iOS, sabrás que no existe un *checkbox* nativo, lo más cercano a eso que hay es el `UISwitch`.\r\n\r\nYo no quería usar el UISwitch porque ocupa mucho espacio y creo que da una ilusión como de encendido/apagado más que de seleccionado/no seleccionado, es por eso que *googleando* un poco me encontré con <a href=\"https://github.com/Marxon13/M13Checkbox\" target=\"_blank\" rel=\"nofollow\">M13Checkbox</a> que es un control escrito en Objective-C que hace justo lo que quiero, el problema: **está en Objective-C**.\r\n\r\nY si bien este no es un gran problema, puesto que pude haber <a href=\"https://developer.xamarin.com/guides/ios/advanced_topics/binding_objective-c/\" target=\"_blank\" rel=\"nofollow\">creado un binding</a>, decidí \"traducir\" la librería de Objective-C a C#, para mostrarte cómo es que en algunos aspectos no hay mucha diferencia entre los dos lenguajes.\r\n\r\n\r\n## Definición de las clases:\r\n\r\n<div class=\"pure-g\">\r\n<div class=\"pure-u-1 pure-u-md-1-2\">\r\n<pre class=\"csharp\">\r\n// C#\r\npublic class CheckView : UIView\r\n\r\n    public M13Checkbox Checkbox  get; set; \r\n\r\n    public bool Selected  get; set; \r\n    \r\n    // Code    \r\n\r\n  \r\n</pre>  \r\n</div>\r\n<div class=\"pure-u-1 pure-u-md-1-2\">\r\n<pre class=\"objectivec\">\r\n// Objective-C\r\n@interface CheckView : UIView\r\n@property (nonatomic, weak) M13Checkbox *checkbox;\r\n@property (nonatomic, assign) BOOL selected;\r\n@end\r\n\r\n@implementation CheckView\r\n@synthesize checkbox, selected;\r\n    // Code\r\n@end\r\n\r\n</pre>  \r\n</div>  \r\n</div>\r\n\r\nEn C# no es necesario crear una interfaz para definir una clase, basta con definir la clase incluyéndo sus propiedades, y si bien también existen las interfaces, estas cumplen otras funciones que no son las mismas que Obj-C.\r\n\r\n## Creando instancias de objetos\r\n\r\n<div class=\"pure-g\">\r\n<div class=\"pure-u-1 pure-u-md-1-2\">\r\n<pre class=\"csharp\">\r\n// C#\r\ncheckView = new CheckView(checkViewFrame);\r\n_titleLabel = new UILabel(labelFrame);\r\n</pre>  \r\n</div>\r\n<div class=\"pure-u-1 pure-u-md-1-2\">\r\n<pre class=\"objectivec\">\r\n// Objective-C\r\ncheckView = [[CheckView alloc] initWithFrame:checkViewFrame];\r\n_titleLabel = [[UILabel alloc] initWithFrame:labelFrame];\r\n</pre>  \r\n</div>  \r\n</div>\r\n\r\nLa primera diferencia es que nosotros no tenemos que usar `alloc` para reservar memoria para nuestra instancia, ni necesitamos llamar a algún método `init` para inicializarlo. Ambas tareas son reemplazadas por el operador `new` y el constructor de la clase.\r\n\r\n\r\n## Métodos\r\n\r\n<div class=\"pure-g\">\r\n<div class=\"pure-u-1 pure-u-md-1-2\">\r\n<pre class=\"csharp\">\r\n// C#\r\n\r\n// Static method\r\npublic static void NoInstanceMethod()\r\n // ...\r\n\r\npublic UIBezierPath GetDefaultShape()\r\n // ...\r\n            \r\npublic void Draw(CGRect rect)\r\n // ...\r\n\r\n// Constructor\r\npublic M13Checkbox(GCRect frame, string title)\r\n // ...\r\n</pre>  \r\n</div>\r\n<div class=\"pure-u-1 pure-u-md-1-2\">\r\n<pre class=\"objectivec\">\r\n// Objective-C\r\n\r\n// Class method\r\n+ (void)noInstanceMethod\r\n // ...\r\n\r\n- (UIBezierPath *)getDefaultShape\r\n // ...\r\n\r\n- (void)drawRect:(CGRect)rect\r\n // ...\r\n\r\n// Initializer\r\n- (id)initWithFrame:(CGRect)frame title:(NSString *)title\r\n // ...\r\n</pre>  \r\n</div>  \r\n</div>\r\n\r\nLa primera cosa que resalta a la vista es que en C# desaparecen los `+` y  `-` dentro de la firma del método, sabemos que `+` significa que el método es un método de clase y lo más parecido en C# es un método *static*, no digo que son 100 iguales, porque no lo son, pero para el día a día, son equivalentes.\r\n\r\nEn Objective-C no existe la sobrecarga de métodos, entonces el nombre del método incluye el nombre del primer parámetro pasado a él como argumento, en este caso \"draw**Rect**\", para C# esto no es necesario, basta con el nombre del método, los argumentos pasados a él lo diferenciarán de los otros que puedan coincidir en nombre.   \r\n\r\nPor otro lado, en C# no existe un método para inicializar un objeto, sino que se ocupan los constructores, que parecen métodos sin tipo de retorno y que llevan el mismo nombre de la clase que construye, como en este caso `M13Checkbox`.\r\n\r\n## Llamando a métodos\r\n\r\n<div class=\"pure-g\">\r\n<div class=\"pure-u-1 pure-u-md-1-2\">\r\n<pre class=\"csharp\">\r\n// C#\r\nCheckbox.GetDefaultShape().Fill();\r\n\r\nfillColor.GetRGBA(out r, out g, out b, out a);\r\n\r\nbezierPath.AddCurveToPoint(new CGPoint((0.17625 * height), // ...\r\n</pre>  \r\n</div>\r\n<div class=\"pure-u-1 pure-u-md-1-2\">\r\n<pre class=\"objectivec\">\r\n// Objective-C\r\n[[checkbox getDefaultShape] fill];\r\n\r\n[fillColor getRed:&r green:&g blue:&b alpha:&a];\r\n\r\n[bezierPath addCurveToPoint: CGPointMake((0.17625 * height), // ...\r\n</pre>  \r\n</div>  \r\n</div>\r\n\r\nLo primero que nos damos cuenta es que los `[ ]` desaparecen, en C# los métodos se llaman colocando el operador `.` a nuestro objeto, para después indicar el nombre y su lista de parámetros entre `( )`, y si un método no recibe parámetros los paréntesis deben colocarse vacíos.  \r\n\r\nEn cuanto a los parámetros, estos no requieren ser distinguidos con el nombre que se indica en la firma del método, basta con colocarlos en el orden correspondiente y separarlos con una coma para distinguirlos uno de otro.\r\n\r\nEn Obj-C vemos que se usa `&` para indicar que un valor es pasado a un método como referencia, mientras que en C# esto se indica con `out` o `ref`, dependiendo de la situación.\r\n\r\n## Propiedades de instancia\r\n\r\n<div class=\"pure-g\">\r\n<div class=\"pure-u-1 pure-u-md-1-2\">\r\n<pre class=\"csharp\">\r\n// C#\r\nCGRect boxRect = new CGRect(Checkbox.StrokeWidth, \r\n    (Frame.Size.Height * Constants.CheckVerticalExtension), \r\n    (Frame.Size.Height * Constants.BoxSize) - Checkbox.StrokeWidth, \r\n    (Frame.Size.Height * Constants.BoxSize) - Checkbox.StrokeWidth);\r\n</pre>  \r\n</div>\r\n<div class=\"pure-u-1 pure-u-md-1-2\">\r\n<pre class=\"objectivec\">\r\n// Objective-C\r\nCGRect boxRect = CGRectMake(checkbox.strokeWidth, \r\n    (self.frame.size.height * kCheckVerticalExtension), \r\n    (self.frame.size.height * kBoxSize) - checkbox.strokeWidth, \r\n    (self.frame.size.height * kBoxSize) - checkbox.strokeWidth);\r\n</pre>  \r\n</div>  \r\n</div>\r\n\r\nLa primera diferencia es que no es necesario utilizar `self` para referirse a propiedades de instancia (en C# `this` es la palabra para referirse al objeto desde dentro de él mismo).\r\n\r\nLa segunda es que en C# no existe la posibilidad de definir valores constantes usando `#define`, para ellas es necesario usar la palabra reservada `const`, y como todo tiene que pertenecer a una clase, yo decidí meterlas en una clase llamada `Constants`.\r\n\r\n## Tipos por referencia  \r\n\r\n<div class=\"pure-g\">\r\n<div class=\"pure-u-1 pure-u-md-1-2\">\r\n<pre class=\"csharp\">\r\n// C#\r\nUIColor fillColor = null;\r\nUIColor strokeColor = null;\r\nUIColor checkColor = null;\r\n</pre>  \r\n</div>\r\n<div class=\"pure-u-1 pure-u-md-1-2\">\r\n<pre class=\"objectivec\">\r\n// Objective-C\r\nUIColor *fillColor = nil;\r\nUIColor *strokeColor = nil;\r\nUIColor *checkColor = nil;\r\n</pre>  \r\n</div>  \r\n</div>\r\n\r\nPara tener una referencia a `UIColor` no es necesario el sufijo `*`, puesto que en C# UIColor ya es un <a href=\"http://thatcsharpguy.com/post/tipos-dato-c-sharp/\">tipo por referencia</a> y no se usa `*` para hacerlo notar. Ah... otra \"gran\" diferencia es que `nil` es como  `null`.\r\n\r\n## Enums  \r\n\r\n<div class=\"pure-g\">\r\n<div class=\"pure-u-1 pure-u-md-1-2\">\r\n<pre class=\"csharp\">\r\n// C#\r\npublic enum CheckboxState\r\n\r\n    Unchecked,\r\n    Checked,\r\n    Mixed\r\n\r\n</pre>  \r\n</div>\r\n<div class=\"pure-u-1 pure-u-md-1-2\">\r\n<pre class=\"objectivec\">\r\n// Objective-C\r\ntypedef NS_ENUM(NSInteger, M13CheckboxState) \r\n    M13CheckboxStateUnchecked = NO, //Default\r\n    M13CheckboxStateChecked = YES,\r\n    M13CheckboxStateMixed\r\n;\r\n  \r\n</pre>   \r\n</div>  \r\n</div>  \r\n\r\nEn C# no es posible asociar los valores de un *enum* con booleanos, como en Objective-C, entonces para compararlos es necesario hacer algo como:\r\n\r\n<div class=\"pure-g\">\r\n<div class=\"pure-u-1 pure-u-md-1-2\">\r\n<pre class=\"csharp\">\r\n// C#\r\nif (Checkbox.CheckboxState == CheckboxState.Unchecked)\r\n\r\n    fillColor = Checkbox.UncheckedColor;\r\n\r\nelse\r\n\r\n    fillColor = Checkbox.TintColor;\r\n\r\n</pre>  \r\n</div>\r\n<div class=\"pure-u-1 pure-u-md-1-2\">\r\n<pre class=\"objectivec\">\r\n// Objective-C\r\nif (checkbox.checkState == M13CheckboxStateUnchecked) \r\n    fillColor = checkbox.uncheckedColor;\r\n else \r\n    fillColor = checkbox.tintColor;\r\n\r\n  \r\n  \r\n  \r\n</pre>  \r\n</div>  \r\n</div>\r\n\r\n## Conclusión  \r\nEsta fue un pequeño ejercicio de comparación de sintaxis entre los dos lenguajes, en este podemos ver que, si bien hay diferencias muy relevantes, también hay puntos en los que se cruzan o no es mucha la diferencia. También aproveché para mostrar el gran esfuerzo que hizo la gente de Xamarin al mapear 1:1 la api de iOS a C#, es por eso que los nombres de los métodos, clases y demás coinciden casi al 100.\r\n\r\n### Lo que sigue\r\nSi quieres seguir leyendo más sobre la transición de Objective-C a C#, puedes ver <a href=\"https://developer.xamarin.com/guides/ios/advanced_topics/xamarin_for_objc/primer/\" target=\"_blank\" rel=\"nofollow\">documentación de Xamarin</a> o <a href=\"http://stackoverflow.com/a/1369221\" target=\"_blank\" rel=\"nofollow\">esta respuesta en StackOverflow</a>. Yo pronto estaré publicando una pequeña guía sobre cómo hacer una app nativa para iPhone usando C# y Xamarin, para continuar con este ejemplo, pero por mientras puedes ver las <a href=\"http://thatcsharpguy.com/post/xamarin-android-vs-traditional/\">diferencias entre Xamarin.Android y Android</a>."
}