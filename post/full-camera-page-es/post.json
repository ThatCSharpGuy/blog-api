{	
	"id" : "/post/full-camera-page-es/",
	"tv" : false,
	"date": "2016-11-08 02:00:00 -0600",
	"title" : "Cámara a página completa en Xamarin.Forms",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//xamarin-forms/camerapage/featured.jpg",
	"tags" : ["XamarinForms","Xamarin"],
	"content": "Hace ya un tiempo desde que programé la aplicación<a href=\"..\\Aharphat-Android\" target=\"_blank\">CharpHat</a>, que es una aplicación que permite tomar una foto de cualquier cosa y ponerle un birrete de C# en ella. La aplicación no era perfecta, pero me ayudó a practicar el uso de los *custom page renderers*.  \n\nAhora, decidí retomar el proyecto, pero en esta ocasión con la meta de aislar el código necesario para crear la interfaz y funconalidad de la cámara, de tal modo que cualquiera que quisiera implementar una cámara en su aplicación lo pudiera reutilizar en sus proyectos. Asegúrate de <strong><a href=\"https://github.com/ThatCSharpGuy/Forms-FullCameraPage\" target=\"_blank\">descargar el código fuente</a></strong> para este post.\n\n## Abstracciones de Forms\n<small><a href=\"https://github.com/ThatCSharpGuy/Forms-FullCameraPage/blob/master/CameraPage.cs\" target=\"_blank\">Aquí está el código fuente para esta sección.</a></small>  \n\nComencemos creando la página de Forms que nos servirá como medio de interacción con el código de clada plataforma:\n\n<pre class=\"csharp\">\npublic class CameraPage : ContentPage\n\n    public delegate void PhotoResultEventHandler(PhotoResultEventArgs result);\n    public event PhotoResultEventHandler OnPhotoResult;\n</pre>  \n\nNada fuera de lo normal, crea una clase que derive de `ContentPage`. Añadí un *event handler* ya que que queremos obtener la foto tomada por el usuario. Ahora, agreguémos algunos métodos para llamar cada vez que el usuario realice una acción en la página (en este caso, el usuario podrá tomar una foto o cancelar la acción):\n\n<pre class=\"csharp\">\npublic void SetPhotoResult(byte[] image, int width = -1, int height = -1)\n\n    OnPhotoResult?.Invoke(new PhotoResultEventArgs(image, width, height));\n\n\npublic void Cancel()\n\n    OnPhotoResult?.Invoke(new PhotoResultEventArgs());\n \n</pre>  \n\nComo referencia, mira las propiedades dentro de la clase `PhotoResultEventArgs`:\n\n<pre class=\"csharp\">\npublic bool Success  get; private set; \npublic int Width  get; private set; \npublic int Height  get; private set; \npublic byte[] Image  get; private set; \n</pre>  \n\nAhora es momento de seguir al código específico de cada plataforma. \n\n## In Xamarin.iOS    \n<small><a href=\"https://github.com/ThatCSharpGuy/Forms-FullCameraPage/blob/master/iOS/CameraPageRenderer.cs\" target=\"_blank\">Aquí está el código fuente para esta sección.</a></small>  \n\nPara ser sincero, la implementación en iOS es la más sencilla por mucho. Comenzamos por crear una clase que derive de `PageRenderer` y le añadimos el atributo `ExportRenderer`:\n\n<pre class=\"csharp\">\n[assembly: ExportRenderer(typeof(CameraPage), typeof(CameraPageRenderer))]\nnamespace FullCameraPage.iOS\n\n\tpublic class CameraPageRenderer : PageRenderer\n</pre>  \n\nAhora, y esto es muy importante, tienes que sobreescribir el método `ViewDidLoad` dado que es llamado tan pronto nuestra página es cargada por el sistema operativo. Para organizar un poco mejor el código, partamos el código en varios métodos:\n\n<pre class=\"csharp\">\npublic override async void ViewDidLoad()\n\n    base.ViewDidLoad();\n    SetupUserInterface();\n    SetupEventHandlers();\n    AuthorizeCameraUse();\n    SetupLiveCameraStream();\n\n</pre>  \n\n### SetupUserInterface \nTal y como el nombre lo dice, aquí es donde tenemos que construir la interfaz. Como podrás haber adivinado, todo se hace con código, pero no te preocupes, es muy sencillo en tanto tu interfaz no sea muy complicada, pero puedes hacer lo que tu quieras aquí.  \n\nPara este ejemplo la interfaz consistrá de un par de botones y una superficie donde la vista en vivo de la cámara se mostrará, así que declara las siguientes campos a nivel de clase:\n\n<pre class=\"csharp\">\nVectorButton takePhotoButton;\nVectorButton cancelPhotoButton;\nUIView liveCameraStream;\n</pre>  \n\nAhora para poner los controles en su lugar necesitas pensar como si estuvieras trabajando con un *relative layout*, lo que significa que hay que poner la posición del control en la pantalla. Por ejemplo, observa cómo se ubica la vista de la cámara:\n\n<pre class=\"csharp\">\nprivate void SetupUserInterface()\n\n    // Code ommited ...\n    liveCameraStream = new UIView()\n    \n        Frame = new CGRect(0f, 0f, View.Bounds.Width, View.Bounds.Height)\n    ;\n    // Code ommited ...\n    View.Add(liveCameraStream);\n    // Code ommited ...\n\n</pre>  \n\n### SetupEventHandlers  \nAhora que ya hemos terminado la interfaz, podemos *conectar* los manejadores de eventos a cada control, por suerte en nuestro ejemplo únicamente tenemos dos botones en la pantalla: para tomar fotos y para cancelar la captura.\n\n<pre class=\"csharp\">\ncancelPhotoButton.TouchUpInside += (s, e) =>\n\n    (Element as CameraPage).Cancel();\n;\n\ntakePhotoButton.TouchUpInside += async (s, e) =>\n\n    var data = await CapturePhoto();\n    UIImage imageInfo = new UIImage(data);\n\n    (Element as CameraPage).SetPhotoResult(data.ToArray(),\n                                           (int)imageInfo.Size.Width,\n                                           (int)imageInfo.Size.Height);\n;\n</pre>  \n\nLa propiedad `Element` contiene una referencia a la página asociada con el *renderer* y es nuestro medio de interacción con el proyecto de Forms. Si te preguntas sobre el método `CapturePhoto`, lo veremos más adelante.  \n\n## AuthorizeCameraUse  \nAhora es momento de solicitar permiso al usuario para usar su cámara. \n\n<pre class=\"csharp\">\nvar authorizationStatus = AVCaptureDevice.GetAuthorizationStatus(AVMediaType.Video);\nif (authorizationStatus != AVAuthorizationStatus.Authorized)\n\n    await AVCaptureDevice.RequestAccessForMediaTypeAsync(AVMediaType.Video);\n\n</pre>  \n\nPero antes de ejecutar el código anterior tienes que agregar la entrada `Privacy - Camera Usage Description` al archivo Info.plist en tu proyecto.  \n\n### SetupLiveCameraStream  \nAhora la parte \"complicada\".\n  \nComienza delcarando a nivel de clase una `AVCaptureSession`, `AVCaptureDeviceInput` y `AVCaptureStillImageOutput`,  ya que estos nos ayudaran a acceder a la cámara, mostrarla en vivo, y capturar la imagen.  \n\nEntonces dentro de `SetupLiveCameraStream`, inicializa una sesión de captura, crea una capa de previsualización del mismo tamaño que nuestra `liveCameraStream`, y añádela como una subcapa de esta:\n\n<pre class=\"csharp\">\n    captureSession = new AVCaptureSession();\n    var videoPreviewLayer = new AVCaptureVideoPreviewLayer(captureSession)\n    \n        Frame = liveCameraStream.Bounds\n    ;\n    liveCameraStream.Layer.AddSublayer(videoPreviewLayer);\n</pre>    \n\nDespués, \"crea\" un dispositivo de captura (que puedes configurar de acuerdo a tus necesidades). Y entonces de éste dispositivo crea una entrada para la sesión de captura:\n\n<pre class=\"csharp\">\n    var captureDevice = AVCaptureDevice.DefaultDeviceWithMediaType(AVMediaType.Video);\n    ConfigureCameraForDevice(captureDevice);\n    captureDeviceInput = AVCaptureDeviceInput.FromDevice(captureDevice);\n</pre>  \n\nYa tenemos una entrada (la cámara del dispositivo), ahora necesitamos una salida, que será una fotografía en formato jpeg:\n\n<pre class=\"csharp\">\n    var dictionary = new NSMutableDictionary();\n    dictionary[AVVideo.CodecKey] = new NSNumber((int)AVVideoCodec.JPEG);\n    stillImageOutput = new AVCaptureStillImageOutput()\n    \n        OutputSettings = new NSDictionary()\n    ;\n</pre>  \n\nTerminamos estableciendo la entrada y salida de la sesión de captura y la iniciamos:\n\n<pre class=\"csharp\">\n    captureSession.AddOutput(stillImageOutput);\n    captureSession.AddInput(captureDeviceInput);\n    captureSession.StartRunning();\n</pre>\n\n### CapturePhoto\nFinalmente la cereza del pastel. El código para capturar la foto. En sí, el código es bastante simple: Toma la salida y obten una imagen fija de ella, ya que nosotros solo necesitamos los bytes (`NSData`) que contenga la foto tomada: \n\n<pre class=\"csharp\">\npublic async Task<NSData> CapturePhoto()\n\n    var videoConnection = stillImageOutput.ConnectionFromMediaType(AVMediaType.Video);\n    var sampleBuffer = await stillImageOutput.CaptureStillImageTaskAsync(videoConnection);\n    var jpegImageAsNsData = AVCaptureStillImageOutput.JpegStillToNSData(sampleBuffer);\n    return jpegImageAsNsData;\n\n</pre>\n\n## In Xamarin.Android    \n<small><a href=\"https://github.com/ThatCSharpGuy/Forms-FullCameraPage/blob/master/Droid/CameraPageRenderer.cs\" target=\"_blank\">Aquí está el código fuente para esta sección.</a></small>      \n\nEsta implementación no es tan limpia como en iOS. Principalmente porque Android hace más énfasis en el uso de *listeners* que en manejadores de evento. Como sea, ese no es un problema para nosotros.\n\nComo en iOS, comienza creando una clase que derive de `PageRenderer` y también haz que implmente la interfaz `TextureView.ISurfaceTextureListener`. No olvides el atributo `ExportRenderer`:  \n\n<pre class=\"csharp\">\n[assembly: Xamarin.Forms.ExportRenderer(typeof(CameraPage), typeof(CameraPageRenderer))]\nnamespace FullCameraPage.Droid\n\n    public class CameraPageRenderer : PageRenderer, TextureView.ISurfaceTextureListener\n</pre>  \n\nDespués, sobreescribe el método `OnElementChanged` (si ya has trabajado con *custom renderers* antes, este método te puede parecer familiar), ya que este será llamado cada vez que una `CameraPage` es mostrada en la pantalla:\n\n<pre class=\"csharp\">\nprotected override void OnElementChanged(ElementChangedEventArgs<Xamarin.Forms.Page> e)\n\n    base.OnElementChanged(e);\n    SetupUserInterface();\n    SetupEventHandlers();\n</pre>  \n\n### SetupUserInterface  \nEn este método se debe crear la interfaz de la cámara, puedes hacerlo mediante un archivo *axml* e \"inflarlo\" con los mecanismos de Android... o, como en este ejemplo, crearlo en código.  \n\nPara este ejemplo vamos a necesitar un `RelativeLayout` como contenedor, un `TextureView` para mostrar la cámara y un botón para tomar la foto. Declara todo a nivel de clase:  \n\n<pre class=\"csharp\">\nRelativeLayout mainLayout;\nTextureView liveView;\nPaintCodeButton capturePhotoButton;\n</pre>  \n\nSolamente falta instanciarlos y añadirlos a la pantalla, por ejemplo, observa cómo se crea el contenedor y se le añada el control `TextureView`:    \n\n<pre class=\"csharp\">\nvoid SetupUserInterface()\n\n    mainLayout = new RelativeLayout(Context);\n    RelativeLayout.LayoutParams mainLayoutParams = new RelativeLayout.LayoutParams(\n        RelativeLayout.LayoutParams.MatchParent,\n        RelativeLayout.LayoutParams.MatchParent);\n    mainLayout.LayoutParameters = mainLayoutParams;\n\n    liveView = new TextureView(Context);\n    RelativeLayout.LayoutParams liveViewParams = new RelativeLayout.LayoutParams(\n        RelativeLayout.LayoutParams.MatchParent, \n        RelativeLayout.LayoutParams.MatchParent);\n    liveView.LayoutParameters = liveViewParams;\n    mainLayout.AddView(liveView);\n    \n    // Code ommited...\n\n    AddView(mainLayout);\n\n</pre>  \n\nAntes de continuar hay otro método que debemos sobreescribir para darle al contenedor su tamaño (y también lo podemos usar para acomodar la interfaz correctamente):  \n\n<pre class=\"csharp\">\nprotected override void OnLayout(bool changed, int l, int t, int r, int b)\n\n    base.OnLayout(changed, l, t, r, b);\n    if (!changed)\n        return;\n    var msw = MeasureSpec.MakeMeasureSpec(r - l, MeasureSpecMode.Exactly);\n    var msh = MeasureSpec.MakeMeasureSpec(b - t, MeasureSpecMode.Exactly);\n    mainLayout.Measure(msw, msh);\n    mainLayout.Layout(0, 0, r - l, b - t);\n\n    capturePhotoButton.SetX( mainLayout.Width / 2 - 60);\n    capturePhotoButton.SetY(mainLayout.Height - 200);\n\n</pre>  \n\n### SetupEventHandlers  \nComo dije antes, Android depende mucho de *event listeners* en lugar de  *event handlers*, así que este método es muy sencillo. Necesitamos colocar un manejador de evento al botón que tomará la foto, asi como asignar un escuchador que estará atento al estado del control  `SurfaceTexture` (¿Recuerdas que nuestro *renderer* implementa una interfaz?):  \n\n<pre class=\"csharp\">\ncapturePhotoButton.Click += async (sender, e) =>\n\n    var bytes = await TakePhoto();\n    (Element as CameraPage).SetPhotoResult(bytes, liveView.Bitmap.Width, liveView.Bitmap.Height);\n;\nliveView.SurfaceTextureListener = this;\n</pre>  \n\nAh, y otra cosa, vamos a sobreescribir el comportamiento del botón \"Atrás\" para que funcione para cancelar la fotografía:  \n\n<pre class=\"csharp\">\npublic override bool OnKeyDown(Keycode keyCode, KeyEvent e)\n\n    if (keyCode == Keycode.Back)\n    \n        (Element as CameraPage).Cancel();\n        return false;\n    \n    return base.OnKeyDown(keyCode, e);\n\n</pre>   \n\n### TextureView.ISurfaceTextureListener implementation  \nAhora toca implementar el núcleo de la página. Comienza por escribir el código para el método `OnSurfaceTextureAvailable` en donde vamos a preparar la salida de la cámara... pero primero necesitamos una cámara, ¿cierto?  \nA nivel de clase declara una `Camera`:    \n\n<pre class=\"csharp\">\nAndroid.Hardware.Camera camera;\n</pre>\n \nDentro del método abre la cámara (por default tomará la cámara trasera del dispositivo) y obtén sus parámetros. Los necesitamos para elegir el tamaño de previsualización correcto porque queremos que se vea bien en nuestra app:  \n\n<pre class=\"csharp\">\ncamera = Android.Hardware.Camera.Open();\nvar parameters = camera.GetParameters();\n</pre> \n\nUna vez que tenemos los parámetros a mano, podemos obtener los `PreviewSizes` y de ellos elegir el que mejor se ajusta a nuestras necesidades. En este caso estoy usando una simple <a href=\"#\">expresión linq</a> para obtener el mejor tamaño de acuerdo a la relación de aspecto:  \n\n<pre class=\"csharp\">\nvar aspect = ((decimal)height) / ((decimal)width);\n\nvar previewSize = parameters.SupportedPreviewSizes\n                            .OrderBy(s => Math.Abs(s.Width / (decimal)s.Height - aspect))\n                            .First();\n\nparameters.SetPreviewSize(previewSize.Width, previewSize.Height);\ncamera.SetParameters(parameters);\n</pre> \n\nTermina estableciendo el valor de `surface` como la textura de previsualización, una vez hecho esto, lo único que queda por hacer es iniciar la cámara:  \n\n<pre class=\"csharp\">\ncamera.SetPreviewTexture(surface);\nStartCamera();\n</pre> \n\nHay otro método en el que debemos escribir código, este es `OnSurfaceTextureDestroyed` en donde debemos detener el uso de la cámara, así que únicamente escribe el código siguiente en él:  \n\n<pre class=\"csharp\">\nStopCamera();\nreturn true;\n</pre> \n\n### StartCamera and StopCamera  \nEste par de métodos son bastante simples también, para `StartCamera` únicamente tenemos que rotar la previsualización para hacer que se vea correctamente en la pantalla (en este caso está establecido para que se vea verticalmente), y terminamos iniciando la cámara:  \n\n<pre class=\"csharp\">\ncamera.SetDisplayOrientation(90);\ncamera.StartPreview();\n</pre> \n\nEl métodod `StopCamera` detiene la previsualización y libera la cámara para que otras aplicaciones puedan acceder a ella:  \n\n<pre class=\"csharp\">\ncamera.StopPreview();\ncamera.Release();\n</pre> \n\n### TakePhoto\nPara tomar una foto, lo que hay que hacer es obtener una imagen fija de lo que se muestra en el video en vivo dentro de la `TextureView`, aquí está el código para hacerlo y regresar los bytes correspondientes:    \n\n<pre class=\"csharp\">\ncamera.StopPreview();\nvar ratio = ((decimal)Height) / Width;\nvar image = Bitmap.CreateBitmap(liveView.Bitmap, 0, 0, liveView.Bitmap.Width, (int)(liveView.Bitmap.Width * ratio));\nbyte[] imageBytes = null;\nusing (var imageStream = new System.IO.MemoryStream())\n\n    await image.CompressAsync(Bitmap.CompressFormat.Jpeg, 50, imageStream);\n    image.Recycle();\n    imageBytes = imageStream.ToArray();\n\ncamera.StartPreview();\nreturn imageBytes;\n</pre> \n\nY así es como después de tanto código podemos hacer uso de la cámara. Sigue leyendo para encontrar un ejemplo de uso:  \n\n## Usage in Forms  \n\n<pre class=\"csharp\">\nvar cameraPage = new CameraPage();\ncameraPage.OnPhotoResult += CameraPage_OnPhotoResult;\nNavigation.PushModalAsync(cameraPage);  \n// ...\nasync void CameraPage_OnPhotoResult(Pages.PhotoResultEventArgs result)\n\n    await Navigation.PopModalAsync();\n    if (!result.Success)\n        return;\n    Image.Source = ImageSource.FromStream(() => new MemoryStream(result.Image));\n</pre>  \n\nSi <strong><a href=\"https://github.com/ThatCSharpGuy/Forms-FullCameraPage\" target=\"_blank\">descargas el código fuente</a></strong> y lo ejecutas, verás algo como esto:   \n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/DgFEK9tPKs0\" frameborder=\"0\" allowfullscreen></iframe>\n\n\n\n## Acknowledgements   \nEl código para este post está basado completamente en el código de la <a href=\"..\\Aharphat-Android\" target=\"_blank\">CharpHat app</a>,  que a su vez está basado en el código de la app <a href=\"https://blog.xamarin.com/build-your-own-snapchat-clone-with-xamarin-forms-and-azure/\" target=\"_blank\">Moments</a> de <a href=\"https://github.com/pierceboggan\" target=\"_blank\">Pierce Boggan</a>."
}