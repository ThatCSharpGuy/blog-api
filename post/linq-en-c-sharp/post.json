{	
	"id" : "/post/linq-en-c-sharp/",
	"tv" : false,
	"date": "2015-11-11 14:00:00 -0600",
	"title" : "Linq en C#",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimagesfeatured.png",
	"tags" : ["AprendeCSharp"],
	  
	"content": '"Es muy probable que alguna vez en tu vida de desarrollador hayas escuchado hablar de una consulta SQL, pero si no, te cuento que una consulta es una instrucción que se le da a *la computadora* para que busque registros dentro de una tabla y nos entregue los resultados de dicha búsqueda. Una consulta en SQL se ve así:\n<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="err">\</span><span class="n">nSELECT</span> <span class="n">Name</span><span class="p">,</span> <span class="n">Surname</span><span class="p">,</span> <span class="n">Age</span><span class="err">\</span><span class="n">nFROM</span> <span class="n">Students</span><span class="err">\</span><span class="n">nWHERE</span> <span class="n">Age</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="err">\</span><span class="n">nORDER</span> <span class="k">BY</span> <span class="n">Name</span><span class="err">\</span><span class="n">n</span></code></pre></figure>\nDurante mucho tiempo, el poder de las consultas se mantuvo únicamente para las bases de datos, sin embargo, en el 2007 Microsoft liberó junto con la versión 3.5 de su framework, una herramienta llamada **LINQ** que proviene de **L**anguage **IN**tegrated **Q**uery (personalmente prefiero escribir Linq con minúsculas... cuestión de gustos).\n<br />\n<br />\nLinq nos otorga la posibilidad de usar un lenguaje bastante similar al SQL dentro de nuestro código C# para consultar un origen de datos. Para poder usarlo, se requiere de un **proveedor** que no es más que una especie de traductor que toma nuestra consulta y la convierte en algo que pueda ejecutar el origen de datos. Existen proveedores dentro del framework que nos permiten usar Linq a objetos, Linq a XML y Linq a SQL.\n\n### Linq to Objects  \nPara esta serie de posts, me centraré en Linq a objetos (los otros tienen un funcionamiento similar) que opera sobre colecciones de objetos en memoria que implementan la interfaz <code>IEnumerable</code> como arreglos, <code>List</code>, <code>Vector</code>...   \n\nHaciéndo una analogía a la consulta con la que inicié el post, supongamos que tenemos una lista de alumnos llamada <code>students</code>:\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nList</span><span class="p">&lt;</span><span class="n">Student</span><span class="p">&gt;</span> <span class="n">students</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Student</span><span class="p">&gt;</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="k">new</span> <span class="n">Student</span> <span class="p">{</span> <span class="n">Age</span> <span class="p">=</span> <span class="m">11</span><span class="p">,</span> <span class="n">Name</span> <span class="p">=</span> <span class="err">\</span><span class="s">&quot;Laura\&quot;, Surname = \&quot;Rodríguez\&quot; },\n    new Student { Age = 9, Name = \&quot;Francisco\&quot;, Surname=\&quot;Jímenez\&quot; },\n};\n</span></code></pre></figure>\nFormar una consulta simple es bastante sencillo, y muy parecido a lo que haríamos en SQL, lo que necesitamos hacer es:  \n\n 1. Nombrar una variable que contendrá temporalmente cada uno de los elementos contenidos en la colección sobre la que vamos a ejecutar la consulta. Para nuestro caso, la llamarémos <code>s</code>.\n 2. Indicar el origen de datos a consultar. En nuestro caso, este origen de datos es nuestra lista <code>students</code>.\n 3. Indicar las condiciones que queremos que nuestra consulta compruebe.\n 5. Realizar una acción con los elementos que cumplan las condiciones previamente indicadas.\n\nPara ejecutar la consulta del inicio del post sobre nuestra lista de alumnos, debemos usar la sintaxis siguiente: \n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">olderStudents</span> <span class="p">=</span> <span class="k">from</span> <span class="n">s</span> <span class="k">in</span> <span class="n">students</span><span class="err">\</span><span class="n">n</span>                    <span class="k">where</span> <span class="n">s</span><span class="p">.</span><span class="n">Age</span> <span class="p">&gt;</span> <span class="m">10</span><span class="err">\</span><span class="n">n</span>                    <span class="k">select</span> <span class="n">s</span><span class="p">;</span><span class="err">\</span><span class="n">n</span></code></pre></figure>\nEs fácil identificar las partes que la componen:  \n\n - <code>from s</code> hace referencia a la *variable temporal* de la que les contaba un poco antes.\n - <code>in students</code> hace referencia a la colección sobre la que vamos a ejecutar la consulta, esto hace que nuestra variable <code>s</code> sea de tipo <code>Student</code>\n - <code>where s.Age > 10</code> hace referencia a las condiciones que queremos que nuestra consulta compruebe aquí podemos usar condiciones más complejas usando los operadores lógicos <code>||</code> o <code>&&</code>.\n - <code>select s</code> hace referencia a la acción que queremos, en este caso únicamente estamos seleccionando los elementos que conicidan con <code>s.Age > 10</code>  \n  \n\n### Ejecución retrasada  \nUna cosa que es importante saber es que el **declarar una consulta Linq no implica que se ejecute en el momento de la declaración**. Lo que quiere decir esto es que debemos ver el **resultado de una consulta como una referencia a cómo se ejecuta la consulta, no el resultado de la consulta ejecutada**, es por eso que muchas veces veran que se usa <a href=\"var-en-c-sharp\">la palabra *var*</a> junto con Linq. En realidad la consulta será ejecutada cuando se necesite.  \n  \nPara explicar con un ejemplo, volviendo a nuestra consulta <code>olderStudents</code>, sabemos que solamente uno de los objetos cumple con la condición establecida de <code>s.Age > 10</code>, es por eso que cuando queremos contar los elementos con <code>Count()</code>, el resultado es <code>1</code>:\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">olderStudents</span><span class="p">.</span><span class="n">Count</span><span class="p">());</span> <span class="c1">// 1\n</span></code></pre></figure>\nAhora, si agregamos un nuevo elemento a nuestra lista original <code>students</code>:\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nstudents</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">Student</span> <span class="p">{</span> <span class="n">Age</span> <span class="p">=</span> <span class="m">23</span><span class="p">,</span> <span class="n">Name</span> <span class="p">=</span> <span class="err">\</span><span class="s">&quot;Antonio\&quot;, Surname = \&quot;Feregrino\&quot; });\n</span></code></pre></figure>\nY volvemos a contar los objetos dentro de de nuestra consulta <code>olderStudents</code>, el resultado será <code>2</code>:\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">olderStudents</span><span class="p">.</span><span class="n">Count</span><span class="p">());</span> <span class="c1">// 2\n</span></code></pre></figure>\nA esta característica se le conoce como **ejecución retrasada** o **deferred execution**. Podemos evitar esto al convertir nuestra consulta a una colección *estática*, como una lista o un arreglo utilizando los métodos que nos entrega Linq, como <code>ToList</code> o <code>ToArray</code>. Al hacer esto se ejecutará la consulta y se perderá la referencia a esta, con lo que cualquier modificación que sufran los orígenes de datos, no afectará nuestro resultado. Esto se logra así desde la declaración de la consulta, o más adelante llamando <code>ToList</code> o <code>ToArray</code> sobre la consulta.\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">n</span><span class="c1">// Al momento de la declaración\nList&lt;Student&gt; olderStudentList = (from s in students\n                                  where s.Age &gt; 10\n                                  select s).ToList();\n\n// En cualquier otro momento\t\t  \nvar olderStudentsArray = olderStudents.ToArray();\n</span></code></pre></figure>   \n\n#### Lo que sigue  \nLas consultas simples, como la que se usa en este post, son solo la punta del iceberg de todo lo que se puede hacer con Linq, en futuros post veremos las posibilidades que tenemos para hacer consultas más complejas para obtener promedios, sumas, mínimos, hacer uniones, agrupamientos, intersecciones, distinciones... en fin, una enorme cantidad de cosas. Además de que veremos qué son los tipos anónimos en C#."'   
}