{	
	"id" : "/post/yield-c-sharp/",
	"tv" : false,
	"date": "2016-11-22 13:00:01 -0600",
	"title" : "La palabra yield en C#",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//aprende-c-sharp/yield/featured.jpg",
	"tags" : ["AprendeCSharp"],
	"content": "<h2 id=\"la-interfaz-ienumerable\"> La interfaz IEnumerable</h2>\n<p>Que un objeto implemente la clase IEnumerable significa que las instancias de esta tienen contenido sobre el que se puede iterar o recorrer. Este recorrido es siempre hacia “adelante”. Dicho “en código”, la interfaz <code>IEnumerable</code> (genérica o no) nos indica que podemos usar un bloque <code>foreach</code> para recorrer el objeto que la implemente. Por ejemplo, la clase <code>List&lt;T&gt;</code>, <code>ObservableCollection&lt;T&gt;</code> y los arreglos implementan esta clase. Es importante mencionar esto, ya que el tema que se verá a continuación está totalmente ligado a esta interfaz.</p>\n\n<p>En el siguiente post vamos a ver una serie de métodos que tienen como tipo de retorno la interfaz <code>IEnumerable</code>, que como ya sabes ahora, es un tipo de dato que se puede recorrer, o que se puede iterar sobre él, ya sea en un ciclo <code>foreach</code> o empleando Linq.</p>\n\n<h2 id=\"para-qu-sirve-yield\">¿Para qué sirve yield?</h2>\n<p>Considero que la mejor manera de explicar el uso de esta palabra reservada es mediante un ejemplo, así que observa el siguiente código antes de nada.</p>\n\n<div class=\"pure-g\">\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\nIEnumerable<int> GetMultiplesOf(int n, \n                                int start, \n                                int end)\n\n    List<int> multiples = new List<int>();\n    for (int i = start; i &lt; end; i++)\n    \n        if (i  n == 0)\n        \n            Console.WriteLine(\n                $\"i GetMultiplesOf\");\n            multiples.Add(i);\n        \n    \n    return multiples;\n\n   \n \n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\nIEnumerable<int> YieldMultiplesOf(int n, \n                                  int start, \n                                  int end)\n  \n\n    for (int i = start; i &lt; end; i++)\n    \n        if (i  n == 0)\n        \n            Console.WriteLine(\n                $\"i YieldMultiplesOf\");\n            yield return i;\n        \n      \n\n\n   \n\n \n\n** Para que dentro de un método se pueda usar la palabra `yield`, este debe tener como tipo de retorno una de las dos variantes de `IEnumerable`.**  \n\nA simple vista pareciera que hacen lo mismo: encontrar los números divisibles entre `n`. La diferencia entre ellos radica en que mientras que uno crea una secuencia intermedia y almacena todos los valores antes de devolverlos, el otro devuelve uno por uno a quién lo llamó.\n\nPara que veas el funcionamiento, vamos a llamarlos dentro de un ciclo `foreach`:\n\n<div class=\"pure-g\">\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\nConsole.WriteLine(\"Normal collection\");\nforeach (var m in GetMultiplesOf(2, 1, 10))\n\n    Console.WriteLine($\"m es multiplo de 2\");\n\n</pre> \n</div>\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\nConsole.WriteLine(\"Yield collection\");\nforeach (var m in YieldMultiplesOf(2, 1, 10))\n\n    Console.WriteLine($\"m es multiplo de 2\");\n\n</pre>   \n</div> \n</div>\n\nEl resultado de ejecutarlas es el siguiente:\n\n<div class=\"pure-g\">\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre>\nNormal collection\n2 GetMultiplesOf\n4 GetMultiplesOf\n6 GetMultiplesOf\n8 GetMultiplesOf\n2 es multiplo de 2\n4 es multiplo de 2\n6 es multiplo de 2\n8 es multiplo de 2\n</pre>\n</div>\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre>\nYield collection\n2 YieldMultiplesOf\n2 es multiplo de 2\n4 YieldMultiplesOf\n4 es multiplo de 2\n6 YieldMultiplesOf\n6 es multiplo de 2\n8 YieldMultiplesOf\n8 es multiplo de 2\n</pre>\n</div> \n</div>  \n\nWow, wow, ¿viste lo que ocurrió? mientras que en el que no usa `yield` se calcularon todos los valores en una sola llamada y se almacenaron en una lista temporal, en el otro solamente se calculó uno por uno y solamente cuando fue requerido. Evitándonos así tener que crear colecciones auxiliares para almacenar los datos.  \n\nPara comprender un poco mejor el funcionamiento, mira estas imágenes:\n\n<div class=\"pure-g\">\n<div class=\"pure-u-1 pure-u-md-1-2\">\n post_image get.png \"Normal Enumerable\" \n</div>\n<div class=\"pure-u-1 pure-u-md-1-2\">\n post_image yield.png \"Yield Enumerable\" \n</div>\n</div>\n\nEn resumidas palabras, `yield` nos ayuda a implementar una especie de *\"lazy loading\"* en nuestro código introduciendo saltos entre un método y quien lo llamó para evitar así desperdiciar memoria en colecciones intermedias. Eso sin mencionar que usando esta técnica también podemos asegurar que para una determinada operación sobre un `IEnumerable` siempre se ejecutará la menor cantidad de iteraciones posibles.\n\nMira el siguiente ejemplo, en donde se aplican algunas operaciones de Linq:  \n\n<div class=\"pure-g\">\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\nvar get = GetMultiplesOf(2, 320, 335)\n            .Skip(3)\n            .First();\nConsole.WriteLine($\"El 4to multiplo es get\");\n</pre>  \n</div>\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\nvar yield = YieldMultiplesOf(2, 320, 335)\n                .Skip(3)\n                .First();\nConsole.WriteLine($\"El 4to multiplo es yield\");\n</pre>\n</div>\n</div>\n\nY su resultado es el siguiente. Debes notar que para el caso de la colección intermedia se calcularon todos los valores posibles, mientras que para cuando se usó `yield` solo se calcularon los valores necesaros:\n\n<div class=\"pure-g\">\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre>\n320 GetMultiplesOf\n322 GetMultiplesOf\n324 GetMultiplesOf\n326 GetMultiplesOf\n328 GetMultiplesOf\n330 GetMultiplesOf\n332 GetMultiplesOf\n334 GetMultiplesOf\nEl 4to multiplo es 326\n</pre>\n</div>\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre>\n320 YieldMultiplesOf\n322 YieldMultiplesOf\n324 YieldMultiplesOf\n326 YieldMultiplesOf\nEl 4to multiplo es 326\n\n\n\n\n</pre>\n</div> \n</div>  \n\n## Multiples returns\n\nAl igual que cuando usamos `return`, un método puede contener varias instrucciones `yield return`. Por ejemplo, imagina un programa en donde tengas que calcular los factores primos de un número:\n\n<pre class=\"csharp\">\npublic static IEnumerable<int> PrimeFactors(int n)\n\n    while (n  2 == 0)\n    \n        yield return 2;\n        n = n / 2;\n    \n\n    for (int i = 3; i &lt;= Math.Sqrt(n); i += 2)\n    \n        while (n  i == 0)\n        \n            yield return i;\n            n = n / i;\n        \n    \n\n    if (n &gt; 2)\n        yield return n;\n\n  \n\n\n**Por otro lado, si en algun momento queremos terminar la ejecución de este método podemos usar la combinación de palabras `yield break` para hacerlo.**\n\nSin duda también nos ayuda a implementar la \"lazy evaluation\" y ejecutar el código solamente cuando lo necesitamos, con ella nos ahorramos el crear una colección intermedia entre la fuente que generará los resultados y el destino de estos.\n\n\n## Funcionamiento interno   \nLa palabra `yield` opera insertando saltos entre el método llamado y el código que lo llama... como vimos en una imagen anterior. Pero para que esto funcione, se debe almacenar cierta información que le indique al método llamado  en qué estado se encontraba antes de volver a ser ejecutado. Es por eso que cuando usamos la palabra `yield` el compilador entra en acción para nosotros, crea una clase intermedia en donde se almacena la información del estado de la iteración siguiente, te recomiendo que visites este enlace si deseas saber más.\n\n## Ejemplos de uso  \nLos ejemplos mostrados en el código pueden parecer un poco absurdos (lo sé) pero por ejemplo, ¿qué sucedería si en lugar de buscar los factores primos de un número, tuviéramos que encontrar una persona en un repositorio de datos de 1,000,000 de registros? o, ¿qué ocurriría con la memoria de nuestra computadora si tuviéramos que trabajar con las líneas de un archivo de 1Gb?\n</int></pre></int></pre></div></int></int></int></pre></div></div>\n"
}