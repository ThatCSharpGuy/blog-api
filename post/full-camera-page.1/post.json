{	
	"id" : "/post/full-camera-page.1/",
	"tv" : false,
	"date": "2016-11-08 02:00:00 -0600",
	"title" : "Full page camera in Xamarin.Forms",
	"author" : "Antonio Feregrino Bola√±os",
	"featured_image": "http://thatcsharpguy.com/postimages//xamarin-forms/camerapage/featured.jpg",
	"tags" : ["XamarinForms","Xamarin"],
	"content": "It has been a while since I coded <a href=\"..\\Aharphat-Android\" target=\"_blank\">CharpHat</a>, which is an app that lets you snap a picture of anything and then put a nice C# graduation cap on it. That app was far from perfect, but it helped me to practice the usage of custom page renderers.  \n\nToday I decided to retake that project, but this time trying to isolate the code needed to build the interface and funcionality of the page, so that anyone looking forward to implement a full camera page in their apps could reuse the code for their own projects. So be sure to <strong><a href=\"https://github.com/ThatCSharpGuy/Forms-FullCameraPage\" target=\"_blank\">grab the source code</a></strong> for this post.\n\n## Forms abstractions  \n<small><a href=\"https://github.com/ThatCSharpGuy/Forms-FullCameraPage/blob/master/CameraPage.cs\" target=\"_blank\">Here is the source code for this section.</a></small>  \n\nLet's start by creating the Xamarin.Forms page that will serve as our point of interaction with the custom code:  \n\n<pre class=\"csharp\">\npublic class CameraPage : ContentPage\n\n    public delegate void PhotoResultEventHandler(PhotoResultEventArgs result);\n    public event PhotoResultEventHandler OnPhotoResult;\n</pre>  \n\nBusiness as usual, create a class deriving from `ContentPage`. I have added an event handler as I want to access the picture taken by the user. Now let's throw in some methods to call whenever an user performs an action in our camera page (in this case, the user will be allowed to take a photo or cancel the action):\n\n<pre class=\"csharp\">\npublic void SetPhotoResult(byte[] image, int width = -1, int height = -1)\n\n    OnPhotoResult?.Invoke(new PhotoResultEventArgs(image, width, height));\n\n\npublic void Cancel()\n\n    OnPhotoResult?.Invoke(new PhotoResultEventArgs());\n \n</pre>  \n\nFor reference, see the properties inside the `PhotoResultEventArgs` class:\n\n<pre class=\"csharp\">\npublic bool Success  get; private set; \npublic int Width  get; private set; \npublic int Height  get; private set; \npublic byte[] Image  get; private set; \n</pre>  \n\nNow, time to move on to the platform specifics. \n\n## In Xamarin.iOS    \n<small><a href=\"https://github.com/ThatCSharpGuy/Forms-FullCameraPage/blob/master/iOS/CameraPageRenderer.cs\" target=\"_blank\">Here is the source code for this section.</a></small>  \n\nTo be honest, this implementation is the easiest by far. Start off by creating a class that inherits from `PageRenderer`, and to add the `ExportRenderer` attribute:\n\n<pre class=\"csharp\">\n[assembly: ExportRenderer(typeof(CameraPage), typeof(CameraPageRenderer))]\nnamespace FullCameraPage.iOS\n\n\tpublic class CameraPageRenderer : PageRenderer\n</pre>  \n\nNow, an this is very important, you need to override the `ViewDidLoad` method, since it gets called as soon as our page is loaded by the iOS mechanisms. For the sake of organisation let's split the code in several other methods:  \n\n<pre class=\"csharp\">\npublic override async void ViewDidLoad()\n\n    base.ViewDidLoad();\n    SetupUserInterface();\n    SetupEventHandlers();\n    AuthorizeCameraUse();\n    SetupLiveCameraStream();\n\n</pre>  \n\n### SetupUserInterface \nAs the name states, here is where you need to build the UI. As you may have guessed, it is all done by code, but don't worry, it is very easy... as long as your UI isn't so complex, but you can do whatever you need here.  \n\nFor this sample the UI will consist of a couple of buttons and a surface where the live preview from the camera is going to be shown, so you need to declare them on a class-level scope:  \n\n<pre class=\"csharp\">\nVectorButton takePhotoButton;\nVectorButton cancelPhotoButton;\nUIView liveCameraStream;\n</pre>  \n\nTo set the items in place you need to think as if you were working with a relative layout, meaning that you need to set the position of each item within the screen. For example, look at how the live camera preview view is positioned:\n\n<pre class=\"csharp\">\nprivate void SetupUserInterface()\n\n    // Code ommited ...\n    liveCameraStream = new UIView()\n    \n        Frame = new CGRect(0f, 0f, View.Bounds.Width, View.Bounds.Height)\n    ;\n    // Code ommited ...\n    View.Add(liveCameraStream);\n    // Code ommited ...\n\n</pre>  \n\n### SetupEventHandlers\nNow that the UI has been built, let's hook up the event handlers to each control, luckly for this sample there are only two buttons on screen: one to take the picture and the other to cancel the whole thing.\n\n<pre class=\"csharp\">\ncancelPhotoButton.TouchUpInside += (s, e) =>\n\n    (Element as CameraPage).Cancel();\n;\n\ntakePhotoButton.TouchUpInside += async (s, e) =>\n\n    var data = await CapturePhoto();\n    UIImage imageInfo = new UIImage(data);\n\n    (Element as CameraPage).SetPhotoResult(data.ToArray(),\n                                           (int)imageInfo.Size.Width,\n                                           (int)imageInfo.Size.Height);\n;\n</pre>  \n\nThe property `Element` contains a reference to the page associated to the renderer, and is our way to interact with our Forms project. As for the method `CapturePhoto`... we'll see it later. \n\n## AuthorizeCameraUse  \nNow it's time to ask the user for its permission to access the camera: \n\n<pre class=\"csharp\">\nvar authorizationStatus = AVCaptureDevice.GetAuthorizationStatus(AVMediaType.Video);\nif (authorizationStatus != AVAuthorizationStatus.Authorized)\n\n    await AVCaptureDevice.RequestAccessForMediaTypeAsync(AVMediaType.Video);\n\n</pre>  \n\nBut wait a minute, before executing the code above, make sure you have added the key `Privacy - Camera Usage Description` to the Info.plist in your project.  \n\n### SetupLiveCameraStream\nNow the \"heavy\" stuff.  \n  \nStart by declaring at class-level scope an `AVCaptureSession`, `AVCaptureDeviceInput` and `AVCaptureStillImageOutput`, as they will hel us access the camera, display the live feed and capture the photo.  \n\nThen, inside the `SetupLiveCameraStream` method, initialize the capture session, create a preview layer with the same size as our `liveCameraStream`, and add it as a sublayer of it:\n\n<pre class=\"csharp\">\n    captureSession = new AVCaptureSession();\n    var videoPreviewLayer = new AVCaptureVideoPreviewLayer(captureSession)\n    \n        Frame = liveCameraStream.Bounds\n    ;\n    liveCameraStream.Layer.AddSublayer(videoPreviewLayer);\n</pre>    \n\nNext, \"create\" a capture device (you can configure it to work according to your needs). And then, from it create the an input source for the capture session:\n\n<pre class=\"csharp\">\n    var captureDevice = AVCaptureDevice.DefaultDeviceWithMediaType(AVMediaType.Video);\n    ConfigureCameraForDevice(captureDevice);\n    captureDeviceInput = AVCaptureDeviceInput.FromDevice(captureDevice);\n</pre>  \n\nWe have an input (the camera of the device), now we need an output which is going to be a jpeg photograph:\n\n<pre class=\"csharp\">\n    var dictionary = new NSMutableDictionary();\n    dictionary[AVVideo.CodecKey] = new NSNumber((int)AVVideoCodec.JPEG);\n    stillImageOutput = new AVCaptureStillImageOutput()\n    \n        OutputSettings = new NSDictionary()\n    ;\n</pre>  \n\nFinalize by setting the input and output of the capture session and starting it: \n\n<pre class=\"csharp\">\n    captureSession.AddOutput(stillImageOutput);\n    captureSession.AddInput(captureDeviceInput);\n    captureSession.StartRunning();\n</pre>\n\n### CapturePhoto\nAt last, the icing on the cake, the code to capture the photo. The code is pretty simple: Take the output and capture a still image from it, as we only need the bytes we get an `NSData` containing the taken photo. \n\n<pre class=\"csharp\">\npublic async Task<NSData> CapturePhoto()\n\n    var videoConnection = stillImageOutput.ConnectionFromMediaType(AVMediaType.Video);\n    var sampleBuffer = await stillImageOutput.CaptureStillImageTaskAsync(videoConnection);\n    var jpegImageAsNsData = AVCaptureStillImageOutput.JpegStillToNSData(sampleBuffer);\n    return jpegImageAsNsData;\n\n</pre>\n\n## In Xamarin.Android    \n<small><a href=\"https://github.com/ThatCSharpGuy/Forms-FullCameraPage/blob/master/Droid/CameraPageRenderer.cs\" target=\"_blank\">Here is the source code for this section.</a></small>    \nThis implementation isn't as clean as it is in iOS. Mainly because Android puts a lot of ephasis in the use of listeners, rather than in event handlers. However, that is not a problem for us.\n\nAs with the iOS implementation, start by creating a new class and make it derive from `PageRenderer` and also make it implement the `TextureView.ISurfaceTextureListener` interface. Don't forget the `ExportRender` attribute:\n\n<pre class=\"csharp\">\n[assembly: Xamarin.Forms.ExportRenderer(typeof(CameraPage), typeof(CameraPageRenderer))]\nnamespace FullCameraPage.Droid\n\n    public class CameraPageRenderer : PageRenderer, TextureView.ISurfaceTextureListener\n</pre>  \n\nThen, override the `OnElementChanged` method (if you have creaated custom renderers before this method may be familar to you), this method is going to be called everytime the a `CamerPage` is shown on screen:\n\n<pre class=\"csharp\">\nprotected override void OnElementChanged(ElementChangedEventArgs<Xamarin.Forms.Page> e)\n\n    base.OnElementChanged(e);\n    SetupUserInterface();\n    SetupEventHandlers();\n</pre>  \n\n### SetupUserInterface  \nIn this method we are supposed to create the camera page itself, you can do it by creating an *axml* file and calling all the Android inflating stuff... Or, like in this sample, you can create it by code.\n\nFor this sample, we'll need a `RelativeLayout` to work as a container, a `TextureView` to display the live feed from the camera, and a `Button` (a `PaintCodeButton` actually) to snap the photograph. Declare all them at class-level scope: \n\n<pre class=\"csharp\">\nRelativeLayout mainLayout;\nTextureView liveView;\nPaintCodeButton capturePhotoButton;\n</pre>  \n\nNow, proceed to create them and add them to the screen, for example, see how we can create the container layout and add the `TextureView` to it:  \n\n<pre class=\"csharp\">\nvoid SetupUserInterface()\n\n    mainLayout = new RelativeLayout(Context);\n    RelativeLayout.LayoutParams mainLayoutParams = new RelativeLayout.LayoutParams(\n        RelativeLayout.LayoutParams.MatchParent,\n        RelativeLayout.LayoutParams.MatchParent);\n    mainLayout.LayoutParameters = mainLayoutParams;\n\n    liveView = new TextureView(Context);\n    RelativeLayout.LayoutParams liveViewParams = new RelativeLayout.LayoutParams(\n        RelativeLayout.LayoutParams.MatchParent, \n        RelativeLayout.LayoutParams.MatchParent);\n    liveView.LayoutParameters = liveViewParams;\n    mainLayout.AddView(liveView);\n    \n    // Code ommited...\n\n    AddView(mainLayout);\n\n</pre>  \n\nBefore continuing, there is another method (`OnLayout`) we need to override to give our main layout it's size (and acommodate the UI accordingly): \n\n<pre class=\"csharp\">\nprotected override void OnLayout(bool changed, int l, int t, int r, int b)\n\n    base.OnLayout(changed, l, t, r, b);\n    if (!changed)\n        return;\n    var msw = MeasureSpec.MakeMeasureSpec(r - l, MeasureSpecMode.Exactly);\n    var msh = MeasureSpec.MakeMeasureSpec(b - t, MeasureSpecMode.Exactly);\n    mainLayout.Measure(msw, msh);\n    mainLayout.Layout(0, 0, r - l, b - t);\n\n    capturePhotoButton.SetX( mainLayout.Width / 2 - 60);\n    capturePhotoButton.SetY(mainLayout.Height - 200);\n\n</pre>  \n\n### SetupEventHandlers  \nAs I said, Android relies mostly on event listeners rather than handlers, so the code for this method is pretty simple. We need to set an event handler for the \"sutter\" button and assign the listener that will be aware of the `SurfaceTexture` status (remember that our page render implements an interface?):  \n\n<pre class=\"csharp\">\ncapturePhotoButton.Click += async (sender, e) =>\n\n    var bytes = await TakePhoto();\n    (Element as CameraPage).SetPhotoResult(bytes, liveView.Bitmap.Width, liveView.Bitmap.Height);\n;\nliveView.SurfaceTextureListener = this;\n</pre>  \n\nAnd one more thing, let's to override the default behavior of the \"back\" button, so that it acts as a cancel button for the camera:\n\n<pre class=\"csharp\">\npublic override bool OnKeyDown(Keycode keyCode, KeyEvent e)\n\n    if (keyCode == Keycode.Back)\n    \n        (Element as CameraPage).Cancel();\n        return false;\n    \n    return base.OnKeyDown(keyCode, e);\n\n</pre>   \n\n### TextureView.ISurfaceTextureListener implementation  \nNow is time to implement the core of our page. Start by writing the code for the `OnSurfaceTextureAvailable` where we will prepare the output for the camera, but first we'll need a camera, right?\n\nAt class-level scope declare a `Camera`:  \n\n<pre class=\"csharp\">\nAndroid.Hardware.Camera camera;\n</pre>\n \nInside the method, open the camera (by default it'll try to open the back camera of the device) and get its parameters. We need them to select the right preview size, because we want things to look great in our app:\n\n<pre class=\"csharp\">\ncamera = Android.Hardware.Camera.Open();\nvar parameters = camera.GetParameters();\n</pre> \n\nOnce we have the parameters at hand, we can get the avaliable `PreviewSizes` and get the one that fits our preview surface. In this case I'm using a simple <a href=\"#\">linq expression</a> to get the best preview size based on aspect ratio:\n\n<pre class=\"csharp\">\nvar aspect = ((decimal)height) / ((decimal)width);\n\nvar previewSize = parameters.SupportedPreviewSizes\n                            .OrderBy(s => Math.Abs(s.Width / (decimal)s.Height - aspect))\n                            .First();\n\nparameters.SetPreviewSize(previewSize.Width, previewSize.Height);\ncamera.SetParameters(parameters);\n</pre> \n\nFinish by setting our surface as the preview texture, at this point the only thing left to do is to start the camera:\n\n<pre class=\"csharp\">\ncamera.SetPreviewTexture(surface);\nStartCamera();\n</pre> \n\nThe other method we need to write code into is `OnSurfaceTextureDestroyed` in order to stop the camera, so just write the following inside and it'll be all:  \n\n<pre class=\"csharp\">\nStopCamera();\nreturn true;\n</pre> \n\n### StartCamera and StopCamera\nThese two methods are quite simple too, for `StartCamera` we only need to rotate the preview to make it look right in the screen (in this case I'm setting it to be viewed vertically), and then finally, start the camera:   \n\n<pre class=\"csharp\">\ncamera.SetDisplayOrientation(90);\ncamera.StartPreview();\n</pre> \n\nThe `StopCamera` method stops the preview and releases the camera, so that other apps can access to it:   \n\n<pre class=\"csharp\">\ncamera.StopPreview();\ncamera.Release();\n</pre> \n\n### TakePhoto\n\nIn order to get a photo, the only thing we need to do is get an sitll image from the live feed presented in the `TextureView`, here is the code to do so and then return the image in bytes:\n\n<pre class=\"csharp\">\ncamera.StopPreview();\nvar ratio = ((decimal)Height) / Width;\nvar image = Bitmap.CreateBitmap(liveView.Bitmap, 0, 0, liveView.Bitmap.Width, (int)(liveView.Bitmap.Width * ratio));\nbyte[] imageBytes = null;\nusing (var imageStream = new System.IO.MemoryStream())\n\n    await image.CompressAsync(Bitmap.CompressFormat.Jpeg, 50, imageStream);\n    image.Recycle();\n    imageBytes = imageStream.ToArray();\n\ncamera.StartPreview();\nreturn imageBytes;\n</pre> \n\nAnd that's it, after all that code, you can now make use of this camera page. Keep reading to find a sample usage code:\n\n## Usage in Forms  \n\n<pre class=\"csharp\">\nvar cameraPage = new CameraPage();\ncameraPage.OnPhotoResult += CameraPage_OnPhotoResult;\nNavigation.PushModalAsync(cameraPage);  \n// ...\nasync void CameraPage_OnPhotoResult(Pages.PhotoResultEventArgs result)\n\n    await Navigation.PopModalAsync();\n    if (!result.Success)\n        return;\n    Image.Source = ImageSource.FromStream(() => new MemoryStream(result.Image));\n</pre>  \n\nIf you <strong><a href=\"https://github.com/ThatCSharpGuy/Forms-FullCameraPage\" target=\"_blank\">download the source code</a></strong> and run it, you will see something like this:\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/DgFEK9tPKs0\" frameborder=\"0\" allowfullscreen></iframe>\n\n\n\n## Acknowledgements \nThe code for this post was entirely based on the code from the <a href=\"..\\Aharphat-Android\" target=\"_blank\">CharpHat</a>, which at the same time was based on the <a href=\"https://blog.xamarin.com/build-your-own-snapchat-clone-with-xamarin-forms-and-azure/\" target=\"_blank\">Moments app</a> by <a href=\"https://github.com/pierceboggan\" target=\"_blank\">Pierce Boggan</a>."
}