{	
	"id" : "/post/flurl/",
	"tv" : false,
	"date": "2016-04-25 14:00:00 -0500",
	"title" : "La web es tuya con Flurl",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimagesfeatured.png",
	"tags" :
	["NuGetRecomendado"],
	
	"content" : body"En la actualidad la mayoría de las apps que conocemos tienen alguna interacción con internet: ya sea para realizar publicaciones a Facebook o Twitter, para recuperar información acerca del clima o el tráfico o para actualizar tu puntuación en un juego.\r\n\r\nEs por eso que seguramente las aplicaciones que tu desarrolles también tengan que incluir esta interacción... y mientras que podrías tu mismo programar toda la infraestructura para realizar peticiones, ¿por qué no usar una librería que ya lo hace? En este post te voy a hablar de Flurl y Flurl.Http, que son librerías con una api fluida que facilitan la escritura y ejecución de peticiones HTTP.\r\n\r\n## Construcción de URLs  \r\nDe entrada, podría parecerte sencillo crear URLs por tu cuenta, pero cuando menos te das cuenta resulta que olvidaste poner un '/' y todo el código está mal. Con Flurl te puedes olvidar de esos problemas:\r\n\r\nEl método `AppendPathSegment` ayuda a añadir un segmento de URL a otra, al ser una api fluida, podemos *encadenar* varias llamadas a `AppendPathSegment`:\r\n\r\n{% highlight csharp %}\r\n var myCoolUrl2 = \"http://localhost/\"\r\n    .AppendPathSegment(\"sales\")\r\n    .AppendPathSegment(\"Q1\")\r\n    .AppendPathSegment(\"max\");\r\nConsole.WriteLine(myCoolUrl2);\r\n{% endhighlight %}  \r\n\r\nAl final, `myCoolUrl2` es:\r\n\r\n<pre>\r\nhttp://localhost/sales/Q1/max\r\n</pre> \r\n\r\nEl método devuelve un objeto del tipo `Url`, sobre el que podemos trabajar y que es directamente transformable en una cadena de texto.\r\n\r\nSi lo que necesitamos es añadir muchos segmentos a una URL, tal vez sea más conveniente hacerlo a través de un arreglo, tal vez sea mejor usar `AppendPathSegments`. Este método es similar al anterior, solo que opera con un mútliples segmentos de URL que son enviados en un arreglo marcado <a href=\"/params-c-sharp\">como params</a>:\r\n\r\n{% highlight csharp %}\r\nvar urlParts = new string[] { \"liga_mx\", \"results\", \"america\" };\r\nvar builtUrl2 = new Url(\"http://api.soccer-data.com\");\r\nbuiltUrl2.AppendPathSegments(urlParts);\r\nConsole.WriteLine(builtUrl2);\r\n{% endhighlight %}  \r\n\r\nAl final, `builtUrl2` es:\r\n\r\n<pre>\r\nhttp://api.soccer-data.com/liga_mx/results/america\r\n</pre> \r\n\r\n### Query string\r\nFlurl también tiene la capacidad de añadir parámetros a la *query string* de una URL usando el método `SetQueryParams`, para lo cual se crea un objeto anónimo:\r\n\r\n{% highlight csharp %}\r\nvar endDate = DateTime.Today;\r\nvar startDate = endDate.AddDays(-30);\r\nbuiltUrl.SetQueryParams(new { endDate, startDate, c = \"concacaf champions league\" });\r\nConsole.WriteLine(builtUrl);\r\n{% endhighlight %}\r\n\r\nAl final, `builtUrl` es:\r\n\r\n<pre>\r\nhttp://api.soccer-data.com/liga_mx/results/america?endDate=04%2F25%2F2016%2000%3A00%3A00&startDate=03%2F26%2F2016%2000%3A00%3A00&c=concacaf%20champions%20league\r\n</pre> \r\n\r\nComo puedes darte cuenta, los nombres de las propiedades en el objeto anónimo `new { endDate, startDate, c = competition }` fueron respetadas y los parámetros fueron codificados como URL para ser enviados en una petición HTTP.\r\n\r\nTambién podemos quitar parámetros de la *query string* con `RemoveQueryParams`:\r\n\r\n{% highlight csharp %}\r\nbuiltUrl.RemoveQueryParams(\"c\", \"startDate\");\r\nConsole.WriteLine(builtUrl);\r\n{% endhighlight %}\r\n\r\nAl final, `builtUrl` es:\r\n\r\n<pre>\r\nhttp://api.soccer-data.com/liga_mx/results/america?endDate=04%2F25%2F2016%2000%3A00%3A00\r\n</pre> \r\n\r\n## Creación de un cliente HTTP\r\nA partir de tener una URL construida con los métodos anteriores, podemos comenzar a configurar nuestro cliente HTTP:\r\n\r\n{% highlight csharp %}\r\nvar client = myCoolUrl1\r\n    .WithBasicAuth(\"antonio\", \"secretPass\")\r\n    .WithHeader(\"User-Agent\", \"Flurl-Sample\");\r\n{% endhighlight %}\r\n\r\nAhora, cada vez que hagamos una petición con un cliente creado por esta URL, contendrá el encabezado siguiente:\r\n\r\n<pre>\r\nAuthorization: Basic YW50b25pbzpzZWNyZXRQYXNz  \r\nUser-Agent: Flurl-Sample\r\n</pre> \r\n\r\nTambién tenemos más opciones, como la de asignar varios encabezados a la vez:\r\n\r\n{% highlight csharp %}\r\nvar client2 = builtUrl\r\n    .WithOAuthBearerToken(\"t0k3n\")\r\n    .WithHeader(\"Accept-Language\", \"it\")\r\n    .WithHeader(\"User-Agent\", \"Flurl-Sample\")\r\n    .WithHeaders(new\r\n    {\r\n        CustomHeader = \"Another value\",\r\n        Accept = \"text/json\"\r\n    });\r\n{% endhighlight %}\r\n\r\nCuyo resultado es:\r\n\r\n<pre>\r\nAuthorization: Bearer t0k3n  \r\nAccept-Language: it  \r\nUser-Agent: Flurl-Sample  \r\nCustomHeader: Another value  \r\nAccept: text/json  \r\n</pre> \r\n\r\n## Ejecución de peticiones\r\nYa sea con un cliente HTTP o con una Url podemos comenzar a realizar peticiones asíncronas. Para este ejemplo, usaré la <a href=\"http://pokeapi.co/\" target=\"_blank\">Pokéapi</a>:\r\n\r\n{% highlight csharp %}\r\nvar pokemonId = 25;\r\nvar url1 = \"http://pokeapi.co/api/v2/\"\r\n    .AppendPathSegment(\"pokemon\")\r\n    .AppendPathSegment(pokemonId.ToString());\r\n\r\nConsole.WriteLine(\"Consultando \" + url1); // Consultando http://pokeapi.co/api/v2/pokemon/25\r\n{% endhighlight %}\r\n\r\nA partir de aquí podemos obtener un objeto dinámico con `GetJsonAsync`:\r\n\r\n{% highlight csharp %}\r\ndynamic pkmn1 = await url1.GetJsonAsync(); // pkmn1 \r\nConsole.WriteLine(pkmn1.name + \" \" + \"\\nH:\" + pkmn1.height + \"\\nW:\" + pkmn1.weight + \"\\n\");\r\n{% endhighlight %}\r\n\r\n<pre>\r\npikachu\r\nH:4\r\nW:60\r\n</pre>\r\n\r\nO crear una clase que contenga las propiedades del objeto que vamos a recibir para que el resultado que tenemos sea fuertemente tipado, usando `GetJsonAync<T>` :\r\n\r\n{% highlight csharp %}\r\nvar pokemon = await url2.GetJsonAsync<Pokemon>();\r\nConsole.WriteLine(pokemon.Name + \"\\nH:\" + pokemon.Height + \"\\nW:\" + pokemon.Weight + \"\\n\");\r\n{% endhighlight %}\r\n\r\n<pre>\r\ncharmander\r\nH:6\r\nW:85\r\n</pre>\r\n\r\nFlurl también permite hacer peticiones POST mediante `PostJsonAsync` o `PostUrlEncodedAsync`, además de integrar el manejo de errores mediante la `FlurlHttpException` que contiene la información necesaria acerca del error sucedido, por ejemplo, mira el manejo de esta excepción\r\n\r\n{% highlight csharp %}\r\ncatch (FlurlHttpException ex)\r\n{\r\n    if (ex.Call.Response != null\r\n        && ex.Call.Response.StatusCode == HttpStatusCode.NotFound)\r\n    {\r\n        Console.WriteLine(\"No existe un pokemon llamado \" + pokemonName);\r\n    }\r\n}\r\n{% endhighlight %}\r\n\r\n\r\nNo olvides que puedes consultar todo el código de este ejemplo en <a href=\"https://github.com/ThatCSharpGuy/Flurl-Sample\" target=\"_blank\">https://github.com/ThatCSharpGuy/Flurl-Sample</a>.\r\n\r\n\r\n## Conclusión\r\nAl principio pareciera que la construcción de URLs, configuración de clientes y ejecución de peticiones HTTP es tan sencillo que tu mismo puedes gestionarlo todo, pero depende del tamaño de lo que quieres lograr. Si tu interés es delegar esta tarea a librerías de terceros, Flurl es una gran opción y es que además de lo poco que traté de mostrar en este post, aún hay más, entre ellas la facilidad que nos brinda a la hora de hacer *testing*.\r\n \r\n# Instalación  \r\nPara instalarlo no hay mejor manera que el gestor de paquetes de NuGet, instala solo Flurl si quieres solo los beneficios de la construcción de URLs o Flurl.Http si quieres el paquete completo:\r\n\r\n{% console titulo %}\r\nPM> Install-Package Flurl\r\n{% endconsole %}\r\n\r\n{% console titulo %}\r\nPM> Install-Package Flurl.Http\r\n{% endconsole %}\r\n\r\nO échale un ojo al <a href=\"https://github.com/tmenier/Flurl\" target=\"_blank\" rel=\"nofollow\">proyecto en GitHub</a> y contribuir a su desarrollo de alguna manera."
}