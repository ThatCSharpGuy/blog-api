{	
	"id" : "/post/flurl/",
	"tv" : false,
	"date": "2016-04-25 14:00:00 -0500",
	"title" : "La web es tuya con Flurl",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages/flurl/featured.png",
	"tags" : ["NuGetRecomendado"],
	"content": "<p>En la actualidad la mayoría de las apps que conocemos tienen alguna interacción con internet: ya sea para realizar publicaciones a Facebook o Twitter, para recuperar información acerca del clima o el tráfico o para actualizar tu puntuación en un juego.</p>\n\n<p>Es por eso que seguramente las aplicaciones que tu desarrolles también tengan que incluir esta interacción… y mientras que podrías tu mismo programar toda la infraestructura para realizar peticiones, ¿por qué no usar una librería que ya lo hace? En este post te voy a hablar de Flurl y Flurl.Http, que son librerías con una api fluida que facilitan la escritura y ejecución de peticiones HTTP.</p>\n\n<h2 id=\"construccin-de-urls\">Construcción de URLs</h2>\n<p>De entrada, podría parecerte sencillo crear URLs por tu cuenta, pero cuando menos te das cuenta resulta que olvidaste poner un ‘/’ y todo el código está mal. Con Flurl te puedes olvidar de esos problemas:</p>\n\n<p>El método <code>AppendPathSegment</code> ayuda a añadir un segmento de URL a otra, al ser una api fluida, podemos <em>encadenar</em> varias llamadas a <code>AppendPathSegment</code>:</p>\n\n<pre class=\"csharp\">\n var myCoolUrl2 = \"http://localhost/\"\n    .AppendPathSegment(\"sales\")\n    .AppendPathSegment(\"Q1\")\n    .AppendPathSegment(\"max\");\nConsole.WriteLine(myCoolUrl2);\n</pre>\n\n<p>Al final, <code>myCoolUrl2</code> es:</p>\n\n<pre>\nhttp://localhost/sales/Q1/max\n</pre>\n\n<p>El método devuelve un objeto del tipo <code>Url</code>, sobre el que podemos trabajar y que es directamente transformable en una cadena de texto.</p>\n\n<p>Si lo que necesitamos es añadir muchos segmentos a una URL, tal vez sea más conveniente hacerlo a través de un arreglo, tal vez sea mejor usar <code>AppendPathSegments</code>. Este método es similar al anterior, solo que opera con un mútliples segmentos de URL que son enviados en un arreglo marcado <a href=\"/params-c-sharp\">como params</a>:</p>\n\n<pre class=\"csharp\">\nvar urlParts = new string[]  \"liga_mx\", \"results\", \"america\" ;\nvar builtUrl2 = new Url(\"http://api.soccer-data.com\");\nbuiltUrl2.AppendPathSegments(urlParts);\nConsole.WriteLine(builtUrl2);\n</pre>\n\n<p>Al final, <code>builtUrl2</code> es:</p>\n\n<pre>\nhttp://api.soccer-data.com/liga_mx/results/america\n</pre>\n\n<h3 id=\"query-string\">Query string</h3>\n<p>Flurl también tiene la capacidad de añadir parámetros a la <em>query string</em> de una URL usando el método <code>SetQueryParams</code>, para lo cual se crea un objeto anónimo:</p>\n\n<pre class=\"csharp\">\nvar endDate = DateTime.Today;\nvar startDate = endDate.AddDays(-30);\nbuiltUrl.SetQueryParams(new  endDate, startDate, c = \"concacaf champions league\" );\nConsole.WriteLine(builtUrl);\n</pre>\n\n<p>Al final, <code>builtUrl</code> es:</p>\n\n<pre>\nhttp://api.soccer-data.com/liga_mx/results/america?endDate=042F252F201620003A003A00&amp;startDate=032F262F201620003A003A00&amp;c=concacaf20champions20league\n</pre>\n\n<p>Como puedes darte cuenta, los nombres de las propiedades en el objeto anónimo <code>new  endDate, startDate, c = competition </code> fueron respetadas y los parámetros fueron codificados como URL para ser enviados en una petición HTTP.</p>\n\n<p>También podemos quitar parámetros de la <em>query string</em> con <code>RemoveQueryParams</code>:</p>\n\n<pre class=\"csharp\">\nbuiltUrl.RemoveQueryParams(\"c\", \"startDate\");\nConsole.WriteLine(builtUrl);\n</pre>\n\n<p>Al final, <code>builtUrl</code> es:</p>\n\n<pre>\nhttp://api.soccer-data.com/liga_mx/results/america?endDate=042F252F201620003A003A00\n</pre>\n\n<h2 id=\"creacin-de-un-cliente-http\">Creación de un cliente HTTP</h2>\n<p>A partir de tener una URL construida con los métodos anteriores, podemos comenzar a configurar nuestro cliente HTTP:</p>\n\n<pre class=\"csharp\">\nvar client = myCoolUrl1\n    .WithBasicAuth(\"antonio\", \"secretPass\")\n    .WithHeader(\"User-Agent\", \"Flurl-Sample\");\n</pre>\n\n<p>Ahora, cada vez que hagamos una petición con un cliente creado por esta URL, contendrá el encabezado siguiente:</p>\n\n<pre>\nAuthorization: Basic YW50b25pbzpzZWNyZXRQYXNz  \nUser-Agent: Flurl-Sample\n</pre>\n\n<p>También tenemos más opciones, como la de asignar varios encabezados a la vez:</p>\n\n<pre class=\"csharp\">\nvar client2 = builtUrl\n    .WithOAuthBearerToken(\"t0k3n\")\n    .WithHeader(\"Accept-Language\", \"it\")\n    .WithHeader(\"User-Agent\", \"Flurl-Sample\")\n    .WithHeaders(new\n    \n        CustomHeader = \"Another value\",\n        Accept = \"text/json\"\n    );\n</pre>\n\n<p>Cuyo resultado es:</p>\n\n<pre>\nAuthorization: Bearer t0k3n  \nAccept-Language: it  \nUser-Agent: Flurl-Sample  \nCustomHeader: Another value  \nAccept: text/json  \n</pre>\n\n<h2 id=\"ejecucin-de-peticiones\">Ejecución de peticiones</h2>\n<p>Ya sea con un cliente HTTP o con una Url podemos comenzar a realizar peticiones asíncronas. Para este ejemplo, usaré la <a href=\"http://pokeapi.co/\" target=\"_blank\">Pokéapi</a>:</p>\n\n<pre class=\"csharp\">\nvar pokemonId = 25;\nvar url1 = \"http://pokeapi.co/api/v2/\"\n    .AppendPathSegment(\"pokemon\")\n    .AppendPathSegment(pokemonId.ToString());\n\nConsole.WriteLine(\"Consultando \" + url1); // Consultando http://pokeapi.co/api/v2/pokemon/25\n</pre>\n\n<p>A partir de aquí podemos obtener un objeto dinámico con <code>GetJsonAsync</code>:</p>\n\n<pre class=\"csharp\">\ndynamic pkmn1 = await url1.GetJsonAsync(); // pkmn1 \nConsole.WriteLine(pkmn1.name + \" \" + \"\\nH:\" + pkmn1.height + \"\\nW:\" + pkmn1.weight + \"\\n\");\n</pre>\n\n<pre>\npikachu\nH:4\nW:60\n</pre>\n\n<p>O crear una clase que contenga las propiedades del objeto que vamos a recibir para que el resultado que tenemos sea fuertemente tipado, usando <code>GetJsonAync&lt;T&gt;</code> :</p>\n\n<pre class=\"csharp\">\nvar pokemon = await url2.GetJsonAsync<pokemon>();\nConsole.WriteLine(pokemon.Name + \"\\nH:\" + pokemon.Height + \"\\nW:\" + pokemon.Weight + \"\\n\");\n\n\n<pre>\ncharmander\nH:6\nW:85\n</pre>\n\nFlurl también permite hacer peticiones POST mediante `PostJsonAsync` o `PostUrlEncodedAsync`, además de integrar el manejo de errores mediante la `FlurlHttpException` que contiene la información necesaria acerca del error sucedido, por ejemplo, mira el manejo de esta excepción\n\n<pre class=\"csharp\">\ncatch (FlurlHttpException ex)\n\n    if (ex.Call.Response != null\n        &amp;&amp; ex.Call.Response.StatusCode == HttpStatusCode.NotFound)\n    \n        Console.WriteLine(\"No existe un pokemon llamado \" + pokemonName);\n    \n\n</pre>\n\n\nNo olvides que puedes consultar todo el código de este ejemplo en <a href=\"https://github.com/ThatCSharpGuy/Flurl-Sample\" target=\"_blank\">https://github.com/ThatCSharpGuy/Flurl-Sample</a>.\n\n\n## Conclusión\nAl principio pareciera que la construcción de URLs, configuración de clientes y ejecución de peticiones HTTP es tan sencillo que tu mismo puedes gestionarlo todo, pero depende del tamaño de lo que quieres lograr. Si tu interés es delegar esta tarea a librerías de terceros, Flurl es una gran opción y es que además de lo poco que traté de mostrar en este post, aún hay más, entre ellas la facilidad que nos brinda a la hora de hacer *testing*.\n \n# Instalación  \nPara instalarlo no hay mejor manera que el gestor de paquetes de NuGet, instala solo Flurl si quieres solo los beneficios de la construcción de URLs o Flurl.Http si quieres el paquete completo:\n\n console titulo \nPM&gt; Install-Package Flurl\n endconsole \n\n console titulo \nPM&gt; Install-Package Flurl.Http\n endconsole \n\nO échale un ojo al <a href=\"https://github.com/tmenier/Flurl\" target=\"_blank\" rel=\"nofollow\">proyecto en GitHub</a> y contribuir a su desarrollo de alguna manera.\n</pokemon></pre>\n"
}