{	
	"id" : "/post/flurl/",
	"tv" : false,
	"date": "2016-04-25 14:00:00 -0500",
	"title" : "La web es tuya con Flurl",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimagesfeatured.png",
	"tags" :
	[ 
		"NuGetRecomendado"
	],
	"content" : "<p>En la actualidad la mayoría de las apps que conocemos tienen alguna interacción con internet: ya sea para realizar publicaciones a Facebook o Twitter, para recuperar información acerca del clima o el tráfico o para actualizar tu puntuación en un juego.</p>

<p>Es por eso que seguramente las aplicaciones que tu desarrolles también tengan que incluir esta interacción… y mientras que podrías tu mismo programar toda la infraestructura para realizar peticiones, ¿por qué no usar una librería que ya lo hace? En este post te voy a hablar de Flurl y Flurl.Http, que son librerías con una api fluida que facilitan la escritura y ejecución de peticiones HTTP.</p>

<h2 id=\"construccin-de-urls\">Construcción de URLs</h2>
<p>De entrada, podría parecerte sencillo crear URLs por tu cuenta, pero cuando menos te das cuenta resulta que olvidaste poner un ‘/’ y todo el código está mal. Con Flurl te puedes olvidar de esos problemas:</p>

<p>El método <code>AppendPathSegment</code> ayuda a añadir un segmento de URL a otra, al ser una api fluida, podemos <em>encadenar</em> varias llamadas a <code>AppendPathSegment</code>:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"> <span class="kt">var</span> <span class="n">myCoolUrl2</span> <span class="p">=</span> <span class="err">“</span><span class="n">http</span><span class="p">:</span><span class="c1">//localhost/”</span>
    <span class="p">.</span><span class="n">AppendPathSegment</span><span class="p">(</span><span class="err">“</span><span class="n">sales</span><span class="err">”</span><span class="p">)</span>
    <span class="p">.</span><span class="n">AppendPathSegment</span><span class="p">(</span><span class="err">“</span><span class="n">Q1</span><span class="err">”</span><span class="p">)</span>
    <span class="p">.</span><span class="n">AppendPathSegment</span><span class="p">(</span><span class="err">“</span><span class="n">max</span><span class="err">”</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">myCoolUrl2</span><span class="p">);</span></code></pre></figure></p>

<p>Al final, <code>myCoolUrl2</code> es:</p>

<pre>
http://localhost/sales/Q1/max
</pre>

<p>El método devuelve un objeto del tipo <code>Url</code>, sobre el que podemos trabajar y que es directamente transformable en una cadena de texto.</p>

<p>Si lo que necesitamos es añadir muchos segmentos a una URL, tal vez sea más conveniente hacerlo a través de un arreglo, tal vez sea mejor usar <code>AppendPathSegments</code>. Este método es similar al anterior, solo que opera con un mútliples segmentos de URL que son enviados en un arreglo marcado <a href=\"/params-c-sharp\">como params</a>:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">urlParts</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">string</span><span class="p">[]</span> <span class="p">{</span> <span class="err">“</span><span class="n">liga_mx</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">results</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">america</span><span class="err">”</span> <span class="p">};</span>
<span class="kt">var</span> <span class="n">builtUrl2</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Url</span><span class="p">(</span><span class="err">“</span><span class="n">http</span><span class="p">:</span><span class="c1">//api.soccer-data.com”);</span>
<span class="n">builtUrl2</span><span class="p">.</span><span class="n">AppendPathSegments</span><span class="p">(</span><span class="n">urlParts</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">builtUrl2</span><span class="p">);</span></code></pre></figure></p>

<p>Al final, <code>builtUrl2</code> es:</p>

<pre>
http://api.soccer-data.com/liga_mx/results/america
</pre>

<h3 id=\"query-string\">Query string</h3>
<p>Flurl también tiene la capacidad de añadir parámetros a la <em>query string</em> de una URL usando el método <code>SetQueryParams</code>, para lo cual se crea un objeto anónimo:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">endDate</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Today</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">startDate</span> <span class="p">=</span> <span class="n">endDate</span><span class="p">.</span><span class="n">AddDays</span><span class="p">(-</span><span class="m">30</span><span class="p">);</span>
<span class="n">builtUrl</span><span class="p">.</span><span class="n">SetQueryParams</span><span class="p">(</span><span class="k">new</span> <span class="p">{</span> <span class="n">endDate</span><span class="p">,</span> <span class="n">startDate</span><span class="p">,</span> <span class="n">c</span> <span class="p">=</span> <span class="err">“</span><span class="n">concacaf</span> <span class="n">champions</span> <span class="n">league</span><span class="err">”</span> <span class="p">});</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">builtUrl</span><span class="p">);</span></code></pre></figure></p>

<p>Al final, <code>builtUrl</code> es:</p>

<pre>
http://api.soccer-data.com/liga_mx/results/america?endDate=04%2F25%2F2016%2000%3A00%3A00&amp;startDate=03%2F26%2F2016%2000%3A00%3A00&amp;c=concacaf%20champions%20league
</pre>

<p>Como puedes darte cuenta, los nombres de las propiedades en el objeto anónimo <code>new { endDate, startDate, c = competition }</code> fueron respetadas y los parámetros fueron codificados como URL para ser enviados en una petición HTTP.</p>

<p>También podemos quitar parámetros de la <em>query string</em> con <code>RemoveQueryParams</code>:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="n">builtUrl</span><span class="p">.</span><span class="n">RemoveQueryParams</span><span class="p">(</span><span class="err">“</span><span class="n">c</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">startDate</span><span class="err">”</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">builtUrl</span><span class="p">);</span></code></pre></figure></p>

<p>Al final, <code>builtUrl</code> es:</p>

<pre>
http://api.soccer-data.com/liga_mx/results/america?endDate=04%2F25%2F2016%2000%3A00%3A00
</pre>

<h2 id=\"creacin-de-un-cliente-http\">Creación de un cliente HTTP</h2>
<p>A partir de tener una URL construida con los métodos anteriores, podemos comenzar a configurar nuestro cliente HTTP:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="n">myCoolUrl1</span>
    <span class="p">.</span><span class="n">WithBasicAuth</span><span class="p">(</span><span class="err">“</span><span class="n">antonio</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">secretPass</span><span class="err">”</span><span class="p">)</span>
    <span class="p">.</span><span class="n">WithHeader</span><span class="p">(</span><span class="err">“</span><span class="n">User</span><span class="p">-</span><span class="n">Agent</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">Flurl</span><span class="p">-</span><span class="n">Sample</span><span class="err">”</span><span class="p">);</span></code></pre></figure></p>

<p>Ahora, cada vez que hagamos una petición con un cliente creado por esta URL, contendrá el encabezado siguiente:</p>

<pre>
Authorization: Basic YW50b25pbzpzZWNyZXRQYXNz  
User-Agent: Flurl-Sample
</pre>

<p>También tenemos más opciones, como la de asignar varios encabezados a la vez:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">client2</span> <span class="p">=</span> <span class="n">builtUrl</span>
    <span class="p">.</span><span class="n">WithOAuthBearerToken</span><span class="p">(</span><span class="err">“</span><span class="n">t0k3n</span><span class="err">”</span><span class="p">)</span>
    <span class="p">.</span><span class="n">WithHeader</span><span class="p">(</span><span class="err">“</span><span class="n">Accept</span><span class="p">-</span><span class="n">Language</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">it</span><span class="err">”</span><span class="p">)</span>
    <span class="p">.</span><span class="n">WithHeader</span><span class="p">(</span><span class="err">“</span><span class="n">User</span><span class="p">-</span><span class="n">Agent</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">Flurl</span><span class="p">-</span><span class="n">Sample</span><span class="err">”</span><span class="p">)</span>
    <span class="p">.</span><span class="n">WithHeaders</span><span class="p">(</span><span class="k">new</span>
    <span class="p">{</span>
        <span class="n">CustomHeader</span> <span class="p">=</span> <span class="err">“</span><span class="n">Another</span> <span class="k">value</span><span class="err">”</span><span class="p">,</span>
        <span class="n">Accept</span> <span class="p">=</span> <span class="err">“</span><span class="n">text</span><span class="p">/</span><span class="n">json</span><span class="err">”</span>
    <span class="p">});</span></code></pre></figure></p>

<p>Cuyo resultado es:</p>

<pre>
Authorization: Bearer t0k3n  
Accept-Language: it  
User-Agent: Flurl-Sample  
CustomHeader: Another value  
Accept: text/json  
</pre>

<h2 id=\"ejecucin-de-peticiones\">Ejecución de peticiones</h2>
<p>Ya sea con un cliente HTTP o con una Url podemos comenzar a realizar peticiones asíncronas. Para este ejemplo, usaré la <a href=\"http://pokeapi.co/\" target=\"_blank\">Pokéapi</a>:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">pokemonId</span> <span class="p">=</span> <span class="m">25</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">url1</span> <span class="p">=</span> <span class="err">“</span><span class="n">http</span><span class="p">:</span><span class="c1">//pokeapi.co/api/v2/”</span>
    <span class="p">.</span><span class="n">AppendPathSegment</span><span class="p">(</span><span class="err">“</span><span class="n">pokemon</span><span class="err">”</span><span class="p">)</span>
    <span class="p">.</span><span class="n">AppendPathSegment</span><span class="p">(</span><span class="n">pokemonId</span><span class="p">.</span><span class="n">ToString</span><span class="p">());&lt;/</span><span class="n">p</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="n">p</span><span class="p">&gt;</span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">“</span><span class="n">Consultando</span> <span class="err">“</span> <span class="p">+</span> <span class="n">url1</span><span class="p">);</span> <span class="c1">// Consultando http://pokeapi.co/api/v2/pokemon/25</span></code></pre></figure></p>

<p>A partir de aquí podemos obtener un objeto dinámico con <code>GetJsonAsync</code>:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">dynamic</span> <span class="n">pkmn1</span> <span class="p">=</span> <span class="k">await</span> <span class="n">url1</span><span class="p">.</span><span class="n">GetJsonAsync</span><span class="p">();</span> <span class="c1">// pkmn1 </span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">pkmn1</span><span class="p">.</span><span class="n">name</span> <span class="p">+</span> <span class="err">“</span> <span class="err">“</span> <span class="p">+</span> <span class="err">“\</span><span class="n">nH</span><span class="p">:</span><span class="err">”</span> <span class="p">+</span> <span class="n">pkmn1</span><span class="p">.</span><span class="n">height</span> <span class="p">+</span> <span class="err">“\</span><span class="n">nW</span><span class="p">:</span><span class="err">”</span> <span class="p">+</span> <span class="n">pkmn1</span><span class="p">.</span><span class="n">weight</span> <span class="p">+</span> <span class="err">“\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span></code></pre></figure></p>

<pre>
pikachu
H:4
W:60
</pre>

<p>O crear una clase que contenga las propiedades del objeto que vamos a recibir para que el resultado que tenemos sea fuertemente tipado, usando <code>GetJsonAync&lt;T&gt;</code> :</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">pokemon</span> <span class="p">=</span> <span class="k">await</span> <span class="n">url2</span><span class="p">.</span><span class="n">GetJsonAsync</span><span class="p">&lt;</span><span class="n">pokemon</span><span class="p">&gt;();</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">pokemon</span><span class="p">.</span><span class="n">Name</span> <span class="p">+</span> <span class="err">\</span><span class="s">&quot;\nH:\&quot; + pokemon.Height + \&quot;\nW:\&quot; + pokemon.Weight + \&quot;\n\&quot;);</span></code></pre></figure></pokemon></p>

<pre>
charmander
H:6
W:85
</pre>

<p>Flurl también permite hacer peticiones POST mediante <code>PostJsonAsync</code> o <code>PostUrlEncodedAsync</code>, además de integrar el manejo de errores mediante la <code>FlurlHttpException</code> que contiene la información necesaria acerca del error sucedido, por ejemplo, mira el manejo de esta excepción</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">catch</span> <span class="p">(</span><span class="n">FlurlHttpException</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ex</span><span class="p">.</span><span class="n">Call</span><span class="p">.</span><span class="n">Response</span> <span class="p">!=</span> <span class="k">null</span>
        <span class="p">&amp;</span><span class="n">amp</span><span class="p">;&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">ex</span><span class="p">.</span><span class="n">Call</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="n">StatusCode</span> <span class="p">==</span> <span class="n">HttpStatusCode</span><span class="p">.</span><span class="n">NotFound</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">“</span><span class="n">No</span> <span class="n">existe</span> <span class="n">un</span> <span class="n">pokemon</span> <span class="n">llamado</span> <span class="err">“</span> <span class="p">+</span> <span class="n">pokemonName</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure></p>

<p>No olvides que puedes consultar todo el código de este ejemplo en <a href=\"https://github.com/ThatCSharpGuy/Flurl-Sample\" target=\"_blank\">https://github.com/ThatCSharpGuy/Flurl-Sample</a>.</p>

<h2 id=\"conclusin\">Conclusión</h2>
<p>Al principio pareciera que la construcción de URLs, configuración de clientes y ejecución de peticiones HTTP es tan sencillo que tu mismo puedes gestionarlo todo, pero depende del tamaño de lo que quieres lograr. Si tu interés es delegar esta tarea a librerías de terceros, Flurl es una gran opción y es que además de lo poco que traté de mostrar en este post, aún hay más, entre ellas la facilidad que nos brinda a la hora de hacer <em>testing</em>.</p>

<h1 id=\"instalacin\">Instalación</h1>
<p>Para instalarlo no hay mejor manera que el gestor de paquetes de NuGet, instala solo Flurl si quieres solo los beneficios de la construcción de URLs o Flurl.Http si quieres el paquete completo:</p>

<p><figure class="console"><pre><code>PM&gt; Install-Package Flurl</code></pre></figure></p>

<p><figure class="console"><pre><code>PM&gt; Install-Package Flurl.Http</code></pre></figure></p>

<p>O échale un ojo al <a href=\"https://github.com/tmenier/Flurl\" target=\"_blank\" rel=\"nofollow\">proyecto en GitHub</a> y contribuir a su desarrollo de alguna manera.</p>
"
}