{	
	"id" : "/post/flurl/",
	"tv" : false,
	"date": "2016-04-25 14:00:00 -0500",
	"title" : "La web es tuya con Flurl",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimagesfeatured.png",
	"tags" : ["NuGetRecomendado"],
	  
	"content": '"En la actualidad la mayoría de las apps que conocemos tienen alguna interacción con internet: ya sea para realizar publicaciones a Facebook o Twitter, para recuperar información acerca del clima o el tráfico o para actualizar tu puntuación en un juego.\r\n\r\nEs por eso que seguramente las aplicaciones que tu desarrolles también tengan que incluir esta interacción... y mientras que podrías tu mismo programar toda la infraestructura para realizar peticiones, ¿por qué no usar una librería que ya lo hace? En este post te voy a hablar de Flurl y Flurl.Http, que son librerías con una api fluida que facilitan la escritura y ejecución de peticiones HTTP.\r\n\r\n## Construcción de URLs  \r\nDe entrada, podría parecerte sencillo crear URLs por tu cuenta, pero cuando menos te das cuenta resulta que olvidaste poner un '/' y todo el código está mal. Con Flurl te puedes olvidar de esos problemas:\r\n\r\nEl método `AppendPathSegment` ayuda a añadir un segmento de URL a otra, al ser una api fluida, podemos *encadenar* varias llamadas a `AppendPathSegment`:\r\n\r\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span> <span class="kt">var</span> <span class="n">myCoolUrl2</span> <span class="p">=</span> <span class="err">\</span><span class="s">&quot;http://localhost/\&quot;\r\n    .AppendPathSegment(\&quot;sales\&quot;)\r\n    .AppendPathSegment(\&quot;Q1\&quot;)\r\n    .AppendPathSegment(\&quot;max\&quot;);\r\nConsole.WriteLine(myCoolUrl2);\r\n</span></code></pre></figure>  \r\n\r\nAl final, `myCoolUrl2` es:\r\n\r\n<pre>\r\nhttp://localhost/sales/Q1/max\r\n</pre> \r\n\r\nEl método devuelve un objeto del tipo `Url`, sobre el que podemos trabajar y que es directamente transformable en una cadena de texto.\r\n\r\nSi lo que necesitamos es añadir muchos segmentos a una URL, tal vez sea más conveniente hacerlo a través de un arreglo, tal vez sea mejor usar `AppendPathSegments`. Este método es similar al anterior, solo que opera con un mútliples segmentos de URL que son enviados en un arreglo marcado <a href=\"/params-c-sharp\">como params</a>:\r\n\r\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nvar</span> <span class="n">urlParts</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">string</span><span class="p">[]</span> <span class="p">{</span> <span class="err">\</span><span class="s">&quot;liga_mx\&quot;, \&quot;results\&quot;, \&quot;america\&quot; };\r\nvar builtUrl2 = new Url(\&quot;http://api.soccer-data.com\&quot;);\r\nbuiltUrl2.AppendPathSegments(urlParts);\r\nConsole.WriteLine(builtUrl2);\r\n</span></code></pre></figure>  \r\n\r\nAl final, `builtUrl2` es:\r\n\r\n<pre>\r\nhttp://api.soccer-data.com/liga_mx/results/america\r\n</pre> \r\n\r\n### Query string\r\nFlurl también tiene la capacidad de añadir parámetros a la *query string* de una URL usando el método `SetQueryParams`, para lo cual se crea un objeto anónimo:\r\n\r\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nvar</span> <span class="n">endDate</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Today</span><span class="p">;</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nvar</span> <span class="n">startDate</span> <span class="p">=</span> <span class="n">endDate</span><span class="p">.</span><span class="n">AddDays</span><span class="p">(-</span><span class="m">30</span><span class="p">);</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nbuiltUrl</span><span class="p">.</span><span class="n">SetQueryParams</span><span class="p">(</span><span class="k">new</span> <span class="p">{</span> <span class="n">endDate</span><span class="p">,</span> <span class="n">startDate</span><span class="p">,</span> <span class="n">c</span> <span class="p">=</span> <span class="err">\</span><span class="s">&quot;concacaf champions league\&quot; });\r\nConsole.WriteLine(builtUrl);\r\n</span></code></pre></figure>\r\n\r\nAl final, `builtUrl` es:\r\n\r\n<pre>\r\nhttp://api.soccer-data.com/liga_mx/results/america?endDate=04%2F25%2F2016%2000%3A00%3A00&startDate=03%2F26%2F2016%2000%3A00%3A00&c=concacaf%20champions%20league\r\n</pre> \r\n\r\nComo puedes darte cuenta, los nombres de las propiedades en el objeto anónimo `new { endDate, startDate, c = competition }` fueron respetadas y los parámetros fueron codificados como URL para ser enviados en una petición HTTP.\r\n\r\nTambién podemos quitar parámetros de la *query string* con `RemoveQueryParams`:\r\n\r\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nbuiltUrl</span><span class="p">.</span><span class="n">RemoveQueryParams</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;c\&quot;, \&quot;startDate\&quot;);\r\nConsole.WriteLine(builtUrl);\r\n</span></code></pre></figure>\r\n\r\nAl final, `builtUrl` es:\r\n\r\n<pre>\r\nhttp://api.soccer-data.com/liga_mx/results/america?endDate=04%2F25%2F2016%2000%3A00%3A00\r\n</pre> \r\n\r\n## Creación de un cliente HTTP\r\nA partir de tener una URL construida con los métodos anteriores, podemos comenzar a configurar nuestro cliente HTTP:\r\n\r\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nvar</span> <span class="n">client</span> <span class="p">=</span> <span class="n">myCoolUrl1</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span>    <span class="p">.</span><span class="n">WithBasicAuth</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;antonio\&quot;, \&quot;secretPass\&quot;)\r\n    .WithHeader(\&quot;User-Agent\&quot;, \&quot;Flurl-Sample\&quot;);\r\n</span></code></pre></figure>\r\n\r\nAhora, cada vez que hagamos una petición con un cliente creado por esta URL, contendrá el encabezado siguiente:\r\n\r\n<pre>\r\nAuthorization: Basic YW50b25pbzpzZWNyZXRQYXNz  \r\nUser-Agent: Flurl-Sample\r\n</pre> \r\n\r\nTambién tenemos más opciones, como la de asignar varios encabezados a la vez:\r\n\r\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nvar</span> <span class="n">client2</span> <span class="p">=</span> <span class="n">builtUrl</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span>    <span class="p">.</span><span class="n">WithOAuthBearerToken</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;t0k3n\&quot;)\r\n    .WithHeader(\&quot;Accept-Language\&quot;, \&quot;it\&quot;)\r\n    .WithHeader(\&quot;User-Agent\&quot;, \&quot;Flurl-Sample\&quot;)\r\n    .WithHeaders(new\r\n    {\r\n        CustomHeader = \&quot;Another value\&quot;,\r\n        Accept = \&quot;text/json\&quot;\r\n    });\r\n</span></code></pre></figure>\r\n\r\nCuyo resultado es:\r\n\r\n<pre>\r\nAuthorization: Bearer t0k3n  \r\nAccept-Language: it  \r\nUser-Agent: Flurl-Sample  \r\nCustomHeader: Another value  \r\nAccept: text/json  \r\n</pre> \r\n\r\n## Ejecución de peticiones\r\nYa sea con un cliente HTTP o con una Url podemos comenzar a realizar peticiones asíncronas. Para este ejemplo, usaré la <a href=\"http://pokeapi.co/\" target=\"_blank\">Pokéapi</a>:\r\n\r\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nvar</span> <span class="n">pokemonId</span> <span class="p">=</span> <span class="m">25</span><span class="p">;</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nvar</span> <span class="n">url1</span> <span class="p">=</span> <span class="err">\</span><span class="s">&quot;http://pokeapi.co/api/v2/\&quot;\r\n    .AppendPathSegment(\&quot;pokemon\&quot;)\r\n    .AppendPathSegment(pokemonId.ToString());\r\n\r\nConsole.WriteLine(\&quot;Consultando \&quot; + url1); // Consultando http://pokeapi.co/api/v2/pokemon/25\r\n</span></code></pre></figure>\r\n\r\nA partir de aquí podemos obtener un objeto dinámico con `GetJsonAsync`:\r\n\r\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">ndynamic</span> <span class="n">pkmn1</span> <span class="p">=</span> <span class="k">await</span> <span class="n">url1</span><span class="p">.</span><span class="n">GetJsonAsync</span><span class="p">();</span> <span class="c1">// pkmn1 \r\nConsole.WriteLine(pkmn1.name + \&quot; \&quot; + \&quot;\\nH:\&quot; + pkmn1.height + \&quot;\\nW:\&quot; + pkmn1.weight + \&quot;\\n\&quot;);\r\n</span></code></pre></figure>\r\n\r\n<pre>\r\npikachu\r\nH:4\r\nW:60\r\n</pre>\r\n\r\nO crear una clase que contenga las propiedades del objeto que vamos a recibir para que el resultado que tenemos sea fuertemente tipado, usando `GetJsonAync<T>` :\r\n\r\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nvar</span> <span class="n">pokemon</span> <span class="p">=</span> <span class="k">await</span> <span class="n">url2</span><span class="p">.</span><span class="n">GetJsonAsync</span><span class="p">&lt;</span><span class="n">Pokemon</span><span class="p">&gt;();</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">pokemon</span><span class="p">.</span><span class="n">Name</span> <span class="p">+</span> <span class="err">\</span><span class="s">&quot;\\nH:\&quot; + pokemon.Height + \&quot;\\nW:\&quot; + pokemon.Weight + \&quot;\\n\&quot;);\r\n</span></code></pre></figure>\r\n\r\n<pre>\r\ncharmander\r\nH:6\r\nW:85\r\n</pre>\r\n\r\nFlurl también permite hacer peticiones POST mediante `PostJsonAsync` o `PostUrlEncodedAsync`, además de integrar el manejo de errores mediante la `FlurlHttpException` que contiene la información necesaria acerca del error sucedido, por ejemplo, mira el manejo de esta excepción\r\n\r\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">ncatch</span> <span class="p">(</span><span class="n">FlurlHttpException</span> <span class="n">ex</span><span class="p">)</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span>    <span class="k">if</span> <span class="p">(</span><span class="n">ex</span><span class="p">.</span><span class="n">Call</span><span class="p">.</span><span class="n">Response</span> <span class="p">!=</span> <span class="k">null</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span>        <span class="p">&amp;&amp;</span> <span class="n">ex</span><span class="p">.</span><span class="n">Call</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="n">StatusCode</span> <span class="p">==</span> <span class="n">HttpStatusCode</span><span class="p">.</span><span class="n">NotFound</span><span class="p">)</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span>    <span class="p">{</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span>        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;No existe un pokemon llamado \&quot; + pokemonName);\r\n    }\r\n}\r\n</span></code></pre></figure>\r\n\r\n\r\nNo olvides que puedes consultar todo el código de este ejemplo en <a href=\"https://github.com/ThatCSharpGuy/Flurl-Sample\" target=\"_blank\">https://github.com/ThatCSharpGuy/Flurl-Sample</a>.\r\n\r\n\r\n## Conclusión\r\nAl principio pareciera que la construcción de URLs, configuración de clientes y ejecución de peticiones HTTP es tan sencillo que tu mismo puedes gestionarlo todo, pero depende del tamaño de lo que quieres lograr. Si tu interés es delegar esta tarea a librerías de terceros, Flurl es una gran opción y es que además de lo poco que traté de mostrar en este post, aún hay más, entre ellas la facilidad que nos brinda a la hora de hacer *testing*.\r\n \r\n# Instalación  \r\nPara instalarlo no hay mejor manera que el gestor de paquetes de NuGet, instala solo Flurl si quieres solo los beneficios de la construcción de URLs o Flurl.Http si quieres el paquete completo:\r\n\r\n<figure class="console"><pre><code>\r\nPM> Install-Package Flurl\r\n</code></pre></figure>\r\n\r\n<figure class="console"><pre><code>\r\nPM> Install-Package Flurl.Http\r\n</code></pre></figure>\r\n\r\nO échale un ojo al <a href=\"https://github.com/tmenier/Flurl\" target=\"_blank\" rel=\"nofollow\">proyecto en GitHub</a> y contribuir a su desarrollo de alguna manera."'   
}