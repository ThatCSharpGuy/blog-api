{	
	"id" : "/post/reflexion-c-sharp-es/",
	"tv" : false,
	"date": "2016-10-10 14:00:01 -0500",
	"title" : "Reflexión en C#",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//aprende-c-sharp/reflexion.jpg",
	"tags" : ["AprendeCSharp"],
	"content": "<p>La reflexión en C# es solo otra de las caracterísitcas que el lenguaje nos entrega para desarrollar con él. No es una característica tan conocida por todos los desarrolladores y me atrevería a decir que de los que lo conocen, no todas la usan y es que no es necesaria usarla en todos los programas.</p>\n\n<p>La reflexión nos permite acceder a la información de un tipo en tiempo de ejecución. Cuando estamos escribiendo el código, somos nosotros quienes tenemos una idea general del sistema: sabemos los tipos de dato de las variables, los métodos que contienen las clases, los atributos de los miembros de estas y un sin fin de cosas más. Otro elemento que conoce <em>todo</em> de nuestro programa es el compilador, ya que sabe si estamos usando los tipos correctos para llamar a los métodos o tenemos permiso para acceder a determinado miembro de una clase.</p>\n\n<p>Sin embargo, una vez que se compila, el programa no tiene idea de los tipos de dato, métodos y demás complejidades del programa, por ejemplo, el siguiente programa no sabe que <code>zero</code> es del tipo <code>string</code>:</p>\n\n<pre class=\"csharp\">\nvar zero = \"0\";\n</pre>\n\n<p>No es sino hasta que empleamos la reflexión que el programa tiene acceso a esta información a través de un tipo <code>Type</code>:</p>\n\n<pre class=\"csharp\">\nType type = zero.GetType();\nConsole.WriteLine(type); // System.String\n</pre>\n\n<p>También se puede acceder al ensamblado al que pertenece el tipo <code>String</code>:</p>\n\n<pre class=\"csharp\">\nAssembly assembly = type.Assembly;\nConsole.WriteLine(type.Assembly); // mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n</pre>\n\n<p>Y a partir de un ensamblado podemos obtener todos sus tipos con el método <code>GetTypes</code>, en este caso, además de obteneros, también los estamos filtrando, seleccionando solo aquellos cuyo nombre comience con “Int32”:</p>\n\n<pre class=\"csharp\">\nforeach (var ty in assembly.GetTypes()\n    .Where(ty.Name.StartsWith(\"Int32\")))\n\n    Console.WriteLine(ty);\n\n</pre>\n\n<p>Otro de las cosas que podemos hacer empleando la reflexión, es instanciar tipos de dato a partir de una instancia de <code>Type</code> y la clase <code>Activator</code>:</p>\n\n<pre class=\"csharp\">\nvar int32Type = assembly.GetType(\"System.Int32\");\n\nvar createdInt  = Activator.CreateInstance(int32Type);\nConsole.WriteLine(createdInt); // 0\n</pre>\n\n<p>Como ya habíamos visto antes, mediante los <a href=\"../atributos-c-sharp\" target=\"_blank\">atributos en C#</a> podemos proveer a los programas de metadatos, como es la clase <code>Smartphone</code> (cuya implementación puedes <a href=\"https://github.com/ThatCSharpGuy/aprende-c-sharp/blob/master/Reflexion/Smartphone.cs#L10\" target=\"_blank\">encontrar aquí</a>).</p>\n\n<p>El siguiente ejemplo de código obtiene todos los atributos de la propiedad <code>Carrier</code>:</p>\n\n<pre class=\"csharp\">\nvar phone = new Smartphone();\nphone.IsLocked = true;\nphone.Carrier = \"Entel\";\n\nvar t = phone.GetType();\n\nvar carrierProperty = t.GetProperty(\"Carrier\");\n\nforeach (var att in carrierProperty.GetCustomAttributes())\n\n    Console.WriteLine(att);\n\n</pre>\n\n<p>El resultado de ejecutar el código anterior es:</p>\n\n<pre>\nRequiredAttribute\nValidCarrierAttribute\nDisplayAttribute\n</pre>\n\n<p>Que son los atributos que tiene la propiedad <code>Carrier</code>.</p>\n\n<p>Y si queremos, podemos hacer cosas un poco más complejas. Por ejemplo, si deseamos encontrar todas las propiedades que tengan <code>DisplayAttribute</code> podemos buscarlas con <a href=\"../linq-en-c-sharp\">Linq</a>:</p>\n\n<pre class=\"csharp\">\nvar propertiesWithDisplayName = from prop in t.GetProperties()\n                                where prop.GetCustomAttributes<displayattribute>().Any()\n                                select prop;\n \n\nPara luego mostrar los valores de una manera \"amigable\":\n\n<pre class=\"csharp\">\nforeach (var property in propertiesWithDisplayName)\n\n    var attr = property.GetCustomAttribute<displayattribute>();\n    Console.WriteLine(attr.Name + \": \" + property.GetValue(phone));\n\n  \n\nEjecutar el código anterior dará como resultado:\n\n<pre>\nCompañía: Entel\nBloqueado: true\n</pre>  \n\nYa para terminar, otra de las posiblidades que nos da la reflexión en C# es la de modificar los valores de una variable o propiedad en tiempo de ejecución con solo tener su nombre. Toma en cuenta el código siguiente, en donde se solicita al usuario ingresar el nombre de una propiedad y se busca dicha propiedad en el tipo `Smartphone`:\n\n<pre class=\"csharp\">\nConsole.WriteLine(\"Escribe el nombre de la propiedad a modificar:\");\nvar propertyName = Console.ReadLine();\nvar propertyToModify = phoneType.GetProperty(propertyName);\n</pre>  \n\nDespués se verifica que la propiedad exista (el método `GetProperty` regresa `null` si no encuentra una propiedad con el nombre indicado) y si existe, solicitamos el nuevo valor para la propiedad:\n\n<pre class=\"csharp\">\nif (propertyToModify != null)\n\n    Console.WriteLine(\"Escribe el valor:\");\n    var value = Console.ReadLine();\n    // Efectuar conversión ... \n\nelse\n\n    Console.WriteLine(\"La propiedad \" + propertyName + \" no existe\");\n\n</pre>  \n\nPara efectuar la conversión debemso recurrir, nuevamente, a la reflexión. A través del método `SetValue` y la clase `Convert`: \n\n<pre class=\"csharp\">\npropertyToModify.SetValue(phone, Convert.ChangeType(value, propertyToModify.PropertyType));\n</pre>  \n\n## Usos de la reflexión\nSi tu trabajo es el de ser un desarrollador de aplicaciones para usuario final, tal vez no le veas mucho uso a esta poderosa característica, sin embargo, usándola se puede\n\n - Acceder a los metadatos y conocer los atributos de cada uno de los componentes de un programa  \n - Instanciar clases en tiempo de ejecución  \n - Tener acceso a métodos, propiedades y cualquier otro miembro privado de los tipos de dato  \n\n## Para finalizar  \nEs importante señalar que en este post doy apenas una mínima introducción a lo que se puede hacer, esperando despertar tu interés. También debes saber que hacer uso de la reflexión hará que un programa se ejecute un poco más lento que si no se usara, ya que se realizan operaciones un poco más complejas.  \n</displayattribute></pre></displayattribute></pre>\n"
}