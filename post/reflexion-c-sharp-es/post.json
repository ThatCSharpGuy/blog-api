{	
	"id" : "/post/reflexion-c-sharp-es/",
	"tv" : false,
	"date": "2016-10-10 14:00:01 -0500",
	"title" : "Reflexión en C#",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//aprende-c-sharp/reflexion.jpg",
	"tags" : ["AprendeCSharp"],
	  
	"content": '"La reflexión en C# es solo otra de las caracterísitcas que el lenguaje nos entrega para desarrollar con él. No es una característica tan conocida por todos los desarrolladores y me atrevería a decir que de los que lo conocen, no todas la usan y es que no es necesaria usarla en todos los programas.\n\nLa reflexión nos permite acceder a la información de un tipo en tiempo de ejecución. Cuando estamos escribiendo el código, somos nosotros quienes tenemos una idea general del sistema: sabemos los tipos de dato de las variables, los métodos que contienen las clases, los atributos de los miembros de estas y un sin fin de cosas más. Otro elemento que conoce *todo* de nuestro programa es el compilador, ya que sabe si estamos usando los tipos correctos para llamar a los métodos o tenemos permiso para acceder a determinado miembro de una clase.\n\nSin embargo, una vez que se compila, el programa no tiene idea de los tipos de dato, métodos y demás complejidades del programa, por ejemplo, el siguiente programa no sabe que `zero` es del tipo `string`:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">zero</span> <span class="p">=</span> <span class="err">\</span><span class="s">&quot;0\&quot;;\n</span></code></pre></figure>  \n\nNo es sino hasta que empleamos la reflexión que el programa tiene acceso a esta información a través de un tipo `Type`:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nType</span> <span class="n">type</span> <span class="p">=</span> <span class="n">zero</span><span class="p">.</span><span class="n">GetType</span><span class="p">();</span><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">type</span><span class="p">);</span> <span class="c1">// System.String\n</span></code></pre></figure>    \n\nTambién se puede acceder al ensamblado al que pertenece el tipo `String`:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nAssembly</span> <span class="n">assembly</span> <span class="p">=</span> <span class="n">type</span><span class="p">.</span><span class="n">Assembly</span><span class="p">;</span><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">type</span><span class="p">.</span><span class="n">Assembly</span><span class="p">);</span> <span class="c1">// mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n</span></code></pre></figure>  \n\nY a partir de un ensamblado podemos obtener todos sus tipos con el método `GetTypes`, en este caso, además de obteneros, también los estamos filtrando, seleccionando solo aquellos cuyo nombre comience con \"Int32\":\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nforeach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">ty</span> <span class="k">in</span> <span class="n">assembly</span><span class="p">.</span><span class="n">GetTypes</span><span class="p">()</span><span class="err">\</span><span class="n">n</span>    <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">ty</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">StartsWith</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;Int32\&quot;)))\n{\n    Console.WriteLine(ty);\n}\n</span></code></pre></figure>  \n\nOtro de las cosas que podemos hacer empleando la reflexión, es instanciar tipos de dato a partir de una instancia de `Type` y la clase `Activator`:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">int32Type</span> <span class="p">=</span> <span class="n">assembly</span><span class="p">.</span><span class="n">GetType</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;System.Int32\&quot;);\n\nvar createdInt  = Activator.CreateInstance(int32Type);\nConsole.WriteLine(createdInt); // 0\n</span></code></pre></figure>  \n\nComo ya habíamos visto antes, mediante los <a href=\"../atributos-c-sharp\" target=\"_blank\">atributos en C#</a> podemos proveer a los programas de metadatos, como es la clase `Smartphone` (cuya implementación puedes <a href=\"https://github.com/ThatCSharpGuy/aprende-c-sharp/blob/master/Reflexion/Smartphone.cs#L10\" target=\"_blank\">encontrar aquí</a>). \n\nEl siguiente ejemplo de código obtiene todos los atributos de la propiedad `Carrier`:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">phone</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Smartphone</span><span class="p">();</span><span class="err">\</span><span class="n">nphone</span><span class="p">.</span><span class="n">IsLocked</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span><span class="err">\</span><span class="n">nphone</span><span class="p">.</span><span class="n">Carrier</span> <span class="p">=</span> <span class="err">\</span><span class="s">&quot;Entel\&quot;;\n\nvar t = phone.GetType();\n\nvar carrierProperty = t.GetProperty(\&quot;Carrier\&quot;);\n\nforeach (var att in carrierProperty.GetCustomAttributes())\n{\n    Console.WriteLine(att);\n}\n</span></code></pre></figure>  \n\nEl resultado de ejecutar el código anterior es:  \n\n<pre>\nRequiredAttribute\nValidCarrierAttribute\nDisplayAttribute\n</pre>\n\nQue son los atributos que tiene la propiedad `Carrier`.\n\nY si queremos, podemos hacer cosas un poco más complejas. Por ejemplo, si deseamos encontrar todas las propiedades que tengan `DisplayAttribute` podemos buscarlas con <a href=\"../linq-en-c-sharp\">Linq</a>:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">propertiesWithDisplayName</span> <span class="p">=</span> <span class="k">from</span> <span class="n">prop</span> <span class="k">in</span> <span class="n">t</span><span class="p">.</span><span class="n">GetProperties</span><span class="p">()</span><span class="err">\</span><span class="n">n</span>                                <span class="k">where</span> <span class="n">prop</span><span class="p">.</span><span class="n">GetCustomAttributes</span><span class="p">&lt;</span><span class="n">DisplayAttribute</span><span class="p">&gt;().</span><span class="n">Any</span><span class="p">()</span><span class="err">\</span><span class="n">n</span>                                <span class="k">select</span> <span class="n">prop</span><span class="p">;</span><span class="err">\</span><span class="n">n</span></code></pre></figure> \n\nPara luego mostrar los valores de una manera \"amigable\":\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nforeach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">property</span> <span class="k">in</span> <span class="n">propertiesWithDisplayName</span><span class="p">)</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="kt">var</span> <span class="n">attr</span> <span class="p">=</span> <span class="n">property</span><span class="p">.</span><span class="n">GetCustomAttribute</span><span class="p">&lt;</span><span class="n">DisplayAttribute</span><span class="p">&gt;();</span><span class="err">\</span><span class="n">n</span>    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">attr</span><span class="p">.</span><span class="n">Name</span> <span class="p">+</span> <span class="err">\</span><span class="s">&quot;: \&quot; + property.GetValue(phone));\n}\n</span></code></pre></figure>  \n\nEjecutar el código anterior dará como resultado:\n\n<pre>\nCompañía: Entel\nBloqueado: true\n</pre>  \n\nYa para terminar, otra de las posiblidades que nos da la reflexión en C# es la de modificar los valores de una variable o propiedad en tiempo de ejecución con solo tener su nombre. Toma en cuenta el código siguiente, en donde se solicita al usuario ingresar el nombre de una propiedad y se busca dicha propiedad en el tipo `Smartphone`:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;Escribe el nombre de la propiedad a modificar:\&quot;);\nvar propertyName = Console.ReadLine();\nvar propertyToModify = phoneType.GetProperty(propertyName);\n</span></code></pre></figure>  \n\nDespués se verifica que la propiedad exista (el método `GetProperty` regresa `null` si no encuentra una propiedad con el nombre indicado) y si existe, solicitamos el nuevo valor para la propiedad:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nif</span> <span class="p">(</span><span class="n">propertyToModify</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;Escribe el valor:\&quot;);\n    var value = Console.ReadLine();\n    // Efectuar conversión ... \n}\nelse\n{\n    Console.WriteLine(\&quot;La propiedad \&quot; + propertyName + \&quot; no existe\&quot;);\n}\n</span></code></pre></figure>  \n\nPara efectuar la conversión debemso recurrir, nuevamente, a la reflexión. A través del método `SetValue` y la clase `Convert`: \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npropertyToModify</span><span class="p">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">phone</span><span class="p">,</span> <span class="n">Convert</span><span class="p">.</span><span class="n">ChangeType</span><span class="p">(</span><span class="k">value</span><span class="p">,</span> <span class="n">propertyToModify</span><span class="p">.</span><span class="n">PropertyType</span><span class="p">));</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\n## Usos de la reflexión\nSi tu trabajo es el de ser un desarrollador de aplicaciones para usuario final, tal vez no le veas mucho uso a esta poderosa característica, sin embargo, usándola se puede\n\n - Acceder a los metadatos y conocer los atributos de cada uno de los componentes de un programa  \n - Instanciar clases en tiempo de ejecución  \n - Tener acceso a métodos, propiedades y cualquier otro miembro privado de los tipos de dato  \n\n## Para finalizar  \nEs importante señalar que en este post doy apenas una mínima introducción a lo que se puede hacer, esperando despertar tu interés. También debes saber que hacer uso de la reflexión hará que un programa se ejecute un poco más lento que si no se usara, ya que se realizan operaciones un poco más complejas.  \n"'   
}