{	
	"id" : "/post/mvvm-xamarin-forms/",
	"tv" : false,
	"date": "2016-06-26 16:00:00 -0500",
	"title" : "MVVM en Xamarin.Forms, caso práctico",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//mvvm/mvvm-featured.png",
	"tags" :
	[ 
		"Xamarin",
		"XamarinForms",
		"Mvvm"
	],
	"content" : "<h1 id=\"mvvmdex\">Mvvmdex</h1>
<p>Soy un gran fanático de Pokémon y es por eso que para este post haremos una aplicación que se encargará de buscar pokémons en la PokéAPI usando la <a href=\"#\">Jirapi</a> y mostrar los datos encontrados en la pantalla. En esta aplicación se implementa el patrón MVVM para la separación de responsabilidades.</p>

<p><img src=\"http://i.giphy.com/Mo4P4sEJNUKeQ.gif\" /></p>

<h2 id=\"introduccin\">Introducción</h2>
<p>Dentro de este post voy a asumir que ya tienes un entendimiento básico de cómo es que funciona Xamarin, Xamarin.Forms y la teoría de MVVM, si no, te invito a que consultes mi post sobre <a href=\"../../tv/xamarin/\">qué es Xamarin</a>, el <a href=\"../../tv/xamarin-forms/\">video sobre Xamarin.Forms</a>, y el <a href=\"../../tv/mvvm\">video sobre MVVM</a>.</p>

<h2 id=\"estructura\">Estructura</h2>

<p>Como ya sabrás, el <a href=\"organizacion-codigo-visual-studio\">código en Visual Studio</a> se organiza en proyectos, y esta es la organización de los proyectos para esta pequeña app:</p>

<p><figure><img src='/postimages/post/mvvm-xamarin-forms/post.jsoncodeorg.png' alt='“Code organization” images_set' /></figure></p>

<p>La separación de MVVM se puede observar en que el proyecto <code>Mvvmdex.Views</code> se relaciona con <code>Mvvmdex.ViewModels</code> y a su vez este último se relaciona con <code>Mvvmdex.Models</code>, <strong>nunca hay relacion directa entre las vistas y los modelos</strong>.</p>

<h2 id=\"modelo\">Modelo</h2>

<p>Para este proyecto, el modelo está contenido dentro de <code>Mvvmdex.Models</code>. Como sabe, en el modelo es donde se realiza el acceso a datos y la lógica de la aplicación. En esta aplicación, el <em>Mvvmdex</em>, únicamente se consulta a la PokéAPI dentro de la clase <code>MvvmdexClient</code>. Como puedes ver, no tiene ninguna relación con la vista:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">pokemon</span><span class="p">&gt;</span> <span class="n">SearchForPokemon</span><span class="p">(</span><span class="kt">string</span> <span class="n">pokemonName</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">try</span>
	<span class="p">{</span>
		<span class="kt">var</span> <span class="n">pkmn</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_client</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">jirapi</span><span class="p">.</span><span class="n">resources</span><span class="p">.</span><span class="n">pokemon</span><span class="p">&gt;(</span><span class="n">pokemonName</span><span class="p">);</span>
		<span class="kt">var</span> <span class="n">species</span> <span class="p">=</span> <span class="k">await</span> <span class="n">pkmn</span><span class="p">.</span><span class="n">Species</span><span class="p">.</span><span class="n">GetResource</span><span class="p">(</span><span class="n">_client</span><span class="p">);</span>
		<span class="k">return</span> <span class="k">new</span> <span class="n">Pokemon</span>
		<span class="p">{</span>
			<span class="n">Id</span> <span class="p">=</span> <span class="n">pkmn</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span>
			<span class="n">Name</span> <span class="p">=</span> <span class="n">pkmn</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span>
			<span class="n">Description</span> <span class="p">=</span> <span class="n">species</span><span class="p">.</span><span class="n">FlavorTextEntries</span>
				<span class="p">.</span><span class="n">FirstOrDefault</span><span class="p">(</span><span class="n">te</span> <span class="p">=&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">te</span><span class="p">.</span><span class="n">Language</span><span class="p">.</span><span class="n">Name</span> <span class="p">==</span> <span class="err">\</span><span class="s">&quot;en\&quot;)?</span>
				<span class="p">.</span><span class="n">FlavorText</span><span class="p">.</span><span class="n">Replace</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;\n\&quot;,\&quot;\&quot;),</span>
			<span class="n">Shape</span> <span class="p">=</span> <span class="n">species</span><span class="p">.</span><span class="n">Shape</span><span class="p">.</span><span class="n">Name</span>
		<span class="p">};</span>
	<span class="p">}</span>
	<span class="k">catch</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="k">null</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure></jirapi.resources.pokemon></pokemon></p>

<h2 id=\"viewmodels\">ViewModels</h2>

<p>Para este proyecto, el modelo está contenido dentro de <code>Mvvmdex.ViewModels</code>. Esta es la parte más complicada, hay que recordar que este es el intermediario entre la vista y el modelo. Para esta app únicamente existe un solo ViewModel, <code>PokemonSearchViewModel</code>, pero es muy común que tu tengas varios dependiendo del tamaño y complejidad de tu aplicación.</p>

<p>Esta sección tiene relación directa con el Modelo, en el <em>Mvvmdex</em> se hace referencia en el cliente <code>MvvmdexClient</code>:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">private</span> <span class="n">MvvmdexClient</span> <span class="n">_client</span><span class="p">;&lt;/</span><span class="n">p</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="n">p</span><span class="p">&gt;</span><span class="k">public</span> <span class="n">PokemonSearchViewModel</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">_client</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MvvmdexClient</span><span class="p">();</span> <span class="c1">// &amp;lt;- Model</span>
<span class="p">}</span></code></pre></figure></p>

<p>El modelo puede enviar y recibir mensajes del <em>viewmodel</em> a través de métodos.</p>

<h3 id=\"inotifypropertychanged\">INotifyPropertyChanged</h3>

<p>La interfaz <code>INotifyPropertyChanged</code> permitirá a la vista ser notificada cada vez que suceda algún cambio en el <em>viewmodel</em>. La interfaz únicamente expone el evento <code>PropertyChanged</code> que debemos invocar cada vez que queremos notificar a la vista algún cambio. Para hacer la tarea más sencilla, se crea un método auxiliar:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">void</span> <span class="nf">RaiseOnPropertyChange</span><span class="p">([</span><span class="n">CallerMemberName</span><span class="p">]</span> <span class="kt">string</span> <span class="n">propertyName</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PropertyChanged</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">PropertyChanged</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">new</span> <span class="n">PropertyChangedEventArgs</span><span class="p">(</span><span class="n">propertyName</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure></p>

<p>El atributo <code>CallerMemberName</code> nos facilitará la tarea, ya que con él aseguramos que el nombre de la propiedad desde la que lo llamemos será colocada ahí para notificar a la vista sobre la propiedad correcta.</p>

<p>Es importante decir que existen muchos frameworks de <em>mvvm</em> que ya contienen una implementación de esta interfaz y para nosotros bastaría con derivar nuestros objetos de dicha implementación para no tener que hacerla nosotros mismos.</p>

<h3 id=\"propiedades\">Propiedades</h3>

<p>Con las propiedades hay una pequeña limitante: no pueden ser propiedades auto-implementadas, ya que es necesario llamar a nuestro método auxiliar creado más arriba. Mira la propiedad <code>PokemonName</code>:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">private</span> <span class="kt">string</span> <span class="n">_pokemonName</span><span class="p">;&lt;/</span><span class="n">p</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="n">p</span><span class="p">&gt;</span><span class="k">public</span> <span class="kt">string</span> <span class="n">PokemonName</span>
<span class="p">{</span>
	<span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_pokemonName</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">set</span> <span class="p">{</span> <span class="n">_pokemonName</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span> <span class="n">RaiseOnPropertyChange</span><span class="p">();</span> <span class="cm">/* RaiseOnPropertyChange(“PokemonName”) */</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure></p>

<p>Como puedes ver, cada vez que ocurre un cambio en la propiedad, se está notificando a quién desee sobre el cambio, en nuestro caso, la vista es quien desea ser notificada. Más adelante, con los <em>data bindings</em>, enlazaremos las propiedades en el <em>viewmodel</em> con elementos dentro de la vista.</p>

<h3 id=\"commands\">Commands</h3>

<p>Los <em>commands</em> es otro de los mecanismos que contempla <em>mvvm</em> para la comunicación entre los componentes, y es a través de ellos que se trasladan algunos de los eventos generados en la vista hacia el <em>viewmodel</em>. En Xamarin.Forms un comando no es más que una instancia de objeto que implementa la interfaz <code>ICommand</code>, en el caso de esta app, tenemos el comando <code>BuscaPokemonCommand</code> que lo único que hace es ejecutar una <code>Action</code> cuando se ejecuta.</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">BuscaPokemonCommand</span> <span class="p">:</span> <span class="n">ICommand</span>
<span class="p">{</span>
	<span class="k">private</span> <span class="k">readonly</span> <span class="n">Action</span> <span class="n">_search</span><span class="p">;</span>
	<span class="k">public</span> <span class="nf">BuscaPokemonCommand</span><span class="p">(</span><span class="n">Action</span> <span class="n">search</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">_search</span> <span class="p">=</span> <span class="n">search</span><span class="p">;</span>
	<span class="p">}&lt;/</span><span class="n">p</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="n">pre</span><span class="p">&gt;&lt;</span><span class="n">code</span><span class="p">&gt;</span><span class="k">public</span> <span class="kt">bool</span> <span class="n">CanExecute</span><span class="p">(</span><span class="kt">object</span> <span class="n">parameter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">Execute</span><span class="p">(</span><span class="kt">object</span> <span class="n">parameter</span><span class="p">)</span>
<span class="p">{</span>
		<span class="n">_search</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">event</span> <span class="n">EventHandler</span> <span class="n">CanExecuteChanged</span><span class="p">;</span> <span class="p">}</span> </code></pre></figure>  
</code></pre>

<p>La interfaz ICommand contiene tres miembros:</p>

<ul>
  <li><code>bool CanExecute(object parameter)</code> - con el cual podemos decidir si el comando se puede ejecutar</li>
  <li><code>void Execute(object parameter)</code> - en el cual debemos efectuar la ejecución</li>
  <li><code>event EventHandler CanExecuteChanged</code> - es un evento que debe invocarse cada vez que las condiciones bajo las que se puede invocar un comando han cambiado.</li>
</ul>

<p>Es importante mencionar que al igual que con la interfaz <code>INotifyPropertyChanged</code>, ya existen varios frameworks que proveen implementaciones genéricas de <code>ICommand</code> para evitarnos el tedio de escribirlos nosotros mismos.</p>

<h4 id=\"en-el-viewmodel\">En el ViewModel</h4>

<p>Ahora, la forma en la que se usa este comando es a través de una propiedad ya que más adelante será enlazada con un control dentro de la vista:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">private</span> <span class="n">ICommand</span> <span class="n">_buscaPokemonCommand</span><span class="p">;</span>
<span class="k">public</span> <span class="n">ICommand</span> <span class="n">BuscaPokemonCommand</span>
<span class="p">{</span>
	<span class="k">get</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">_buscaPokemonCommand</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">Action</span> <span class="n">buscaPokemonAction</span> <span class="p">=</span> <span class="k">async</span> <span class="p">()</span> <span class="p">=&amp;</span><span class="n">gt</span><span class="p">;</span>
			<span class="p">{</span>
			<span class="kt">var</span> <span class="n">pokemon</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_client</span><span class="p">.</span><span class="n">SearchForPokemon</span><span class="p">(</span><span class="n">SearchTerms</span><span class="p">.</span><span class="n">ToLower</span><span class="p">());&lt;/</span><span class="n">p</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="n">pre</span><span class="p">&gt;&lt;</span><span class="n">code</span><span class="p">&gt;</span>			<span class="n">HasCoincidence</span> <span class="p">=</span> <span class="n">pokemon</span> <span class="p">!=</span> <span class="k">null</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">HasCoincidence</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">Description</span> <span class="p">=</span> <span class="n">pokemon</span><span class="p">.</span><span class="n">Description</span><span class="p">;</span>
				<span class="n">PokemonName</span> <span class="p">=</span> <span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;{0:D3} {1}\&quot;, pokemon.Id, pokemon.Name);</span>
				<span class="n">Shape</span> <span class="p">=</span> <span class="n">pokemon</span><span class="p">.</span><span class="n">Shape</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">};</span>
		<span class="n">_buscaPokemonCommand</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BuscaPokemonCommand</span><span class="p">(</span><span class="n">buscaPokemonAction</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">_buscaPokemonCommand</span><span class="p">;</span>
<span class="p">}</span> <span class="p">}</span> </code></pre></figure>  
</code></pre>

<h2 id=\"vista\">Vista</h2>

<p>Hay que recordar que en Forms podemos crear nuestras interfaces a través de código C# o XAML, para esta ocasión usaré XAML para crear la pantalla.</p>

<p>La vista de la aplicación es bastante simple, únicamente consta de un cuadro de búsqueda (<code>SearchBar</code>), un contenedor (<code>StackLayout</code>) que contiene varias etiquetas (<code>Label</code>) para mostrar los datos de Pokémon en cuestión y por último una etiqueta para mostrar en caso de que no encontremos un pokémon que coincida con nuestra búsqueda:</p>

<p><figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;contentpage</span> <span class="na">xmlns=</span><span class="s">\&quot;http://xamarin.com/schemas/2014/forms\&quot;</span> <span class="na">xmlns:x=</span><span class="s">\&quot;http://schemas.microsoft.com/winfx/2009/xaml\&quot;</span> <span class="na">xmlns:converters=</span><span class="s">\&quot;clr-namespace:Mvvmdex.Views.Converters\&quot;</span> <span class="na">x:class=</span><span class="s">\&quot;Mvvmdex.Views.MvvmdexPage\&quot;</span> <span class="na">title=</span><span class="s">\&quot;Mvvmdex\&quot;</span><span class="nt">&gt;</span>
	<span class="nt">&lt;contentpage.resources&gt;</span>
		<span class="nt">&lt;resourcedictionary&gt;</span>
			<span class="nt">&lt;converters:booleaninverterconverter</span> <span class="na">x:key=</span><span class="s">\&quot;BooleanInverter\&quot;</span> <span class="nt">/&gt;</span>
			<span class="nt">&lt;converters:shapetoemojiconverter</span> <span class="na">x:key=</span><span class="s">\&quot;ShapeToEmoji\&quot;</span> <span class="nt">/&gt;</span>
		<span class="nt">&lt;/resourcedictionary&gt;</span>
	<span class="nt">&lt;/contentpage.resources&gt;</span>
	<span class="nt">&lt;grid&gt;</span>
		<span class="nt">&lt;grid.rowdefinitions&gt;</span>
			<span class="nt">&lt;rowdefinition</span> <span class="na">height=</span><span class="s">\&quot;Auto\&quot;</span> <span class="nt">/&gt;</span>
			<span class="nt">&lt;rowdefinition</span> <span class="na">height=</span><span class="s">\&quot;*\&quot;</span> <span class="nt">/&gt;</span>
		<span class="nt">&lt;/grid.rowdefinitions&gt;</span>
		
		<span class="nt">&lt;searchbar</span> <span class="na">grid.row=</span><span class="s">\&quot;0\&quot;</span> <span class="na">searchcommand=</span><span class="s">\&quot;{Binding</span> <span class="err">BuscaPokemonCommand}\&quot;</span> <span class="na">text=</span><span class="s">\&quot;{Binding</span> <span class="err">SearchTerms}\&quot;</span> <span class="nt">/&gt;</span>
		
		<span class="nt">&lt;stacklayout</span> <span class="na">isvisible=</span><span class="s">\&quot;{Binding</span> <span class="err">HasCoincidence}\&quot;</span> <span class="na">grid.row=</span><span class="s">\&quot;1\&quot;</span> <span class="na">padding=</span><span class="s">\&quot;20\&quot;</span> <span class="na">spacing=</span><span class="s">\&quot;10\&quot;</span><span class="nt">&gt;</span>
			<span class="nt">&lt;label</span> <span class="na">text=</span><span class="s">\&quot;{Binding</span> <span class="err">PokemonName}\&quot;</span> <span class="na">fontsize=</span><span class="s">\&quot;Large\&quot;</span> <span class="nt">/&gt;</span>
			<span class="nt">&lt;label</span> <span class="na">text=</span><span class="s">\&quot;{Binding</span> <span class="err">Description}\&quot;</span> <span class="nt">/&gt;</span>
			<span class="nt">&lt;label</span> <span class="na">text=</span><span class="s">\&quot;{Binding</span> <span class="err">Shape,</span> <span class="na">Converter=</span><span class="s">{StaticResource</span> <span class="err">ShapeToEmoji}}\&quot;</span> <span class="nt">/&gt;</span>
		<span class="nt">&lt;/stacklayout&gt;</span>
		
		<span class="nt">&lt;label</span> <span class="na">isvisible=</span><span class="s">\&quot;{Binding</span> <span class="err">HasCoincidence,</span> <span class="na">Converter=</span><span class="s">{StaticResource</span> <span class="err">BooleanInverter}}\&quot;</span> <span class="na">text=</span><span class="s">\&quot;😕\&quot;</span> <span class="na">grid.row=</span><span class="s">\&quot;1\&quot;</span> <span class="na">horizontaltextalignment=</span><span class="s">\&quot;Center\&quot;</span> <span class="na">fontsize=</span><span class="s">\&quot;100\&quot;</span> <span class="nt">/&gt;</span>
	<span class="nt">&lt;/grid&gt;</span>
<span class="nt">&lt;/contentpage&gt;</span>
<span class="nt">&lt;p&gt;</span></code></pre></figure></p>

<h3 id=\"data-bindings\">Data bindings</h3>

<p>Si ves mucho <code>Binding</code> en el código no te preocupes, es algo muy común en <em>MVVM</em>, y es que es ahí donde ocurre el enlace de la vista al <em>viewmodel</em>, una de las partes centrales del patrón. Los <em>data bindings</em> se encargan de “estar al tanto” de los cambios que informa el <em>viewmodel</em> y reflejarlos en la pantalla cuando sucedan.</p>

<p>Por ejemplo, la etiqueta en la que se muestra el nombre y el número del Pokémon:</p>

<p><figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;label</span> <span class="na">text=</span><span class="s">\&quot;{Binding</span> <span class="err">PokemonName}\&quot;</span> <span class="na">fontsize=</span><span class="s">\&quot;Large\&quot;</span><span class="nt">&gt;&lt;/label&gt;</span></code></pre></figure></p>

<p>Mediante los <em>bindings</em> el texto del <code>Label</code> cambiará cada vez que la propiedad <code>PokemonName</code> lo haga.</p>

<p>Sin embargo, los bindings no son solo de una dirección (<em>viewmodel</em> → vista), sino que también pueden ser usados al revés. Tomemos, por ejemplo el control <code>SearchBar</code>:</p>

<p><figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;searchbar</span> <span class="na">grid.row=</span><span class="s">\&quot;0\&quot;</span> <span class="na">searchcommand=</span><span class="s">\&quot;{Binding</span> <span class="err">BuscaPokemonCommand}\&quot;</span> <span class="na">text=</span><span class="s">\&quot;{Binding</span> <span class="err">SearchTerms}\&quot;</span> <span class="nt">/&gt;</span>

<span class="nt">&lt;p&gt;</span></code></pre></figure></p>

<p>Entonces cada vez que el usuario cambie el texto de la caja de búsqueda, la propiedad <code>SearchTerms</code> del <em>viewmodel</em> también cambiará. Y no solo eso, sino que también el control tiene enlazado el comando <code>BuscaPokemonCommand</code>, el comando se ejecutará cuando el usuario decida buscar Pokémons.</p>

<p>Como puedes ver, las tres propiedades (<code>PokemonName</code>, <code>SearchTerms y </code>SearchCommand`) existen en el <em>viewmodel</em>. En caso de que no existiera alguna, no pasará absolutamente nada, no habrá errores ni excepciones, es por eso que se dice que es un poco difícil de <em>debuggear</em> estos enlaces de datos.</p>

<h3 id=\"converters\">Converters</h3>

<p>Además de <code>Binding</code> probablemente te hayas fijado en la palabra <code>Converter</code>… así que es hora de explicar los <em>converters</em>. Estos no son más que instancias de tipos que implementan la interfaz <code>IConvertValue</code> que en pocas palabras hace eso: convertir valores.</p>

<p>En el más estricto de los sentidos el <em>viewmodel</em> debe ser independiente de la plataforma y exponer solamente las propiedades necesarias para que la vista opere. Pero, ¿qué pasa si nosotros queremos extender un poco más esa funcionalidad?</p>

<p>Por ejemplo, en la app <em>Mvvmdex</em> quisiera mostrar u ocultar un panel dependiendo de si el Pokémon fue encontrado o no, el <em>viewmodel</em> ofrece la propiedad booleana <code>HasConicidence</code> que podemos ligar a <code>IsVisible</code>:</p>

<p><figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="ni">&amp;lt;</span>StackLayout IsVisible=”{Binding HasCoincidence}” … /<span class="ni">&amp;gt;</span></code></pre></figure></p>

<p>Sin embargo, no podemos ligar esa propiedad directamente con otro control para que se “esconda” cuando haya coincidencia, es por eso que se implementó la clase <code>BooleanInverterConverter</code>:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">BooleanInverterConverter</span> <span class="p">:</span> <span class="n">IValueConverter</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="kt">object</span> <span class="nf">Convert</span><span class="p">(</span><span class="kt">object</span> <span class="k">value</span><span class="p">,</span> <span class="n">Type</span> <span class="n">targetType</span><span class="p">,</span> <span class="kt">object</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">CultureInfo</span> <span class="n">culture</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="p">!(</span><span class="kt">bool</span><span class="p">)</span><span class="k">value</span><span class="p">;</span>
	<span class="p">}&lt;/</span><span class="n">p</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="n">pre</span><span class="p">&gt;&lt;</span><span class="n">code</span><span class="p">&gt;</span><span class="k">public</span> <span class="kt">object</span> <span class="n">ConvertBack</span><span class="p">(</span><span class="kt">object</span> <span class="k">value</span><span class="p">,</span> <span class="n">Type</span> <span class="n">targetType</span><span class="p">,</span> <span class="kt">object</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">CultureInfo</span> <span class="n">culture</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">throw</span> <span class="k">new</span> <span class="nf">NotImplementedException</span><span class="p">();</span>
<span class="p">}</span> <span class="p">}</span> </code></pre></figure>  
</code></pre>

<p>Que como puedes ver tiene dos métodos, uno para convertir “de ida” y uno “de vuelta”, esta app solo hace uso del “de ida” y únicamente niega el valor booleano que se le pase.</p>

<p>Luego entonces ya podemos usarlo en nuestra pantalla, primero declarándolo dentro de los recursos de la pantalla:</p>

<p><figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;contentpage.resources&gt;</span>
	<span class="nt">&lt;resourcedictionary&gt;</span>
		<span class="nt">&lt;converters:booleaninverterconverter</span> <span class="na">x:key=</span><span class="s">\&quot;BooleanInverter\&quot;</span> <span class="nt">/&gt;</span> </code></pre></figure>  

Para luego usarlo junto con un enlace a datos en un control:

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;label</span> <span class="na">isvisible=</span><span class="s">\&quot;{Binding</span> <span class="err">HasCoincidence,</span> <span class="na">Converter=</span><span class="s">{StaticResource</span> <span class="err">BooleanInverter}}\&quot;</span> <span class="na">text=</span><span class="s">\&quot;😕\&quot;</span> <span class="na">grid.row=</span><span class="s">\&quot;1\&quot;</span> <span class="na">horizontaltextalignment=</span><span class="s">\&quot;Center\&quot;</span> <span class="na">fontsize=</span><span class="s">\&quot;100\&quot;</span> <span class="nt">/&gt;</span></code></pre></figure>  

### Enlace con el ViewModel

Para terminar todo esto, falta un paso muy importante, y es el de relacionar de alguna manera la vista con el *viewmodel*. Hay muchas maneras de hacer esto, sin embargo, una de las más prácticas es establecer el nuestro *viewmodel* como el `BindingContext` de la vista. Para esta app, la acción se realiza en el *code behind* de la página `MvvmdexPage`:

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">MvvmdexPage</span> <span class="p">:</span> <span class="n">ContentPage</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nf">MvvmdexPage</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">BindingContext</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PokemonSearchViewModel</span><span class="p">();</span> <span class="c1">// &amp;lt;- ViewModel</span>
		<span class="c1">// ....</span></code></pre></figure>  

## Para cerrar

Existen muchas más posibilidades para hacer más robusta una aplicación de Forms con *MVVM*, como el uso de la inyección de dependencias para integrar más capacidades como navegación entre pantallas, acceso a sensores del teléfono y más. También puedes integrar frameworks como <a href=\"http://www.mvvmlight.net/doc/\" target=\"_blank\" rel=\"nofollow\">mvvm light</a> o <a href=\"https://github.com/PrismLibrary/Prism#prism\" target=\"_blank\" rel=\"nofollow\">Prism</a> para liberarte de hacer tus propias implementaciones de `ICommand` e `INotifyPropertyChanged`. 

Espero que este post te haya servido, recuerda que la mejor forma de aprender es experimentando, así que te invito a que <a href=\"https://github.com/ThatCSharpGuy/xfmvvm\" target=\"_blank\" rel=\"nofollow\">descargues el código de GitHub</a> y juegues un poco con él, si tienes dudas, puedes contactarme sin problemas.
</resourcedictionary></contentpage.resources>
"
}