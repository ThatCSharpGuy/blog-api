{	
	"id" : "/post/mvvm-xamarin-forms/",
	"tv" : false,
	"date": "2016-06-26 16:00:00 -0500",
	"title" : "MVVM en Xamarin.Forms, caso pr√°ctico",
	"author" : "Antonio Feregrino Bola√±os",
	"featured_image": "http://thatcsharpguy.com/postimages//mvvm/mvvm-featured.png",
	"tags" : ["Xamarin","XamarinForms","Mvvm"],
	"content": "Mvvmdex\n=  \nSoy un gran fan√°tico de Pok√©mon y es por eso que para este post haremos una aplicaci√≥n que se encargar√° de buscar pok√©mons en la Pok√©API usando la <a href=\"#\">Jirapi</a> y mostrar los datos encontrados en la pantalla. En esta aplicaci√≥n se implementa el patr√≥n MVVM para la separaci√≥n de responsabilidades.\n\n<img src=\"http://i.giphy.com/Mo4P4sEJNUKeQ.gif\" />\n\n## Introducci√≥n  \nDentro de este post voy a asumir que ya tienes un entendimiento b√°sico de c√≥mo es que funciona Xamarin, Xamarin.Forms y la teor√≠a de MVVM, si no, te invito a que consultes mi post sobre [qu√© es Xamarin](../../tv/xamarin/), el [video sobre Xamarin.Forms](../../tv/xamarin-forms/), y el [video sobre MVVM](../../tv/mvvm).\n\n## Estructura\n\nComo ya sabr√°s, el <a href=\"organizacion-codigo-visual-studio\">c√≥digo en Visual Studio</a> se organiza en proyectos, y esta es la organizaci√≥n de los proyectos para esta peque√±a app:\n\n post_image codeorg.png \"Code organization\"   \n\nLa separaci√≥n de MVVM se puede observar en que el proyecto `Mvvmdex.Views` se relaciona con `Mvvmdex.ViewModels` y a su vez este √∫ltimo se relaciona con `Mvvmdex.Models`, **nunca hay relacion directa entre las vistas y los modelos**.\n\n## Modelo  \n\nPara este proyecto, el modelo est√° contenido dentro de `Mvvmdex.Models`. Como sabe, en el modelo es donde se realiza el acceso a datos y la l√≥gica de la aplicaci√≥n. En esta aplicaci√≥n, el *Mvvmdex*, √∫nicamente se consulta a la Pok√©API dentro de la clase `MvvmdexClient`. Como puedes ver, no tiene ninguna relaci√≥n con la vista:\n\n<pre class=\"csharp\">\npublic async Task<Pokemon> SearchForPokemon(string pokemonName)\n\n\ttry\n\t\n\t\tvar pkmn = await _client.Get<Jirapi.Resources.Pokemon>(pokemonName);\n\t\tvar species = await pkmn.Species.GetResource(_client);\n\t\treturn new Pokemon\n\t\t\n\t\t\tId = pkmn.Id,\n\t\t\tName = pkmn.Name,\n\t\t\tDescription = species.FlavorTextEntries\n\t\t\t\t.FirstOrDefault(te => te.Language.Name == \"en\")?\n\t\t\t\t.FlavorText.Replace(\"\\n\",\"\"),\n\t\t\tShape = species.Shape.Name\n\t\t;\n\t\n\tcatch\n\t\n\t\treturn null;\n\t\n\n</pre>   \n\n## ViewModels\n\nPara este proyecto, el modelo est√° contenido dentro de `Mvvmdex.ViewModels`. Esta es la parte m√°s complicada, hay que recordar que este es el intermediario entre la vista y el modelo. Para esta app √∫nicamente existe un solo ViewModel, `PokemonSearchViewModel`, pero es muy com√∫n que tu tengas varios dependiendo del tama√±o y complejidad de tu aplicaci√≥n. \n\nEsta secci√≥n tiene relaci√≥n directa con el Modelo, en el *Mvvmdex* se hace referencia en el cliente `MvvmdexClient`:\n\n<pre class=\"csharp\">\nprivate MvvmdexClient _client;\n\npublic PokemonSearchViewModel()\n\n\t_client = new MvvmdexClient(); // <- Model\n\n</pre>  \n\nEl modelo puede enviar y recibir mensajes del *viewmodel* a trav√©s de m√©todos.\n\n### INotifyPropertyChanged\n\nLa interfaz `INotifyPropertyChanged` permitir√° a la vista ser notificada cada vez que suceda alg√∫n cambio en el *viewmodel*. La interfaz √∫nicamente expone el evento `PropertyChanged` que debemos invocar cada vez que queremos notificar a la vista alg√∫n cambio. Para hacer la tarea m√°s sencilla, se crea un m√©todo auxiliar:\n\n<pre class=\"csharp\">\npublic void RaiseOnPropertyChange([CallerMemberName] string propertyName = null)\n\n\tif (PropertyChanged != null)\n\t\n\t\tPropertyChanged(this, new PropertyChangedEventArgs(propertyName));\n\t\n\n</pre>  \n\nEl atributo `CallerMemberName` nos facilitar√° la tarea, ya que con √©l aseguramos que el nombre de la propiedad desde la que lo llamemos ser√° colocada ah√≠ para notificar a la vista sobre la propiedad correcta.  \n\nEs importante decir que existen muchos frameworks de *mvvm* que ya contienen una implementaci√≥n de esta interfaz y para nosotros bastar√≠a con derivar nuestros objetos de dicha implementaci√≥n para no tener que hacerla nosotros mismos.\n\n### Propiedades  \n\nCon las propiedades hay una peque√±a limitante: no pueden ser propiedades auto-implementadas, ya que es necesario llamar a nuestro m√©todo auxiliar creado m√°s arriba. Mira la propiedad `PokemonName`:\n\n<pre class=\"csharp\">\nprivate string _pokemonName;\n\npublic string PokemonName\n\n\tget  return _pokemonName; \n\tset  _pokemonName = value; RaiseOnPropertyChange(); /* RaiseOnPropertyChange(\"PokemonName\") */ \n\n</pre>  \n\nComo puedes ver, cada vez que ocurre un cambio en la propiedad, se est√° notificando a qui√©n desee sobre el cambio, en nuestro caso, la vista es quien desea ser notificada. M√°s adelante, con los *data bindings*, enlazaremos las propiedades en el *viewmodel* con elementos dentro de la vista.\n \n### Commands  \n\nLos *commands* es otro de los mecanismos que contempla *mvvm* para la comunicaci√≥n entre los componentes, y es a trav√©s de ellos que se trasladan algunos de los eventos generados en la vista hacia el *viewmodel*. En Xamarin.Forms un comando no es m√°s que una instancia de objeto que implementa la interfaz `ICommand`, en el caso de esta app, tenemos el comando `BuscaPokemonCommand` que lo √∫nico que hace es ejecutar una `Action` cuando se ejecuta.\n\n<pre class=\"csharp\">\npublic class BuscaPokemonCommand : ICommand\n\n\tprivate readonly Action _search;\n\tpublic BuscaPokemonCommand(Action search)\n\t\n\t\t_search = search;\n\t\n\n\tpublic bool CanExecute(object parameter)\n\t\n\t\treturn true;\n\t\n\n\tpublic void Execute(object parameter)\n\t\n\t\t\t_search();\n\t\n\n\tpublic event EventHandler CanExecuteChanged;\n\n</pre>  \n\nLa interfaz ICommand contiene tres miembros:  \n  \n - `bool CanExecute(object parameter)` - con el cual podemos decidir si el comando se puede ejecutar \n - `void Execute(object parameter)` - en el cual debemos efectuar la ejecuci√≥n\n - `event EventHandler CanExecuteChanged` - es un evento que debe invocarse cada vez que las condiciones bajo las que se puede invocar un comando han cambiado.\n\nEs importante mencionar que al igual que con la interfaz `INotifyPropertyChanged`, ya existen varios frameworks que proveen implementaciones gen√©ricas de `ICommand` para evitarnos el tedio de escribirlos nosotros mismos.\n\n#### En el ViewModel\n\nAhora, la forma en la que se usa este comando es a trav√©s de una propiedad ya que m√°s adelante ser√° enlazada con un control dentro de la vista:\n\n<pre class=\"csharp\">\nprivate ICommand _buscaPokemonCommand;\npublic ICommand BuscaPokemonCommand\n\n\tget\n\t\n\t\tif (_buscaPokemonCommand == null)\n\t\t\n\t\t\tAction buscaPokemonAction = async () =>\n\t\t\t\n\t\t\tvar pokemon = await _client.SearchForPokemon(SearchTerms.ToLower());\n\n\t\t\t\tHasCoincidence = pokemon != null;\n\t\t\t\tif (HasCoincidence)\n\t\t\t\t\n\t\t\t\t\tDescription = pokemon.Description;\n\t\t\t\t\tPokemonName = String.Format(\"0:D3 1\", pokemon.Id, pokemon.Name);\n\t\t\t\t\tShape = pokemon.Shape;\n\t\t\t\t\n\t\t\t;\n\t\t\t_buscaPokemonCommand = new BuscaPokemonCommand(buscaPokemonAction);\n\t\t\n\t\treturn _buscaPokemonCommand;\n\t\n\n</pre>  \n\n## Vista\n \nHay que recordar que en Forms podemos crear nuestras interfaces a trav√©s de c√≥digo C# o XAML, para esta ocasi√≥n usar√© XAML para crear la pantalla.\n\nLa vista de la aplicaci√≥n es bastante simple, √∫nicamente consta de un cuadro de b√∫squeda (`SearchBar`), un contenedor (`StackLayout`) que contiene varias etiquetas (`Label`) para mostrar los datos de Pok√©mon en cuesti√≥n y por √∫ltimo una etiqueta para mostrar en caso de que no encontremos un pok√©mon que coincida con nuestra b√∫squeda:\n\n<pre class=\"xml\">\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" \n\t\txmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" \n\t\txmlns:converters=\"clr-namespace:Mvvmdex.Views.Converters\" \n\t\tx:Class=\"Mvvmdex.Views.MvvmdexPage\" \n\t\tTitle=\"Mvvmdex\">\n\t<ContentPage.Resources>\n\t\t<ResourceDictionary>\n\t\t\t<converters:BooleanInverterConverter x:Key=\"BooleanInverter\" />\n\t\t\t<converters:ShapeToEmojiConverter x:Key=\"ShapeToEmoji\" />\n\t\t</ResourceDictionary>\n\t</ContentPage.Resources>\n\t<Grid>\n\t\t<Grid.RowDefinitions>\n\t\t\t<RowDefinition Height=\"Auto\" />\n\t\t\t<RowDefinition Height=\"*\" />\n\t\t</Grid.RowDefinitions>\n\t\t\n\t\t<SearchBar Grid.Row=\"0\" SearchCommand=\"Binding BuscaPokemonCommand\" \n\t\t\tText=\"Binding SearchTerms\" />\n\t\t\n\t\t<StackLayout IsVisible=\"Binding HasCoincidence\" Grid.Row=\"1\" Padding=\"20\" Spacing=\"10\">\n\t\t\t<Label Text=\"Binding PokemonName\" FontSize=\"Large\" />\n\t\t\t<Label Text=\"Binding Description\" />\n\t\t\t<Label Text=\"Binding Shape, Converter=StaticResource ShapeToEmoji\" />\n\t\t</StackLayout>\n\t\t\n\t\t<Label IsVisible=\"Binding HasCoincidence, Converter=StaticResource BooleanInverter\" \n\t\t\tText=\"üòï\" Grid.Row=\"1\" HorizontalTextAlignment=\"Center\" FontSize=\"100\" />\n\t</Grid>\n</ContentPage>\n</pre>  \n\n### Data bindings\n\nSi ves mucho `Binding` en el c√≥digo no te preocupes, es algo muy com√∫n en *MVVM*, y es que es ah√≠ donde ocurre el enlace de la vista al *viewmodel*, una de las partes centrales del patr√≥n. Los *data bindings* se encargan de \"estar al tanto\" de los cambios que informa el *viewmodel* y reflejarlos en la pantalla cuando sucedan.\n\nPor ejemplo, la etiqueta en la que se muestra el nombre y el n√∫mero del Pok√©mon:\n\n<pre class=\"xml\">\n<Label Text=\"Binding PokemonName\" FontSize=\"Large\" />\n</pre>  \n\nMediante los *bindings* el texto del `Label` cambiar√° cada vez que la propiedad `PokemonName` lo haga.\n\nSin embargo, los bindings no son solo de una direcci√≥n (*viewmodel* ‚Üí vista), sino que tambi√©n pueden ser usados al rev√©s. Tomemos, por ejemplo el control `SearchBar`:\n\n<pre class=\"xml\">\n<SearchBar Grid.Row=\"0\" SearchCommand=\"Binding BuscaPokemonCommand\" Text=\"Binding SearchTerms\" />\n</pre>\n\nEntonces cada vez que el usuario cambie el texto de la caja de b√∫squeda, la propiedad `SearchTerms` del *viewmodel* tambi√©n cambiar√°. Y no solo eso, sino que tambi√©n el control tiene enlazado el comando `BuscaPokemonCommand`, el comando se ejecutar√° cuando el usuario decida buscar Pok√©mons.  \n\nComo puedes ver, las tres propiedades (`PokemonName`, `SearchTerms y `SearchCommand`) existen en el *viewmodel*. En caso de que no existiera alguna, no pasar√° absolutamente nada, no habr√° errores ni excepciones, es por eso que se dice que es un poco dif√≠cil de *debuggear* estos enlaces de datos.  \n\n### Converters  \n\nAdem√°s de `Binding` probablemente te hayas fijado en la palabra `Converter`... as√≠ que es hora de explicar los *converters*. Estos no son m√°s que instancias de tipos que implementan la interfaz `IConvertValue` que en pocas palabras hace eso: convertir valores.\n\nEn el m√°s estricto de los sentidos el *viewmodel* debe ser independiente de la plataforma y exponer solamente las propiedades necesarias para que la vista opere. Pero, ¬øqu√© pasa si nosotros queremos extender un poco m√°s esa funcionalidad? \n\nPor ejemplo, en la app *Mvvmdex* quisiera mostrar u ocultar un panel dependiendo de si el Pok√©mon fue encontrado o no, el *viewmodel* ofrece la propiedad booleana `HasConicidence` que podemos ligar a `IsVisible`:\n\n<pre class=\"xml\">\n<StackLayout IsVisible=\"Binding HasCoincidence\" ... />\n</pre>  \n\nSin embargo, no podemos ligar esa propiedad directamente con otro control para que se \"esconda\" cuando haya coincidencia, es por eso que se implement√≥ la clase `BooleanInverterConverter`:\n\n<pre class=\"csharp\">\npublic class BooleanInverterConverter : IValueConverter\n\n\tpublic object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n\t\n\t\treturn !(bool)value;\n\t\n\n\tpublic object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n\t\n\t\tthrow new NotImplementedException();\n\t\n\n</pre>  \n\nQue como puedes ver tiene dos m√©todos, uno para convertir \"de ida\" y uno \"de vuelta\", esta app solo hace uso del \"de ida\" y √∫nicamente niega el valor booleano que se le pase.\n\nLuego entonces ya podemos usarlo en nuestra pantalla, primero declar√°ndolo dentro de los recursos de la pantalla:\n\n<pre class=\"xml\">\n<ContentPage.Resources>\n\t<ResourceDictionary>\n\t\t<converters:BooleanInverterConverter x:Key=\"BooleanInverter\" /> \n</pre>  \n\nPara luego usarlo junto con un enlace a datos en un control:\n\n<pre class=\"xml\">\n<Label IsVisible=\"Binding HasCoincidence, Converter=StaticResource BooleanInverter\" \n\tText=\"üòï\" Grid.Row=\"1\" HorizontalTextAlignment=\"Center\" FontSize=\"100\" />\n</pre>  \n\n### Enlace con el ViewModel\n\nPara terminar todo esto, falta un paso muy importante, y es el de relacionar de alguna manera la vista con el *viewmodel*. Hay muchas maneras de hacer esto, sin embargo, una de las m√°s pr√°cticas es establecer el nuestro *viewmodel* como el `BindingContext` de la vista. Para esta app, la acci√≥n se realiza en el *code behind* de la p√°gina `MvvmdexPage`:\n\n<pre class=\"csharp\">\npublic partial class MvvmdexPage : ContentPage\n\n\tpublic MvvmdexPage()\n\t\n\t\tBindingContext = new PokemonSearchViewModel(); // <- ViewModel\n\t\t// ....\n</pre>  \n\n## Para cerrar\n\nExisten muchas m√°s posibilidades para hacer m√°s robusta una aplicaci√≥n de Forms con *MVVM*, como el uso de la inyecci√≥n de dependencias para integrar m√°s capacidades como navegaci√≥n entre pantallas, acceso a sensores del tel√©fono y m√°s. Tambi√©n puedes integrar frameworks como <a href=\"http://www.mvvmlight.net/doc/\" target=\"_blank\" rel=\"nofollow\">mvvm light</a> o <a href=\"https://github.com/PrismLibrary/Prism#prism\" target=\"_blank\" rel=\"nofollow\">Prism</a> para liberarte de hacer tus propias implementaciones de `ICommand` e `INotifyPropertyChanged`. \n\nEspero que este post te haya servido, recuerda que la mejor forma de aprender es experimentando, as√≠ que te invito a que <a href=\"https://github.com/ThatCSharpGuy/xfmvvm\" target=\"_blank\" rel=\"nofollow\">descargues el c√≥digo de GitHub</a> y juegues un poco con √©l, si tienes dudas, puedes contactarme sin problemas."
}