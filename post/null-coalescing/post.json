{	
	"id" : "/post/null-coalescing/",
	"tv" : false,
	"date": "2016-09-19 14:00:01 -0500",
	"title" : "Operador null coalescing en C#",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//aprende-c-sharp/null-c.png",
	"tags" :
	["AprendeCSharp"],
	
	"content" : body"Pese a estar desarrollando en C# desde hace tiempo, tengo que aceptar que hay algunas cosas que me tardé en conocer... entre ellas, el operador `??` . Seguramente ya lo conoces, pero si no, te invito a seguir leyendo para que lo hagas. En realidad, aunque lo conozcas te invito a seguir leyendo, espero apreandas algo nuevo.\n\nEste operador es básicamente una especie de <a href=\"../../tv/azucar-sintactica\" target=\"_blank\">azúcar sintáctica</a> para escribir una **asignación condicional** de tipos por referencia. En otras palabras (en código), observa las siguientes líneas:\n\n{% highlight csharp %}\nstring personName;\nif (inputName == null)\n    personName = \"no name\";\nelse\n    personName = inputName;\nConsole.WriteLine(personName);\n{% endhighlight %}  \n\nSi `inputName` es `null`, el valor de `personName` será *\"no name\"* para cuando el método `WriteLine`, todo eso en 4 líneas. Pero esta no es la única forma de realizar la asignación dependiendo del valor, también podríamos haber hecho uso del <a href=\"https://msdn.microsoft.com/en-us/library/be21c7hw(VS.94).aspx\" target=\"_blank\">operador ternario</a>:  \n\n{% highlight csharp %}\npersonName = inputName == null ? \"no name\" : inputName;\nConsole.WriteLine(personName);\n{% endhighlight %}  \n\n### Null coalescing\n\nQue producirá el mismo resultado si `inputName == null`, todo en 1 sola línea... sin embargo esta sigue sin ser la manera más corta de realizar una asignación de este tipo, la más corta se consigue a través del operador `??`, llamado **null coalescing** (o de uso combinado de NULL, en español):\n\n{% highlight csharp %}\npersonName = inputName ?? \"no name\";\nConsole.WriteLine(personName);\n{% endhighlight %}  \n\nY listo, realiza la misma acción que los dos bloques de código anteriores, pero en menor cantidad de caracteres.\n\nSi aún no has inferido su funcionamiento, es el siguiente: la asignación comienza del lado derecho del signo `=`, y va de izquierda a derecha evaluando los las expresiones en busca del primer valor no nulo, en cuanto alguno sea distinto de `null`, lo asignará a la variable ubicada a la izquierda de `=`.  \n\n### Encadenamiento\n\nOtra de sus particularidades es que permite ser *encadenado*: si colocamos un operador tras otro, se aplicará el mismo principio de buscar desde la izquierda el primer valor no nulo para ser asignado:  \n\n{% highlight csharp %}\npersonName = inputName ?? GetRandomName() ?? TryGetName() ?? \"no name\";\n{% endhighlight %}\n\nSi esta misma asignación se intentara haecer con sentencias `if` o con operadores ternarios, la cantidad de código a escribir aumentaría considerablemente.\n\n### Tipos nullables   \n\nUno de sus usos es junto a los <a href=\"../tipos-nullables-en-c-sharp\">tipos nullables</a>: \n\n{% highlight csharp %}\nint? teamAPoints = null;\nint? teamBPoints = 5;\n\nvar difference = (teamAPoints ?? 0) - (teamBPoints ?? 0);\nConsole.WriteLine(\"Difference \" + difference);\n{% endhighlight %}  \n\n### Carga diferida\nTambién suele ser muy frecuente que este operador sea usado para implementar la *carga diferida* o <a href=\"https://es.wikipedia.org/wiki/Lazy_loading\" target=\"_blank\">lazy loading</a> o el patrón *singleton*:\n\n{% highlight csharp %}\nprivate static Random _random;\npublic static Random Random\n{\n    get\n    {\n        return _random ?? (_random = new Random(DateTime.Now.Second));\n    }\n}\n{% endhighlight %}  \n\nPara la primera vez que llamemos a `Random`, se ejecutará la parte derecha de la instrucción y para llamadas subsecuentes, únicamente nos devolverá eñ valor de `_random`.\n\n### Observaciones\n\nEs importante señalar que para que el operador funcione, los tipos a evaluar deben ser del mismo tipo (o al menos tener conversión implícita) ya que de otro modo, el compilador nos mostrará un error e impedirá la ejecución del programa. El siguiente segmento de código es inválido, ya que `personName` es una cadena y `teamAPoints` es *nullable de int*\n\n{% highlight csharp %}\nvar invalid = personName ?? teamAPoints;\n{% endhighlight %}  \n\n### En C# 6  \nLas cosas buenas no acaban ahí, este operador cobra mayor relevancia cuando lo combinamos con una de las nuevas funciones de C#, <a href=\"../c-sharp-seis/#null-conditional-operator\" target=\"_blank\"><em>null-conditional operator</em></a> (`?.`) podemos la funcionalidad que deseamos y sin usar tantas líneas de código:\n\n{% highlight csharp %}\nvar randomOrNot = MainClass.Random?.Next(0, 10) ?? 0;\n{% endhighlight %}  \n\n### Ventajas  \nPara ser honesto, aunque todo depende de quién lo mira, al operador `??` le encuentro únicamente ventajas:  \n\n - Es más corto y fácil de escribir  \n - Es más fácil de leer\n - Podemos implementar *singletons* o *carga diferida*\n - Puede ser encadenado uno tras de otro\n\n¿Tu le encuentras otra ventaja o una desventaja? mándame un tuit, un correo o deja un comentario en la parte de abajo.\n"
}