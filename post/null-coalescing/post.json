{	
	"id" : "/post/null-coalescing/",
	"tv" : false,
	"date": "2016-09-19 14:00:01 -0500",
	"title" : "Operador null coalescing en C#",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//aprende-c-sharp/null-c.png",
	"tags" : ["AprendeCSharp"],
	  
	"content": '"Pese a estar desarrollando en C# desde hace tiempo, tengo que aceptar que hay algunas cosas que me tardé en conocer... entre ellas, el operador `??` . Seguramente ya lo conoces, pero si no, te invito a seguir leyendo para que lo hagas. En realidad, aunque lo conozcas te invito a seguir leyendo, espero apreandas algo nuevo.\n\nEste operador es básicamente una especie de <a href=\"../../tv/azucar-sintactica\" target=\"_blank\">azúcar sintáctica</a> para escribir una **asignación condicional** de tipos por referencia. En otras palabras (en código), observa las siguientes líneas:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nstring</span> <span class="n">personName</span><span class="p">;</span><span class="err">\</span><span class="n">nif</span> <span class="p">(</span><span class="n">inputName</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span><span class="err">\</span><span class="n">n</span>    <span class="n">personName</span> <span class="p">=</span> <span class="err">\</span><span class="s">&quot;no name\&quot;;\nelse\n    personName = inputName;\nConsole.WriteLine(personName);\n</span></code></pre></figure>  \n\nSi `inputName` es `null`, el valor de `personName` será *\"no name\"* para cuando el método `WriteLine`, todo eso en 4 líneas. Pero esta no es la única forma de realizar la asignación dependiendo del valor, también podríamos haber hecho uso del <a href=\"https://msdn.microsoft.com/en-us/library/be21c7hw(VS.94).aspx\" target=\"_blank\">operador ternario</a>:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npersonName</span> <span class="p">=</span> <span class="n">inputName</span> <span class="p">==</span> <span class="k">null</span> <span class="p">?</span> <span class="err">\</span><span class="s">&quot;no name\&quot; : inputName;\nConsole.WriteLine(personName);\n</span></code></pre></figure>  \n\n### Null coalescing\n\nQue producirá el mismo resultado si `inputName == null`, todo en 1 sola línea... sin embargo esta sigue sin ser la manera más corta de realizar una asignación de este tipo, la más corta se consigue a través del operador `??`, llamado **null coalescing** (o de uso combinado de NULL, en español):\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npersonName</span> <span class="p">=</span> <span class="n">inputName</span> <span class="p">??</span> <span class="err">\</span><span class="s">&quot;no name\&quot;;\nConsole.WriteLine(personName);\n</span></code></pre></figure>  \n\nY listo, realiza la misma acción que los dos bloques de código anteriores, pero en menor cantidad de caracteres.\n\nSi aún no has inferido su funcionamiento, es el siguiente: la asignación comienza del lado derecho del signo `=`, y va de izquierda a derecha evaluando los las expresiones en busca del primer valor no nulo, en cuanto alguno sea distinto de `null`, lo asignará a la variable ubicada a la izquierda de `=`.  \n\n### Encadenamiento\n\nOtra de sus particularidades es que permite ser *encadenado*: si colocamos un operador tras otro, se aplicará el mismo principio de buscar desde la izquierda el primer valor no nulo para ser asignado:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npersonName</span> <span class="p">=</span> <span class="n">inputName</span> <span class="p">??</span> <span class="n">GetRandomName</span><span class="p">()</span> <span class="p">??</span> <span class="n">TryGetName</span><span class="p">()</span> <span class="p">??</span> <span class="err">\</span><span class="s">&quot;no name\&quot;;\n</span></code></pre></figure>\n\nSi esta misma asignación se intentara haecer con sentencias `if` o con operadores ternarios, la cantidad de código a escribir aumentaría considerablemente.\n\n### Tipos nullables   \n\nUno de sus usos es junto a los <a href=\"../tipos-nullables-en-c-sharp\">tipos nullables</a>: \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nint</span><span class="p">?</span> <span class="n">teamAPoints</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span><span class="err">\</span><span class="n">nint</span><span class="p">?</span> <span class="n">teamBPoints</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">nvar</span> <span class="n">difference</span> <span class="p">=</span> <span class="p">(</span><span class="n">teamAPoints</span> <span class="p">??</span> <span class="m">0</span><span class="p">)</span> <span class="p">-</span> <span class="p">(</span><span class="n">teamBPoints</span> <span class="p">??</span> <span class="m">0</span><span class="p">);</span><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;Difference \&quot; + difference);\n</span></code></pre></figure>  \n\n### Carga diferida\nTambién suele ser muy frecuente que este operador sea usado para implementar la *carga diferida* o <a href=\"https://es.wikipedia.org/wiki/Lazy_loading\" target=\"_blank\">lazy loading</a> o el patrón *singleton*:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nprivate</span> <span class="k">static</span> <span class="n">Random</span> <span class="n">_random</span><span class="p">;</span><span class="err">\</span><span class="n">npublic</span> <span class="k">static</span> <span class="n">Random</span> <span class="n">Random</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="k">get</span><span class="err">\</span><span class="n">n</span>    <span class="p">{</span><span class="err">\</span><span class="n">n</span>        <span class="k">return</span> <span class="n">_random</span> <span class="p">??</span> <span class="p">(</span><span class="n">_random</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Random</span><span class="p">(</span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">Second</span><span class="p">));</span><span class="err">\</span><span class="n">n</span>    <span class="p">}</span><span class="err">\</span><span class="n">n</span><span class="p">}</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\nPara la primera vez que llamemos a `Random`, se ejecutará la parte derecha de la instrucción y para llamadas subsecuentes, únicamente nos devolverá eñ valor de `_random`.\n\n### Observaciones\n\nEs importante señalar que para que el operador funcione, los tipos a evaluar deben ser del mismo tipo (o al menos tener conversión implícita) ya que de otro modo, el compilador nos mostrará un error e impedirá la ejecución del programa. El siguiente segmento de código es inválido, ya que `personName` es una cadena y `teamAPoints` es *nullable de int*\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">invalid</span> <span class="p">=</span> <span class="n">personName</span> <span class="p">??</span> <span class="n">teamAPoints</span><span class="p">;</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\n### En C# 6  \nLas cosas buenas no acaban ahí, este operador cobra mayor relevancia cuando lo combinamos con una de las nuevas funciones de C#, <a href=\"../c-sharp-seis/#null-conditional-operator\" target=\"_blank\"><em>null-conditional operator</em></a> (`?.`) podemos la funcionalidad que deseamos y sin usar tantas líneas de código:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">randomOrNot</span> <span class="p">=</span> <span class="n">MainClass</span><span class="p">.</span><span class="n">Random</span><span class="p">?.</span><span class="n">Next</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span> <span class="p">??</span> <span class="m">0</span><span class="p">;</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\n### Ventajas  \nPara ser honesto, aunque todo depende de quién lo mira, al operador `??` le encuentro únicamente ventajas:  \n\n - Es más corto y fácil de escribir  \n - Es más fácil de leer\n - Podemos implementar *singletons* o *carga diferida*\n - Puede ser encadenado uno tras de otro\n\n¿Tu le encuentras otra ventaja o una desventaja? mándame un tuit, un correo o deja un comentario en la parte de abajo.\n"'   
}