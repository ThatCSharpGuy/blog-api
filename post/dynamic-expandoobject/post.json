{	
	"id" : "/post/dynamic-expandoobject/",
	"tv" : false,
	"date": "2016-12-06 13:00:02 -0600",
	"title" : "Dynamic y ExpandoObject",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//aprende-c-sharp/dynamic.jpg",
	"tags" :
	[ 
		"AprendeCSharp"
	],
	"content" : "<p>Cuando C# nació hace 16 años, nació como un lenguaje fuertemente tipado, y, mientras que lo sigue siendo, a partir de su versión 4.0 incorporó características que permitían usar tipado débil en él.</p>

<p>Como sabrás, un lenguaje fuertemente tipado requiere que los tipos de las variables sean conocidos por el compilador al momento de compilar. Es decir, especificar que un entero es un entero, que una cadena es una cadena… por otro lado <strong>que un lenguaje sea débilmente tipado significa que el compilador no sabe nada de las variables con las que está trabajando</strong> y que será hasta que se estén ejecutando cuando se tenga conocimiento sobre ellas.</p>

<p>En C# creamos un tipo de dato “débilmente tipado” con la palabra reservada <code>dynamic</code>, lo cual le indica al compilador que no debe preocuparse por esa variable. Por ejemplo:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">dynamic</span> <span class="n">entero</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="kt">dynamic</span> <span class="n">cadena</span> <span class="p">=</span> <span class="err">“</span><span class="n">Hola</span><span class="err">”</span><span class="p">;</span>
<span class="kt">dynamic</span> <span class="n">cadena2</span> <span class="p">=</span> <span class="err">“</span><span class="n">mundo</span><span class="err">”</span><span class="p">;</span></code></pre></figure></p>

<p>Nosotros podemos inferir que <code>entero</code> es del tipo <code>int</code>, y que <code>cadena</code> y <code>cadena2</code> son <em>strings</em>, sin embargo, para nuestro compilador esto es desconocido ya que como son <code>dynamic</code> esto solo se resolverá hasta que el programa se esté ejecutando.</p>

<p>Es por eso que al llamar al método <em>inexistente</em> <code>Abcdefg</code> dentro de la clase Int32, el compilador no genera ningun error:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">entero</span><span class="p">.</span><span class="n">Abcdefg</span><span class="p">());</span> <span class="c1">// RuntimeException</span></code></pre></figure></p>

<p>Sin embargo, si ejecutamos esa línea obtendremos una excepción, indicandonos que dicho método no existe dentro de ese objeto.</p>

<p><strong>En realidad los tipos que son marcados como <code>dynamic</code> si poseen un tipo asociado</strong> solo que el compilador no conoce (y no le importa), y entonces asume que los objetos declarados de esta manera soportan cualquier operación.</p>

<p>Puedes comprobar que todos tienen un tipo de dato asociado si llamas al método <code>GetType</code> sobre los tipos de dato dinámicos:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">entero</span><span class="p">.</span><span class="n">GetType</span><span class="p">());</span> <span class="c1">// Imprime “System.Int32”</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">cadena</span><span class="p">.</span><span class="n">GetType</span><span class="p">());</span> <span class="c1">// Imprime “System.String”</span></code></pre></figure></p>

<h2 id=\"compatibilidad-con-otros-tipos-de-dato\">Compatibilidad con otros tipos de dato</h2>
<p>Estos tipos de dato son compatibles con otros… en tanto los tipos que “ocultan” sean compatibles, por ejemplo, podemos concatenarlos, confiando en que todos tendrá una implementación del método <code>ToString</code>:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">string</span> <span class="n">holaMundo</span> <span class="p">=</span> <span class="n">cadena</span> <span class="p">+</span> <span class="err">“</span> <span class="err">“</span> <span class="p">+</span> <span class="n">cadena2</span><span class="p">+</span> <span class="err">“</span> <span class="err">“</span> <span class="p">+</span> <span class="n">entero</span><span class="p">;</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">holaMundo</span><span class="p">);</span> <span class="c1">// Imprime “Hola mundo 0”</span></code></pre></figure></p>

<h2 id=\"mutabilidad\">Mutabilidad</h2>
<p>Las variables <em>dinámicas</em> pueden cambiar completamente su contenido sin causar ningún problema, por ejemplo, podemos convertir <code>entero</code> en una instancia de <code>MainClass</code>:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="n">entero</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MainClass</span><span class="p">();</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">entero</span><span class="p">.</span><span class="n">GetType</span><span class="p">());</span> <span class="c1">// Imprime “Dynamics.MainClass”</span></code></pre></figure></p>

<h2 id=\"expandoobject-para-crear-tipos-dinmicos\">ExpandoObject para crear tipos dinámicos</h2>
<p>Nosotros también podemos crear tipos dinámicos haciendo uso de la clase <code>ExpandoObject</code> que es una clase “especial” que nos ofrece el framework. Es importante que lo declares como <code>dynamic</code> ya que de no hacerlo, el compilador lo tratará como fuertemente tipado</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">dynamic</span> <span class="n">expando</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ExpandoObject</span><span class="p">();</span>
<span class="c1">//ExpandoObject expando = new ExpandoObject(); // Esto lo convierte en fuertemente tipado</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">expando</span><span class="p">.</span><span class="n">GetType</span><span class="p">());&lt;</span><span class="n">br</span> <span class="p">/&gt;</span></code></pre></figure></p>

<p>A partir de ahí podemos asignar propiedades de acuerdo a nuestras necesidades:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="n">expando</span><span class="p">.</span><span class="n">Clase</span> <span class="p">=</span> <span class="n">entero</span><span class="p">;</span>
<span class="n">expando</span><span class="p">.</span><span class="n">HolaMundo</span> <span class="p">=</span> <span class="n">holaMundo</span><span class="p">;</span>
<span class="n">expando</span><span class="p">.</span><span class="n">expando</span> <span class="p">=</span> <span class="n">expando</span><span class="p">;</span></code></pre></figure></p>

<p>Al ser un tipo de dato en C# también se pueden usar como argumentos para un método o como tipos de retorno, por ejemplo, el siguiente:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">WorkWithDynamic</span><span class="p">(</span><span class="kt">dynamic</span> <span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">Clase</span> <span class="p">+</span> <span class="err">“</span> <span class="p">:</span> <span class="err">“</span> <span class="p">+</span> <span class="n">d</span><span class="p">.</span><span class="n">Clase</span><span class="p">.</span><span class="n">GetType</span><span class="p">());</span>
  <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">HolaMundo</span> <span class="p">+</span> <span class="err">“</span> <span class="p">:</span> <span class="err">“</span> <span class="p">+</span> <span class="n">d</span><span class="p">.</span><span class="n">HolaMundo</span><span class="p">.</span><span class="n">GetType</span><span class="p">());</span>
  <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">expando</span> <span class="p">+</span> <span class="err">“</span> <span class="p">:</span> <span class="err">“</span> <span class="p">+</span> <span class="n">d</span><span class="p">.</span><span class="n">expando</span><span class="p">.</span><span class="n">GetType</span><span class="p">());</span>
<span class="p">}</span></code></pre></figure></p>

<p>Entonces al llamar a <code>WorkWithDynamic(expando);</code>, obtendremos:</p>

<pre>
Dynamics.MainClass : Dynamics.MainClass
Hola mundo 0 : System.String
System.Dynamic.ExpandoObject : System.Dynamic.ExpandoObject
</pre>

<h2 id=\"uso\">Uso</h2>
<p>Como ya te imaginarás esto puede traer muchas ventajas pero a la vez muchos dolores de cabeza. En lo personal prefiero usar siempre tipado fuerte cuando desarrollo, pero si encuentro algunos casos en los que resulta muy útil:</p>

<h3 id=\"en-servicios-web\">En servicios web</h3>
<p>Hay ocasiones en las que crear una clase para consumir un servicio web puede ser excesivo, este es otro de los usos que le podemos dar a los tipos dinámicos. Por ejemplo, si consultamos la PokéAPI, y usamos Newtonsoft.Json, podemos usar un tipo dinámico para acceder a sus propiedades:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">dynamic</span> <span class="n">item</span> <span class="p">=</span> <span class="n">Newtonsoft</span><span class="p">.</span><span class="n">Json</span><span class="p">.</span><span class="n">JsonConvert</span><span class="p">.</span><span class="n">DeserializeObject</span><span class="p">(</span><span class="n">responseString</span><span class="p">);</span></code></pre></figure></p>

<p>Ahora en <code>item</code> tendremos una versión de la respuesta en <em>json</em> pero en .NET, solo que el compilador no sabe. No es sino hasta que se ejecuta que podemos acceder a las propiedades. Si te fijas bien, los nombres son idénticos a lo que regresa la API:</p>

<p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">“</span><span class="n">Names</span> <span class="k">for</span> <span class="err">“</span> <span class="p">+</span> <span class="n">item</span><span class="p">.</span><span class="n">name</span> <span class="p">+</span> <span class="err">“</span> <span class="p">(</span><span class="n">datatype</span> <span class="err">“</span> <span class="p">+</span> <span class="n">item</span><span class="p">.</span><span class="n">GetType</span><span class="p">()</span> <span class="p">+</span> <span class="err">“</span><span class="p">)</span><span class="err">”</span><span class="p">);</span>
<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">name</span> <span class="k">in</span> <span class="n">item</span><span class="p">.</span><span class="n">names</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">“\</span><span class="n">t</span><span class="err">”</span> <span class="p">+</span> <span class="n">name</span><span class="p">.</span><span class="n">language</span><span class="p">.</span><span class="n">name</span> <span class="p">+</span> <span class="err">“</span><span class="p">:</span> <span class="err">“</span> <span class="p">+</span> <span class="n">name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure></p>

<p>Obtendremos la siguiente respuesta:</p>

<pre>
Names for master-ball (datatype Newtonsoft.Json.Linq.JObject)
	en: Master Ball
	it: Master Ball
	es: Master Ball
	de: Meisterball
	fr: Master Ball
	ko: 마스터볼
	ja: マスターボール
</pre>

<h3 id=\"viewbag-en-aspnet-mvc\">ViewBag en ASP.NET MVC</h3>
<p>Otro fantástico uso de esta característica es la propiedad <code>ViewBag</code> de la clase <code>Controller</code> en MVC, con ella podemos pasar información a la vista sin necesidad de crear un modelo muy específico para cada una de las pantallas de nuestro sistema.</p>

<h3 id=\"comunicacin-con-otros-lenguajes\">Comunicación con otros lenguajes</h3>
<p>Cuando interactuamos desde C# con otros lenguajes como Python o JavaScript que involucran tipado débil y dinámico es necesario contar con un tipo similar dentro de C#, así que este es otro de sus usos.</p>

<h2 id=\"concluyendo\">Concluyendo</h2>
<p>Como conclusión puedo decir que yo siempre trato de evitarlos, ya que pueden transformar el código en un desastre total si se usan sin control. Además de que pueden llegar a resultar confusos de emplear cuando los ves en un código no documentado o que no hayas escrito tú mismo. Habiendo dicho esto, acepto que sí tienen usos específicos y muy bien identificados, además de que si sabes lo que estás haciendo te pueden ahorrar tiempo de desarrollo cuando programas.</p>
"
}