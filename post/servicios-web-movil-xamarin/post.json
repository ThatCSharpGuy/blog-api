{	
	"id" : "/post/servicios-web-movil-xamarin/",
	"tv" : false,
	"date": "2016-08-15 14:00:01 -0500",
	"title" : "Servicios web resistentes en aplicaciones móviles",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//xamarin-forms/resilient/featured.jpg",
	"tags" : ["Xamarin","XamarinForms","NuGetRecomendado"],
	"content": "<blockquote>\n  <p>Este es post es una traducción del post de <a href=\"https://twitter.com/RobGibbens\" target=\"_blank\">Rob Gibbens</a> llamado <a href=\"http://arteksoftware.com/resilient-network-services-with-xamarin/\" target=\"_blank\">Resilient network services with mobile Xamarin apps</a>, te invito a visitar el post y el resto de su blog.</p>\n</blockquote>\n\n<p>Durante mucha de la historia de la computación, nuestras computadoras y nuestras aplicaciones estuvieron en computadoras y no se movían. Nosotros contábamos con una fuente constante de energía, recursos y acceso a la red. Los desarrolladores no necesitaban pasar mucho tiempo previendo interrupciones o fallas con esos recursos. Inclusive era común tener aplicaciones que funcionaban localmente, en las que ni siquiera teníamos que pensar en la red.</p>\n\n<h2 id=\"vivimos-en-un-mundo-mvil\">Vivimos en un mundo móvil</h2>\n<p>Llevamos nuestros dispositivos con nosotros a donde sea. Los tenemos en casa, en el trabajo y durante las vacaciones. Están con nosotros sin importar si estamos conectados a internet wifi de 1 gigabit o en una red 4g. Tienen que funcionar mientras viajamos en túneles, trenes, automóviles, volando a 9000 metros de altura y cuando no tenemos conexión. Como desarrolladores debemos, no solo esperar esos requisitos, sino tomarlos en cuenta desde el desarrollo inicial y la arquitectura de nuestra aplicación móvil.</p>\n\n<h2 id=\"enfoque-actual\">Enfoque actual</h2>\n<p>Cuando empezamos a escribir nuestras apps con Xamarin, probablemente optamos por el enfoque sencillo de escribir el código que se conecta con la red nosotros mismos. Tal vez solamente usamos la librería <em>HttpClient</em> de Microsoft para hacer una llamada, y después <em>Json.net</em> para deserializar el resultado. O puede que nos luzcamos e incluyamos algunas otras librerías también. Puedes ver este enfoque en el post de Rob <a href=\"http://arteksoftware.com/end-to-end-mvvm-with-xamarin/\">End to End Mvvm with Xamarin</a> en donde muestra la implementación de un cliente para un servicio.</p>\n\n<pre class=\"csharp\">\nnamespace DtoToVM.Services  \n\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n    using System.Net.Http;\n    using System.Net.Http.Headers;\n    using System.Threading.Tasks;\n    using AutoMapper;\n    using Newtonsoft.Json;\n    using DtoToVM.Dtos;\n    using DtoToVM.Models;\n\n    public class TekConfClient\n    \n        public async Task&lt;List<conference>&gt; GetConferences ()\n        \n            IEnumerable<conferencedto> conferenceDtos = Enumerable.Empty<conferencedto>();\n            IEnumerable<conference> conferences = Enumerable.Empty<conference> ();\n\n            using (var httpClient = CreateClient ()) \n                var response = await httpClient.GetAsync (\"conferences\").ConfigureAwait(false);\n                if (response.IsSuccessStatusCode) \n                    var json = await response.Content.ReadAsStringAsync ().ConfigureAwait(false);\n                    if (!string.IsNullOrWhiteSpace (json)) \n                        conferenceDtos = await Task.Run (() =&gt; \n                            JsonConvert.DeserializeObject&lt;IEnumerable<conferencedto>&gt;(json)\n                        ).ConfigureAwait(false);\n\n                        conferences = await Task.Run(() =&gt; \n                            Mapper.Map&lt;IEnumerable<conference>&gt; (conferenceDtos)\n                        ).ConfigureAwait(false);\n                    \n                \n            \n\n            return conferences.ToList();\n        \n\n        private const string ApiBaseAddress = \"http://api.tekconf.com/v1/\";\n        private HttpClient CreateClient ()\n        \n            var httpClient = new HttpClient \n             \n                BaseAddress = new Uri(ApiBaseAddress)\n            ;\n\n            httpClient.DefaultRequestHeaders.Accept.Clear();\n            httpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n\n            return httpClient;\n        \n    \n\n  \n\nEste código funciona, pero no toma en cuenta ningún error en la red. Si la red estuviera caída, el servicio no respondiera u ocurriera alguna excepción, nuestra aplicación se cerraría. Evidentemente, esto no es lo óptimo.  \n  \n## Objetivos  \nLos objetivos de nuestras apps deben incluir, pero no limitarse, a los siguientes:  \n\n - Acceso sencillo a servicios *restful*\n - Rápida respuesta para nuestros usuarios  \n - Funcionar *offline*  \n - Manejo de errores\n\nComo objetivos secundarios:  \n\n- Desarrollo en poco tiempo  \n- Facilidad de mantenimiento  \n- Reusar librerías existentes  \n\nAtaquemos estos objetivos uno a la vez, y veremos cómo podemos mejorar nuestra aplicación conectada. Como casi siempre, estaré usando una la app de una conferencia basada en TekConf.\n\n&gt; El código de ejemplo está disponible en [el GitHub de Rob](https://github.com/RobGibbens/ResilientServices)  \n\n## Acceso fácil a servicios *restful*  \n\n### Refit  \n\n console titulo \nPM&gt; Install-Package Refit\n endconsole   \n\nLa primera cosa que vamos a necesitar es una forma para acceder a nuestros servicios. **Podríamos** usar HttpClient + Json.net como hicimos en el ejemplo anterior, sin embargo, podemos hacer esto más simple. De nuevo, uno de nuestros objetivos secundarios es reusar librerías existentes. La primera que usaremos es <a href=\"https://github.com/paulcbetts/refit\" target=\"_blank\" rel=\"nofollow\">Refit</a>. Refit nos permite definir una interfaz que describe la API que estamos llamando, y el framework se encarga de hacer la llamada al servicio y deserializar el objeto de regreso.  \n\nEn nuestro caso, la interfaz se verá más así:  \n\n<pre class=\"csharp\">\n[Headers(\"Accept: application/json\")]\npublic interface ITekConfApi  \n\n    [Get(\"/conferences\")]\n    Task&lt;List<conferencedto>&gt; GetConferences();\n\n    [Get(\"/conferences/slug\")]\n    Task<conferencedto> GetConference(string slug);\n\n  \n\nAquí estamos declarando que nuestra API retornará *json*, y que hay dos \"métodos\" (recursos) que podemos llamar. El primer método es una petición HTTP GET al *endpoint* `/conferencias`. El segundo método es también una petición HTTP GET, y pasa un argumento como parte de la url para obtener una sola conferencia.  \n\nUna vez que la interfaz ha sido definida, usarla es tan simple como esta:  \n\n<pre class=\"csharp\">\nvar tekconfApi = RestService.For<itekconfapi>(\"http://api.tekconf.com/v1\");\n\nvar conferences = await tekconfApi.GetConferences();\n\nvar codemash = await tekconfApi.GetConference(\"codemash-2016\");  \n     \n\n## Fast response for our users  \n\n### Akavache  \n\n console titulo \nPM&gt; Install-Package Akavache\n endconsole   \n\nAhora que tenemos una forma sencilla de acceder al servicio, nos podemos concentrar en la experiencia de usuario. El desempeño de una aplicación móvil, desde la perspectiva del usuario, es **crítica**. No importa en realidad si tu aplicación **ES** rápida mientras que el usuario **PIENSE** que lo es.  \n  \nLa mejor manera de acelerar una llamada a un servicio es no hacer esa llamada en primer lugar. Cargar la información almacenada localmente es exponencialmente más rápido que hacer una petición web, especialmente cuando estamos en un dispositivo móvil conectado en una red celular lenta. Aquí, podemos usar la técnica común de cachear los datos. Cuando la página termine de cargar y solicite datos para mostrar, nosotros inmediatamente queremos la información cacheada en nuestro dispositivo y mostrarla. Desde la perspectiva del usuario, la página se muestra inmediatamente. Mientras esto ocurre, nosotros consultamos al servicio remoto, obtenemos la nueva información y la almacenamos en cache. Dado que el usuario no necesita esperar a que la consulta al servicio concluya, podemos ejecutarla a nuestra discreción y conseguirnos un poco más de tiempo para procesarla.  \n\nMientras que pudimos haber escrito toda la lógica de cacheo nosotros mismos, en su lugar agregamos un paquete de NuGet llamado <a href=\"https://github.com/akavache/Akavache\" target=\"_blank\" rel=\"nofollow\">Akavache</a>. Del sitio de Akavache:  \n\n &gt; Akavache es un repositorio de *clave-valor* asíncrono y persistente (i. e. escribe a disco) creado para escribir aplicaciones de escritorio y móviles en C#, basado en SQLite3. Akavache es ideal para almacenar tanto información importante (i. e. configuración de usuarios) así como información local que debe expirar.  \n\n<pre class=\"csharp\">\npublic async Task&lt;List<conferencedto>&gt; GetConferences()  \n\n    var cache = BlobCache.LocalMachine;\n    var cachedConferences = cache.GetAndFetchLatest(\"conferences\", GetRemoteConferencesAsync,\n        offset =&gt;\n        \n            TimeSpan elapsed = DateTimeOffset.Now - offset;\n            return elapsed &gt; new TimeSpan(hours: 0, minutes: 30, seconds: 0);\n        );\n\n    var conferences = await cachedConferences.FirstOrDefaultAsync();\n    return conferences;\n\n   \n\nPodemos usar el método `GetAndFetchLatest` de Akavache para devolver inmediatamente las conferencias almacenadas, si hay alguna. Al mismo tiempo, preparamos una petición a nuestro método `GetRemoteConferencesAsync`, quién hará la llamada al servicio remoto si el periodo de tiempo indicado ha transcurrido.  \n\nMatthew Soucop tiene un muy buen <a href=\"http://codemilltech.com/akavache-is-aka-awesome/\" target=\"_blank\" rel=\"nofollow\">post de Akavache</a>. \n\n### ModernHttpClient  \n\n console titulo \nPM&gt; Install-Package ModernHttpClient\n endconsole   \n\nA pesar de que nos gustaría siempre obtener los datos de la cache, sabemos que en algún momento tendremos que llamar al servicio remoto. Sin embargo, en la *Xamarin stack*, nos encontramos con un problema, por default Mono (y por tanto Xamarin) usa la *Mono networking stack*. Funciona, pero Apple y Google hay pasado un montón de tiempo optimizando su *stack* de redes en sus respectivas plataformas, y cando usamos `HttpClient` estamos pasando par algo dichas optimizaciones por completo. Podemos arreglar esto añadiendo <a href=\"https://github.com/paulcbetts/ModernHttpClient\" target=\"_blank\" rel=\"nofollow\">ModernHttpClient</a>.  \n  \n &gt; Esta librería lleva las librerías de red más recientes a Xamarin a través de un tipo `HttpClient` modificado. Escribe tu aplicación usando `System.Net.Http` pero coloca esta librería e irá drásticamente más rápido.  \n\n<pre class=\"csharp\">\nvar client = new HttpClient(new NativeMessageHandler())  \n\n    BaseAddress = new Uri(apiBaseAddress)\n;\n\nreturn RestService.For<itekconfapi>(client);\n   \n\nAl pasar `NativeMessageHandler` al constructir de `HttpClient`, automáticamente estamos usando el *stack* apropiado en cada plataforma.  \n  \n### Fusillade  \n\n console titulo \nPM&gt; Install-Package Fusillade\n endconsole   \n\nDesde la perspectiva del usuario, no todas las peticiones al servicio son iguales. Peticiones que son iniciadas por una acción del usuario deben tener una prioridad que cualquier otra que la app haga por su cuenta. Recuerda que nuestro objetivo es que el usuario **sienta** que la app responde rápido.  \n  \n<a href=\"https://github.com/paulcbetts/Fusillade\" target=\"_blank\" rel=\"nofollow\">Fusillade</a> es otro paquete de NuGetque vamos a usar para contar con:  \n\n - Evitar duplicar peticiones automáticas\n - Limitar peticiones\n - Priorizar peticiones \n - Contar con peticiones especulativas  \n\n<pre class=\"csharp\">\npublic class ApiService : IApiService  \n\n    public const string ApiBaseAddress = \"http://api.tekconf.com/v1\";\n\n    public ApiService(string apiBaseAddress = null)\n    \n        Func&lt;HttpMessageHandler, ITekConfApi&gt; createClient = messageHandler =&gt;\n        \n            var client = new HttpClient(messageHandler)\n            \n                BaseAddress = new Uri(apiBaseAddress ?? ApiBaseAddress)\n            ;\n\n            return RestService.For<itekconfapi>(client);\n        ;\n\n        _background = new Lazy<itekconfapi>(() =&gt; createClient(\n            new RateLimitedHttpMessageHandler(new NativeMessageHandler(), Priority.Background)));\n\n        _userInitiated = new Lazy<itekconfapi>(() =&gt; createClient(\n            new RateLimitedHttpMessageHandler(new NativeMessageHandler(), Priority.UserInitiated)));\n\n        _speculative = new Lazy<itekconfapi>(() =&gt; createClient(\n            new RateLimitedHttpMessageHandler(new NativeMessageHandler(), Priority.Speculative)));\n    \n\n    private readonly Lazy<itekconfapi> _background;\n    private readonly Lazy<itekconfapi> _userInitiated;\n    private readonly Lazy<itekconfapi> _speculative;\n\n    public ITekConfApi Background\n    \n        get  return _background.Value; \n    \n\n    public ITekConfApi UserInitiated\n    \n        get  return _userInitiated.Value; \n    \n\n    public ITekConfApi Speculative\n    \n        get  return _speculative.Value; \n    \n\n  \n\nAhora, en lugar de solamente usar `HttpClient`, tenemos una clase `ApiService` que tendrá tres instancias de `Refit`, para peticiones iniciadas por el usuario (*UserInitiated*), en segundo plano (*Background*) y especulativas (*Speculative*).  \n  \nCuando la página carga por primera vez, nosotros automáticamente trataremos de obtener información sobre las conferencias. Dado que el usuario no inició esta petición, podemos enviar esta petición a segundo plano.  \n\n<pre class=\"csharp\">\nvar conferences = await _conferencesService  \n                        .GetConferences(Priority.Background)\n                        .ConfigureAwait(false);\n</pre>  \n\nSi el usuario selecciona el botón de actualizar, entonces tendríamos que correr esta petición con diferente prioridad.  \n\n<pre class=\"csharp\">\nvar conferences = await _conferencesService  \n                        .GetConferences(Priority.UserInitiated)\n                        .ConfigureAwait(false);\n</pre>  \n\nCuando las conferencias *regresan* del servicio, podríamos asumir que el usuario seleccionará una de ellas para ver sus detalles. Puesto que solo estamos especulando que esto podría ocurrir, podemos preparar una petición para obtener los detalles de las conferencias con prioridad especulativa:  \n\n<pre class=\"csharp\">\nforeach (var slug in conferences.Select(x =&gt; x.Slug))  \n\n    _conferencesService.GetConference(Priority.Speculative, slug);\n\n</pre>  \n\n&gt; Una nota de Paul Betts: \"Si usas la prioridad especulativa, tienes que llamar a ResetLimit en tu app móvil para reestablecer el límite de descarga de 5MB cada que navegues entre páginas (esta no es una regla estricta, pero es una buena idea - básicamente cuando sepas que el usuario está \"iniciando una nueva sesión\"). La prioridad especulativa es definitivamente algo que la mayoría de apps no necesitan - imagínate una app de Reddit en donde intentes descargar cada elemento en la página, pero en realidad no quieres hacer eso, tal vez solo intentes adivinar qué es lo que el usuario quiere ver. Entonces el desarrollador puede ser flojo y decir \"Descarga todo, *yolo*\" y Fusillade las eliminará basándose en el contenido de cada una.  \n  \n## Funcionamiento *offline*  \n\nContrario a las aplicaciones de escritorio, nuestras aplicaciones móviles deben ser alguna funcionalidad mientras están desconectadas de la red. La peor cosa que podríamos hacer es que falle cuando tratamos de hacer una petición. Lo mejor que podríamos hacer es que siga funcionando para que el usuario no se de cuenta de que no estaba conectado a internet.  \n\n### Connectivity  \n\n console titulo \nPM&gt; Install-Package Xam.Plugin.Connectivity\n endconsole   \n\nSi queremos estar seguros de que no causaremos un excepción al hacer una petición cuando no hay internet, entonces necesitamos una manera de conocer el estado de la conexión. Cada plataforma tiene su manera de hacer esta validación, pero nosotros queremos hacer uso de ella de una manera *cross-platform* desde nuestra PCL.  \n  \n<a href=\"https://github.com/jamesmontemagno/Xamarin.Plugins/tree/master/Connectivity\" target=\"_blank\" rel=\"nofollow\">Connectivity</a> es un plugin para Xamarin que nos permite hacer justamente eso.  \n  \n&gt; Simple plugin multiplataforma para revisar el estado de la conexión en un dispositivo móvil, obtener el tipo de conexión, el ancho de banda y más.  \n  \nAntes de hacer una petición de red, podemos revisar si el dispositivo está conectado.  \n  \n<pre class=\"csharp\">\nif (CrossConnectivity.Current.IsConnected)  \n\n    conferences = await _apiService.Background.GetConferences();\n\nreturn conferences;\n</pre>  \n\n### Akavache  \nYa vimos cómo Akavache nos permite continuar trabajando mientras estamos offline al cachear los resultados de consultas localmente. Al combinar Akavache y las llamadas especulativas de Fusillade, podemos cachear proactivamente tantos datos como podemos mientras permanece conectado. Cuando no haya red, la app continuará funcionando en modo de solo lectura.  \n  \n## Manejo de errores  \nEn un mundo perfecto, nuestro código funcionaría correctamente todo el tiempo. Este no es un mundo perfecto. Las redes se caen. Los servicios lanzan errores. El código falla. Algunos de los errores son permanentes, pero un gran número son errores esporádicos. Las peticiones por red son poco confiables y las APIs tienen errores esporádicos por una amplia gama de razones.  \n\n## Polly  \n \n console titulo \nPM&gt; Install-Package Polly\n endconsole   \n\n<a href=\"https://github.com/michael-wolfenden/Polly\" target=\"_blank\" rel=\"nofollow\">Polly</a> es una de las librerías más útiles que he usado en un tiempo. De su sitio web:  \n\n&gt; Polly es una librería para .NET 3.5/4.0/4.5/PCL que permite a los desarrolladores expresar políticas de manejo de errores como Reintentar (*Retry*), Reintentar para siempre (*Retry Forever*), espera y reintenta (*Wait and Retry*) o corta circuito (*Circuit Breaker*) de una manera fluida.  \n\nPolly nos permite manejar fácilmente este tipo de errores de manera consistente y coherente. En este ejemplo, trataremos de conectarnos al servicio 5 veces, con una espera que incrementa exponencialmente 2, 4, 8, 16, 32 segundos entre intentos. Esto debería darle tiempo al dispositivo de reestablecer la conexión y continuar con las peticiones.  \n\n<pre class=\"csharp\">\nconferences = await Policy  \n      .Handle<webexception>()\n      .WaitAndRetry\n      (\n        retryCount:5, \n        sleepDurationProvider: retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))\n      )\n      .ExecuteAsync(async () =&gt; await getConferencesTask);\n  \n\n### AsyncErrorHandler  \n \n console titulo \nPM&gt; Install-Package AsyncErrorHandler.Fody  \n endconsole   \n\nInclusive con todo el cacheo, los reintentos y planeación que hemos puesto en el código, en algún momento fallará. Queremos que cuando eso suceda, lo manejemos de buena manera.  \n  \nEn nuestras aplicaciones móviles, es imperativo que usemos `async`/`await` tanto como podamos para asegurarnos de no bloquear el hilo de la UI mientras hacemos cosas como peticiones de red. Manejar las excepciones en métodos asíncronos puede ser complicado.  \n  \nAgregar <a href=\"https://github.com/Fody/AsyncErrorHandler\" target=\"_blank\" rel=\"nofollow\">AsyncErrorHandler</a> nos permite manejar esas excepciones de modo global, así nos aseguramos de que no terminarán nuestra app.  \n\n## Más  \nPodríamos ir un paso más allá en la arquitectura de nuestro código para manejar las peticiones de red. Podríamos registrar cada llamada como una <a href=\"https://developer.xamarin.com/guides/ios/application_fundamentals/backgrounding/part_3_ios_backgrounding_techniques/ios_backgrounding_with_tasks/\" target=\"_blank\" rel=\"nofollow\">BackgroundTask</a> en iOS, o como un <a href=\"http://developer.xamarin.com/guides/android/application_fundamentals/services/\" target=\"_blank\" rel=\"nofollow\">Service</a> en Android para darle a cada una la oportunidad de terminar aún cuando la app es enviada a segundo plano.  \n\nPodríamos implementar una cola, o laguna forma de sincronización de datos que nos permitirían actualizar los datos mientras estamos offline y sincronizarlos con el servidor cuando una conexión esté disponible. Qué tan lejos quieres llegar, depende de ti.  \n\nFundamentalmente, el desarrollo móvil introduce algunas complejidades por las que no habíamos tenido que preocuparnos en el desarrollo para escritorio. Una aplicación móvil que no usa servicios externos es una isla con usabilidad limitada. Una aplicación móvil que usa servicios externos, pero falla cuando trata de acceder a ellos es inútil. Al usar algunas librerías realmente geniales, podemos asegurarnos de que nuestras aplicaciones darán a nuestros usuarios la mejor experiencia.  \n \n## Agradecimientos  \nPara hacer que todo esto funcione, aproveché el gran trabajo de otros desarrolladores. *Sentado sobre los hombros de gigantes*.  \n\nGracias a <a href=\"https://twitter.com/jamesmontemagno\" target=\"_blank\" rel=\"nofollow\">James Montemagno</a> (<a href=\"http://motzcod.es/\" target=\"_blank\">Blog</a>, <a href=\"https://github.com/jamesmontemagno\" target=\"_blank\">GitHub</a>) por el plugin <a href=\"https://github.com/jamesmontemagno/Xamarin.Plugins/tree/master/Connectivity\" target=\"_blank\">Connectivity</a>.\n\nGracias a Michael Wolfenden (<a href=\"https://github.com/michael-wolfenden/\" target=\"_blank\">GitHub</a>) por el fantástico framework <a href=\"https://github.com/michael-wolfenden/Polly\" target=\"_blank\">Polly</a>.  \n\nGracias a <a href=\"https://twitter.com/SimonCropp\" target=\"_blank\">Simon Cropp</a> (<a href=\"https://github.com/SimonCropp\" target=\"_blank\">GitHub</a>) por <a href=\"https://github.com/Fody/\" target=\"_blank\">Fody</a> y <a href=\"https://github.com/Fody/AsyncErrorHandler\" target=\"_blank\">AsyncErrorHandler</a>.  \n\nGracias a <a href=\"https://twitter.com/GeoffreyHuntley\" target=\"_blank\">Geoffrey Huntley</a> (<a href=\"https://www.ghuntley.com/\" target=\"_blank\">Blog</a>, <a href=\"https://github.com/ghuntley\" target=\"_blank\">GitHub</a>) por el código y la inspiración para la clase <a href=\"https://gist.github.com/ghuntley/ed2eb754a47e2cd3bc90\" target=\"_blank\">ApiService con Fusillade y Refit</a>. \n\nMuchas, muchas gracias a <a href=\"https://twitter.com/paulcbetts\" target=\"_blank\">Paul Betts</a> (<a href=\"http://log.paulbetts.org/\" target=\"_blank\">Blog</a>, <a href=\"https://github.com/paulcbetts\" target=\"_blank\">GitHub</a>) por sus trenemdas contribuciones a la comunidad *open source* de Xamarin, incluyendo <a href=\"https://github.com/paulcbetts/refit\" target=\"_blank\">Refit</a>, <a href=\"https://github.com/akavache/Akavache\" target=\"_blank\">Akavache</a>, <a href=\"https://github.com/paulcbetts/Fusillade\" target=\"_blank\">Fusillade</a>, y <a href=\"https://github.com/paulcbetts/ModernHttpClient\" target=\"_blank\">ModernHttpClient</a>.  \n  \n## Código fuente  \nPuedes encontrar un ejemplo completo en el <a href=\"https://github.com/RobGibbens/ResilientServices\" target=\"_blank\">GitHub de Rob</a>.\n</webexception></pre></itekconfapi></itekconfapi></itekconfapi></itekconfapi></itekconfapi></itekconfapi></itekconfapi></pre></itekconfapi></pre></conferencedto></pre></itekconfapi></pre></conferencedto></conferencedto></pre></conference></conferencedto></conference></conference></conferencedto></conferencedto></conference></pre>\n"
}