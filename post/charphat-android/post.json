{	
	"id" : "/post/charphat-android/",
	"tv" : false,
	"date": "2015-09-10 12:00:00 -0500",
	"title" : "CharpHat para Android",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimagesfeatured.png",
	"tags" : ["Xamarin","XamarinForms"],
	  
	"content": '"<div class=\"pure-g\">\n\t<div class=\"pure-u-24-24\">\n\t\t<a href=\"https://play.google.com/store/apps/details?id=com.thatcsharpguy.charphat\" target=\"_blank\">\n\t\t\t<img alt=\"Get it on Google Play\" src=\"/postimages/charphat-android/header.png\" />\n\t\t</a>\n\t</div>\n</div>  \n<br />\nCon CharpHat toma una foto y muéstrale al mundo que te gusta C#, CharpHat te permite colocarte un birrete con mucho estilo.  \n  \n<br />\nHa pasado ya un buen rato desde que tuve el deseo de hacer esta aplicación para móvil, y es que la idea me llegó desde que comencé en el mundo de Xamarin. Pero al tener muy poca experiencia siempre había retrasado la idea. En fin, en este post te voy a explicar cómo es que hice la app con Xamarin.Forms y ayuda de los `custom renderers`.  \n  \n### El proyecto  \nPara comenzar, el proyecto es una aplicación de Xamarin.Forms utilizando un proyecto compartido que cree desde Visual Studio. Una vez creado, deja cuatro proyectos en la solución, esta vez me enfocaré solamente en el proyecto de Android ya que es el que ya está desarrollado por completo. Primero, les muestro el proyecto compartido:\n\n<img src=\"/postimages/charphat-android/shared-capture.png\" />\n\nPara darle un poco de organización dividí el código en carpetas, están:\n<ul>\n\t\t\n\t<li><code>Controls</code>, contiene las abstracciones de controles que se deben implementar específicamente para cada plataforma, como es el caso de <code>StickerableImage</code>, que veremos más adelante.</li>\n\t\t\t\n\t<li><code>Helpers</code>, contiene recursos que se usan en toda la aplicación, como colores o estilos.</li>\n\t\t\t\n\t<li><code>Pages</code>, contiene las páginas que se usan a lo largo de toda la app, incluyéndo <code>CameraPage</code> que debe ser implementada por nosotros para cada plataforma, que veremos más adelante.</li>\n\t\t\t\n\t<li><code>Services</code>, contiene las abstracciones de caracterísitcas que también deben ser implementadas para cada plataforma.</li>\n\t\t\t\n\t<li><code>ViewModels</code>, contiene las clases que definen la lógica de la aplicación.</li>\n\n</ul>  \n  \n### CameraPage  \nLa funcionalidad de la aplicación depende completamente de la posibilidad de tomar fotografías para después poderlas modificar, aquí es donde la cosa se pone un poco seria, puesto que dentro de todas las bondades que nos ofrece Xamarin.Forms, no está la posibilidad de tomar fotografías con código 100% compartido. Por ello se tiene que escribir código para cada plataforma, en este caso usando Xamarin.Android, es decir, **sigue siendo código en C#**.  \n\nLa implementación de la cámara es completamente una implementación basada en la que hizo Pierce Boggan en su aplicación Moments. Para usar un `custom renderer`  básicamente lo que se requiere es:  \n<br />\n**Declarar la abastracción**, en este caso es dentro de la carpeta `Pages` del proyecto compartido, en este caso `BasePage` deriva de `ContentPage`, esto es importante ya que es una manera de indicar qué es lo que vamos a implementar en la plataforma.\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npublic</span> <span class="k">class</span> <span class="nc">CameraPage</span> <span class="p">:</span> <span class="n">BasePage</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">tpublic</span> <span class="n">CameraPage</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span><span class="err">\</span><span class="n">n</span><span class="p">}</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n**Implementar individualmente**, para realizar esto se debe crear una clase dentro del proyecto para el cual queremos implementar el control dentro de la plataforma, a notar que CameraPage deriva de PageRenderer (e implementa ISurfaceTextureListener, pero ese ya es otro tema):\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npublic</span> <span class="k">class</span> <span class="nc">CameraPage</span> <span class="p">:</span> <span class="n">PageRenderer</span><span class="p">,</span> <span class="n">TextureView</span><span class="p">.</span><span class="n">ISurfaceTextureListener</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \nDentro de esta clase, debemos sobreescribir el método `OnElementChanged`, ya que es donde se debe modificar el el control de acuerdo a nuestras necesidades, para este caso, en ese método de carga un `layout` que contiene la definición de la página en XML para Android y se añaden los manejadores de eventos. Para terminar, debemos **indicar a Xamarin.Forms** que nuestra clase derivada de `PageRenderer` debe ser usada para renderizar la página de la cámara en el dispositivo, esto se hace mediante el atributo `ExportRenderer`:\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">n</span><span class="p">[</span><span class="n">assembly</span><span class="p">:</span> <span class="n">ExportRenderer</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">CharpHat</span><span class="p">.</span><span class="n">Pages</span><span class="p">.</span><span class="n">CameraPage</span><span class="p">),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">CharpHat</span><span class="p">.</span><span class="n">Droid</span><span class="p">.</span><span class="n">Pages</span><span class="p">.</span><span class="n">CameraPage</span><span class="p">))]</span><span class="err">\</span><span class="n">n</span></code></pre></figure>    \nLa implementación de la cámara usa las APIs viejas de Android, y no es para nada distinto de lo que se haría para implementar una funcionalidad similar usando Java, pero en este caso estarías usando fabuloso C#.  \n  \n### StickerableImage  \nOtra de las características que tuvo que ser implementada de manera individual para cada plataforma fue la capacidad de añadir y manipular \"stickers\" usando nuestros dedos. Para ello, se deben seguir los pasos anteriores, es decir:  \n<br /> \n**Declarar la abstracción**\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npublic</span> <span class="k">class</span> <span class="nc">StickerableImage</span> <span class="p">:</span> <span class="n">View</span><span class="err">\</span><span class="n">n</span></code></pre></figure>\nEn este caso, añadí dos propiedades a esta clase que permitirán manipular el tamaño (`ScaleFactor`) y el ángulo (`RotationFactor`) en el código del proyecto compartido, además las declaré como propiedades \"bindeables\", para poderlas usar desde XAML o con los <code>ViewModels</code>.\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nBindableProperty</span> <span class="n">ScaleFactorProperty</span><span class="p">;</span><span class="err">\</span><span class="n">nBindableProperty</span> <span class="n">RotationFactorProperty</span><span class="p">;</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n**Implementar individualmente**, para este caso, no se usa un renderizador conocido (como podría ser PageRenderer o ButtonRenderer), sino que se utiliza ViewRenderer en el que debemos especificar: el tipo del control en Xamarin.Forms y el tipo de control en la plataforma nativa (en este caso es Xamarin.Android) \n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npublic</span> <span class="k">class</span> <span class="nc">StickerableImageRenderer</span> <span class="p">:</span> <span class="n">ViewRenderer</span><span class="p">&lt;</span><span class="n">StickerableImage</span><span class="p">,</span> <span class="n">StickerView</span><span class="p">&gt;</span><span class="err">\</span><span class="n">n</span></code></pre></figure>\nCon el código anterior, lo que estamos diciendo es algo como: *Cuando sea Android, reemplaza StickerableImage por StickerView*, donde <code>StickerView</code> es un control del tipo <code>Android.Views.View</code>. Una vez hecho esto, únicamente resta indicarle a Forms que queremos usar ese Renderer para ese tipo de control, para ello usamos fuera del `namespace`:\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">n</span><span class="p">[</span><span class="n">assembly</span><span class="p">:</span> <span class="n">ExportRenderer</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">CharpHat</span><span class="p">.</span><span class="n">Controls</span><span class="p">.</span><span class="n">StickerableImage</span><span class="p">),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">CharpHat</span><span class="p">.</span><span class="n">Droid</span><span class="p">.</span><span class="n">Controls</span><span class="p">.</span><span class="n">StickerableImageRenderer</span><span class="p">))]</span><span class="err">\</span><span class="n">n</span></code></pre></figure> \n  \n#### StickerView  \nEs un `View` que lo que hace es estar al pendiente de cuando el usuario toca la pantalla y dibuja en ese punto el peculiar birrete de C#, también permite modificar el tamaño y el ángulo de este, para poder acomodarlo de acuerdo a lo que indique el usuario.\n  \n### IPictureManager\nAlmacenar imagenes en el dispositivo también es algo que requiere de código específico para cada plataforma, es por eso que cree esta interfaz que será implementada independientemente y hará uso del Servicio de Dependencias de Xamarin.Forms. La interfaz expone un único método `SavePictureToDisk`, que toma los bytes de la imagen, el nombre que se le asignará y la carpeta en que se debe guardar. De nuevo, seguimos los pasos de siempre:  \n\n**Declarar la abstracción**\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npublic</span> <span class="k">interface</span> <span class="n">IPictureManager</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">tstring</span> <span class="n">SavePictureToDisk</span> <span class="p">(</span><span class="kt">string</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">string</span> <span class="n">folder</span><span class="p">,</span> <span class="kt">byte</span><span class="p">[]</span> <span class="n">imageData</span><span class="p">);</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">t</span><span class="c1">// ...\n</span></code></pre></figure>\n**Implementar individualmente**\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npublic</span> <span class="k">class</span> <span class="nc">PictureManager</span> <span class="p">:</span> <span class="n">IPictureManager</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">tpublic</span> <span class="kt">string</span> <span class="n">SavePictureToDisk</span><span class="p">(</span><span class="kt">string</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">string</span> <span class="n">folder</span><span class="p">,</span> <span class="kt">byte</span><span class="p">[]</span> <span class="n">imageData</span><span class="p">)</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">t</span><span class="p">{</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">t</span><span class="err">\</span><span class="n">tvar</span> <span class="n">dir</span> <span class="p">=</span> <span class="n">Android</span><span class="p">.</span><span class="n">OS</span><span class="p">.</span><span class="n">Environment</span><span class="p">.</span><span class="n">GetExternalStoragePublicDirectory</span><span class="p">(</span><span class="n">Android</span><span class="p">.</span><span class="n">OS</span><span class="p">.</span><span class="n">Environment</span><span class="p">.</span><span class="n">DirectoryPictures</span><span class="p">);</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">t</span><span class="err">\</span><span class="n">tstring</span> <span class="n">picsFolder</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">String</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">t</span><span class="err">\</span><span class="n">t</span><span class="c1">// ...\n</span></code></pre></figure>\nPara usar el servicio de dependencias de Xamarin.Forms, debemos utilizar `DependencyAttribute` fuera del nombre de espacio en nuestra clase, como en la siguientes líneas:\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">n</span><span class="p">[</span><span class="n">assembly</span><span class="p">:</span> <span class="n">Xamarin</span><span class="p">.</span><span class="n">Forms</span><span class="p">.</span><span class="n">Dependency</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">CharpHat</span><span class="p">.</span><span class="n">Droid</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="n">PictureManager</span><span class="p">))]</span><span class="err">\</span><span class="n">nnamespace</span> <span class="n">CharpHat</span><span class="p">.</span><span class="n">Droid</span><span class="p">.</span><span class="n">Services</span><span class="err">\</span><span class="n">n</span></code></pre></figure>\n  \n### IScreenshotService\nPara el caso de `IScreenshotService` se realizan pasos similares que para `IPictureManager`. La implementación de `IScreenshotService` permite capturar la pantalla que está viendo el usuario, úitil para cuando el birrete está en su posición y se quiere guardar esa imagen.  \n\n### Conclusiones  \nComo podemos ver, hay ciertas veces en que no nos podemos librar de escribir código para cada plataforma, sin embargo la gran mayoría de nuestra aplicación permanece compartida entre las tres plataformas. Son las peculiaridades como el acceso a la cámara del dispositivo y la captura de pantalla las que requieren de código C# aparte.  \n\n#### Código compartido\nAl momento de la publicación de este post, más de la mitad del código es compartido por la aplicación de Android, sin embargo estoy buscando maneras de reducir el porcentaje de código específico para cada plataforma.  \n<br />\nPor último, no te olvides de <a href=\"https://play.google.com/store/apps/details?id=com.thatcsharpguy.charphat\" target=\"_blank\">descargar la aplicación</a> en Google Play o <a href=\"http://github.com/fferegrino/CharpHat/\">descargar el código fuente</a> en GitHub. Y espera pronto la versión para iOS y Windows Phone.\n\n\n\n \n"'   
}