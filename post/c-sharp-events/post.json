{	
	"id" : "/post/c-sharp-events/",
	"tv" : false,
	"date": "2016-08-22 14:00:01 -0500",
	"title" : "Events en C#",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//aprende-c-sharp/events.png",
	"tags" : ["AprendeCSharp"],
	  
	"content": '"¿Recuerdas que en los primeros posts de este blog hablé sobre <a href=\"../delegados-en-c-sharp\">delegados en C#</a>? pues bien, hoy toca hablar de un pariente muy cercano a ellos: Los eventos o `events`.  \n  \nEl paso de mensajes entre objetos es uno de los pilares de la programación orientada a objetos, y un evento no es más que eso: un mensaje que se envía de un objeto (el emisor) a otros (los receptores) cada vez que se cumple cierta condición o un cambio ocurre en él.\n\nLos receptores, por su cuenta, se suscriben a los eventos para ser informados cada vez que son *lanzados* desde el emisor y poder así manejarlos adecuadamente.\n\n### Declarando eventos en el emisor\n\nPara el código de ejemplo de este post cree una clase llamada `Generator`, que \"genera\" números aleatorios cada 0.5 segundos. Supongamos que queremos que la clase nos \"avise\" a través de un evento cada vez que esté a punto de generar un nuevo número. En C# declaramos eventos de la siguiente manera:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npublic</span> <span class="k">delegate</span> <span class="k">void</span> <span class="n">GeneratingNumberEventHandler</span><span class="p">(</span><span class="n">Generator</span> <span class="n">sender</span><span class="p">);</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">npublic</span> <span class="k">event</span> <span class="n">GeneratingNumberEventHandler</span> <span class="n">GeneratingNumber</span><span class="p">;</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\nEn la primera línea de código puedes observar a un viejo conocido, los delegados, en este caso es un delegado que regresa valor alguno y recibe una instancia de `Generator` como parámetro. Este delegado será el molde para nuestros manejadores de evento.\n\nEn la segunda línea se realiza la declaración del evento, la cual se compone de:  \n  \n - El modificador de acceso (`public`, `internal`, ...).\n - La palabra reservada `event`.\n - El tipo del delegado asociado con ese evento.  \n - El nombre del evento.\n\n### Manejando los eventos en el receptor  \n\nPara que un receptor esté al pendiente de algún evento en un objeto debe suscribirse a él. La suscripción a los eventos se ejecuta con el operador `+=` más el **manejador de eventos**, que no es más que un método que cumple con los requisitos del evento:  \n\nPor ejemplo, tenemos el siguiente método, que tiene `void` como valor de retorno y `Generator` como parámetro (y que por tanto puede ser usado como manjador para el evento declarado arriba):\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nstatic</span> <span class="k">void</span> <span class="n">G_GeneratingNumber</span><span class="p">(</span><span class="n">Generator</span> <span class="n">sender</span><span class="p">)</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">sender</span><span class="p">.</span><span class="n">Name</span> <span class="p">+</span> <span class="err">\</span><span class="s">&quot; generará un número\&quot;);\n}\n</span></code></pre></figure>  \n\nPara asignarlo como manejador, debemos usar el operador `+=`:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">ng</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Generator</span><span class="p">(</span><span class="n">name</span><span class="p">);</span><span class="err">\</span><span class="n">ng</span><span class="p">.</span><span class="n">GeneratingNumber</span> <span class="p">+=</span> <span class="n">G_GeneratingNumber</span><span class="p">;</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\n### Invocando los eventos en el emisor\n\nAsí pues, dentro de nuestro método que genera los números podemos hacer algo como lo siguiente, justamente antes de que se genere un número: \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nif</span> <span class="p">(</span><span class="n">GeneratingNumber</span><span class="p">!=</span> <span class="k">null</span><span class="p">)</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="n">GeneratingNumber</span><span class="p">(</span><span class="k">this</span><span class="p">);</span><span class="err">\</span><span class="n">n</span><span class="p">}</span><span class="err">\</span><span class="n">nvar</span> <span class="n">generated</span> <span class="p">=</span> <span class="n">r</span><span class="p">.</span><span class="n">Next</span><span class="p">();</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\nEs importante que antes de invocar el evento compruebes que existe al menos un receptor (`GeneratingNumber!= null`) ya que de otro modo obtendrás una espantosa `NullReferenceException`.\n\nTras lo cual, si ejecutas el programa podrás ver algo como esto:  \n\n<pre>\nLocotrón generará un número  \nLocotrón generará un número  \nLocotrón generará un número  \n</pre>\n\n### Auxiliares (EventHandler y  y EventHandler<T>)  \n\nDe nueva cuenta, y al igual que con <a href=\"../func-y-action-en-c-sharp\">Func y Action</a>, C# nos ofrece dos tipos auxiliares de delegado: `EventHandler` y `EventHandler<T>`, esto para no tener que definir delegados para cada evento en nuestro código. \n\n#### Declaración  \n\nPara declararlo:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npublic</span> <span class="k">event</span> <span class="n">EventHandler</span> <span class="n">GeneratingNumber1</span><span class="p">;</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\n#### Manejo  \nEl delegado `EventHandler` indica que el método devuelve `void` y recibe una instancia de `object` y una de `EventArgs` como parámetros... sí, un poco complicado, pero tiene sus razones. De nuevo, mira a la forma de asignar un manejador, en esta ocasión estamos <a href=\"../lambdas-en-c-sharp\">usando una lambda</a>:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">ng</span><span class="p">.</span><span class="n">GeneratingNumber1</span> <span class="p">+=</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="kt">var</span> <span class="n">generador</span> <span class="p">=</span> <span class="n">sender</span> <span class="k">as</span> <span class="n">Generator</span><span class="p">;</span><span class="err">\</span><span class="n">n</span>    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">generador</span><span class="p">.</span><span class="n">Name</span> <span class="p">+</span> <span class="err">\</span><span class="s">&quot; generará un número (EventHandler)\&quot;);\n};\n</span></code></pre></figure>  \n\nComúnmente el parámetro `sender` es una referencia al objeto que lanzó el evento, es por eso que se puede hacer el *cast* a `Generator` sin problema. \n\n#### Invocación  \nLa invocación no varía mucho, igual hay que checar que no sea nulo antes de llamar al `event`, solo que esta vez es necesario pasar dos argumentos:  \n\n - `this` que hace referencia a quién genera el evento, y\n - `EventArgs.Empty` \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nif</span> <span class="p">(</span><span class="n">GeneratingNumber1</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="n">GeneratingNumber1</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">EventArgs</span><span class="p">.</span><span class="n">Empty</span><span class="p">);</span><span class="err">\</span><span class="n">n</span><span class="p">}</span><span class="err">\</span><span class="n">n</span></code></pre></figure>    \n\n### Eventos con información extra (EventHandler<T>)  \n\nHay ocasiones en que los eventos por si mismos sean solo una parte de la información, por ejemplo: imagina que de nuestro generador de números aleatorios queremos saber cuándo se genera un número par, y saber cuál es el número par que se generó. Es ahí cuando podemos hacer uso de `EventHandler<T>`:\n\n\n#### Declaración  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npublic</span> <span class="k">event</span> <span class="n">EventHandler</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">EvenNumberGenerated</span><span class="p">;</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\n#### Manejo  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">ng</span><span class="p">.</span><span class="n">EvenNumberGenerated</span> <span class="p">+=</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">number</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;Se generó el número par: \&quot; + number + \&quot; (manejador 1)\&quot;);\n};\n</span></code></pre></figure>  \n\n#### Múltiples manejadores  \n\nHay ocasiones en que para un mismo evento existen muchos suscriptores. Para suscribir más de un manejador de evento basta con seguir utilizando el operador `+=`\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">n</span><span class="c1">// Método para el manejador\nstatic void G_EvenNumberGenerated(object sender, int number)\n{\n    Console.Write(\&quot;Se generó el número par\&quot; + number + \&quot; (manejador 2)\&quot;);\n    if (number % 7 == 0)\n    {\n        Console.Write(\&quot; que además es múltiplo de 7, bye bye!\&quot;);\n        g.EvenNumberGenerated -= G_EvenNumberGenerated;\n    }\n    Console.WriteLine();\n}\n\n// Suscripción del manejador  \ng.EvenNumberGenerated += G_EvenNumberGenerated;  \n</span></code></pre></figure>    \n\n#### Invocación  \n\nAhora, para invocar un evento de este tipo es necesario usar como argumentos el objeto que lo provoca y el valor asociado con el evento:   \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">generated</span> <span class="p">=</span> <span class="n">r</span><span class="p">.</span><span class="n">Next</span><span class="p">();</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">nif</span> <span class="p">(</span><span class="n">generated</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="k">if</span> <span class="p">(</span><span class="n">EvenNumberGenerated</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span><span class="err">\</span><span class="n">n</span>    <span class="p">{</span><span class="err">\</span><span class="n">n</span>        <span class="n">EvenNumberGenerated</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">generated</span><span class="p">);</span><span class="err">\</span><span class="n">n</span>    <span class="p">}</span><span class="err">\</span><span class="n">n</span>    <span class="c1">// ...\n</span></code></pre></figure>  \n\nTras lo cual, el resultado de ejecutar el programa es el siguiente:  \n\n<pre>\nLeña generará un número\nLeña generará un número (EventHandler)\nSe generó el número par: 1817673842 (manejador 1)\nSe generó el número par1817673842 (manejador 2)\nLeña generará un número\nLeña generará un número (EventHandler)\nSe generó el número par: 1464150850 (manejador 1)\nSe generó el número par1464150850 (manejador 2)\n</pre>\n\n### Desuscribiéndose de eventos  \n\nAsí como podemos suscribirnos a eventos, también es posible hacer lo contrario: desuscribirse de los eventos. Nos desuscribimos de un evento cuando no queremos seguir al tanto de su invocación.  \n\nPara desuscribimos usamos el operador `-=` junto con el manejador de evento con el que nos suscribimos:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">ng</span><span class="p">.</span><span class="n">EvenNumberGenerated</span> <span class="p">-=</span> <span class="n">G_EvenNumberGenerated</span><span class="p">;</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\nSi en tu código tendrás que desuscribir eventos, lo ideal es que los declares como métodos con nombre, no lambdas y no delegados, ya que es más natural <a href=\"http://stackoverflow.com/questions/183367/unsubscribe-anonymous-method-in-c-sharp\" target=\"_blank\">remover un manejador</a> que uno anónimo.  \n  \n### ¿Por qué no usar un delegado?  \n\nUna de las preguntas que te podrían surgir es ¿por qué no usar solamente un `delegate` en lugar de la sintaxis extra de los `event`?\n\nLa respuesta es un tanto sencilla, además del valor semántico que le da un evento a tu código, los eventos tienen dos características:  \n\n - Solamente pueden ser invocados dentro del objeto al que pertenecen.    \n - Únicamente pueden ser eliminados (igualados a `null`) dentro del objeto al que pertenecen.  \n\n O, en código:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">n</span><span class="c1">// Dentro de la clase Generator\npublic Action&lt;int&gt; EvenNumberGeneratedAction;\n\n//  Fuera de la clase Generator\t\t\t\n//g.EvenNumberGenerated(5); // No se puede ejecutar el evento desde \&quot;afuera\&quot;\ng.EvenNumberGeneratedAction(3);\n\n//g.EvenNumberGenerated = null; // No se puede \&quot;eliminar\&quot; a todos los manejadores desde fuera  \ng.EvenNumberGeneratedAction = null;\n</span></code></pre></figure>  \n\n### Conclusión  \n\nLos eventos son de mucha importancia cuando se programan aplicaciones en C#, y más aún cuando se tiene que reaccionar a cambios en un objeto o cuando debemos estar al tanto de interacciones con los usuarios. Conocer qué es lo que tienen detrás y cómo es que se declaran, invocan y manejan debería estar en el repertorio de todo desarrollador en C#. "'   
}