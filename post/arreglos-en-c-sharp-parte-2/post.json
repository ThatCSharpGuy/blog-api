{	
	"id" : "/post/arreglos-en-c-sharp-parte-2/",
	"tv" : false,
	"date": "2015-10-22 16:00:00 -0500",
	"title" : "Arreglos en C# (multidimensionales escalonados)",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages/arreglos-en-c-sharp-parte-2/featured.png",
	"tags" : ["AprendeCSharp"],
	"content": "<p>En el post anterior les contaba sobre los arreglos <a href=\"/post/arreglos-en-c-sharp-parte-1\">arreglos unidimensionales en C#</a>, y hacia el final los invitaba a leer este, sobre los arreglos multidimensionales, así que sin más:</p>\n\n<p>Los arreglos escalonados (o <em>jagged arrays</em>) son los tipos de arreglos multidimensionales más conocidos, y es que también son compunes en otros lenguajes de programación. Un arreglo escalonado no es más que un arreglo de arreglos.</p>\n\n<h4 id=\"instanciacin\">Instanciación</h4>\n<p>Para crear estos arreglos de arreglos, tenemos una sintaxis similar a la creación de arreglos unidimensionales, con <code>[ ]</code> para cada dimensión:</p>\n<pre class=\"csharp\">\t\t\t\nchar[][] gato = new char[3][];\n\nstring [][][] rubik = new string[3][][];\n\nint[][] escalera = new int[3][];\n</pre>\n<p>Acá es importante notar que al instanciar un arraglo multidimensional de esta manera <strong>únicamente estamos indicando el tamaño de la primera dimensión</strong>, 3 en el caso de <code>gato</code>, 3 también para <code>rubik</code> y 2 para <code>escalera</code>. Es tarea nuestra inicializar los arreglos interiores:</p>\n<pre class=\"csharp\">\t\t\t\nfor(int i = 0; i &lt; 3; i++)\n\n\tgato[i] = new char[3]; // gato[i] hace referencia a un arreglo\n\n</pre>\n<pre class=\"csharp\">\t\t\t\nfor(int i = 0; i &lt; 3; i++)\n\n\trubik[i] = new string[3][];\n\tfor(int j = 0; j &lt; 3; j++)\n\t\n\t\trubik[i][j] = new string[3];\n\t\n\n</pre>\n<p>Con los arreglos escalonados no hay nada que nos prohíba crear arreglos internos de dimensiones iguales a la de arreglo que las contiene, es más, <strong>podemos crear arreglos internos de distintos tamaños en la misma dimensión</strong>, hagamos algo con nuestro arreglo <code>escalera</code>:</p>\n<pre class=\"csharp\">\t\t\t\nescalera [0] = new int[1]  1 ;\nescalera [1] = new int[2]  2, 3 ;\nescalera [2] = new int[3]  4, 5, 6 ;\n</pre>\n<p>Con estos arreglos de arreglos también podemos usar la instanciación de colecciones:</p>\n<pre class=\"csharp\">\t\nchar[][] gato = \n\n\tnew char[] 'o', 'x', 'o' ,\n\tnew char[] 'o', 'x', 'o' ,\n\tnew char[] 'o', 'x', 'o' \n;\n</pre>\n\n<h4 id=\"acceso-a-los-elementos\">Acceso a los elementos</h4>\n<p>De nueva cuenta, y por tratarse de arreglos, usaremos los <code>[ ]</code> para acceder a los elementos de nuestros arreglos, de tal manera que es posible escribir algo como esto:</p>\n<pre class=\"csharp\"> \nfor (int i = 0; i &lt; escalera.Length; i++)\n\n\tfor (int j = 0; j &lt; escalera [i].Length; j++) \n\t\n\t\tConsole.Write (escalera[i][j] +  \" \");\n\t\n\tConsole.WriteLine();\n    \n</pre>\n\n<h4 id=\"lo-que-sigue\">Lo que sigue</h4>\n<p>En el post siguiente les platicaré sobre los arreglos rectangulares, que son lo más parecido a matrices que podemos encontrar en C#. Estos son similares a los arreglos rectangulares con la pequeña diferencia de que no pueden contener arreglos de distintos tamaños dentro de la misma dimensión.</p>\n"
}