{	
	"id" : "/post/arreglos-en-c-sharp-parte-2/",
	"tv" : false,
	"date": "2015-10-22 16:00:00 -0500",
	"title" : "Arreglos en C# (multidimensionales escalonados)",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimagesfeatured.png",
	"tags" : ["AprendeCSharp"],
	  
	"content": '"En el post anterior les contaba sobre los arreglos <a href=\"/post/arreglos-en-c-sharp-parte-1\">arreglos unidimensionales en C#</a>, y hacia el final los invitaba a leer este, sobre los arreglos multidimensionales, así que sin más:  \n\nLos arreglos escalonados (o *jagged arrays*) son los tipos de arreglos multidimensionales más conocidos, y es que también son compunes en otros lenguajes de programación. Un arreglo escalonado no es más que un arreglo de arreglos.\n\n#### Instanciación  \nPara crear estos arreglos de arreglos, tenemos una sintaxis similar a la creación de arreglos unidimensionales, con `[ ]` para cada dimensión: \n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">t</span><span class="err">\</span><span class="n">t</span><span class="err">\</span><span class="n">t</span><span class="err">\</span><span class="n">nchar</span><span class="p">[][]</span> <span class="n">gato</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="m">3</span><span class="p">][];</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">nstring</span> <span class="p">[][][]</span> <span class="n">rubik</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">string</span><span class="p">[</span><span class="m">3</span><span class="p">][][];</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">nint</span><span class="p">[][]</span> <span class="n">escalera</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">3</span><span class="p">][];</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \nAcá es importante notar que al instanciar un arraglo multidimensional de esta manera **únicamente estamos indicando el tamaño de la primera dimensión**, 3 en el caso de `gato`, 3 también para `rubik` y 2 para `escalera`. Es tarea nuestra inicializar los arreglos interiores: \n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">t</span><span class="err">\</span><span class="n">t</span><span class="err">\</span><span class="n">t</span><span class="err">\</span><span class="n">nfor</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">tgato</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="m">3</span><span class="p">];</span> <span class="c1">// gato[i] hace referencia a un arreglo\n}\n</span></code></pre></figure>   \n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">t</span><span class="err">\</span><span class="n">t</span><span class="err">\</span><span class="n">t</span><span class="err">\</span><span class="n">nfor</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">trubik</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">string</span><span class="p">[</span><span class="m">3</span><span class="p">][];</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">tfor</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">j</span><span class="p">++)</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">t</span><span class="p">{</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">t</span><span class="err">\</span><span class="n">trubik</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">string</span><span class="p">[</span><span class="m">3</span><span class="p">];</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">t</span><span class="p">}</span><span class="err">\</span><span class="n">n</span><span class="p">}</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \nCon los arreglos escalonados no hay nada que nos prohíba crear arreglos internos de dimensiones iguales a la de arreglo que las contiene, es más, **podemos crear arreglos internos de distintos tamaños en la misma dimensión**, hagamos algo con nuestro arreglo `escalera`:   \n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">t</span><span class="err">\</span><span class="n">t</span><span class="err">\</span><span class="n">t</span><span class="err">\</span><span class="n">nescalera</span> <span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">{</span> <span class="m">1</span> <span class="p">};</span><span class="err">\</span><span class="n">nescalera</span> <span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">{</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span> <span class="p">};</span><span class="err">\</span><span class="n">nescalera</span> <span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">3</span><span class="p">]</span> <span class="p">{</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">6</span> <span class="p">};</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \nCon estos arreglos de arreglos también podemos usar la instanciación de colecciones:   \n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">t</span><span class="err">\</span><span class="n">nchar</span><span class="p">[][]</span> <span class="n">gato</span> <span class="p">=</span> <span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">tnew</span> <span class="kt">char</span><span class="p">[]{</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39;x&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span> <span class="p">},</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">tnew</span> <span class="kt">char</span><span class="p">[]{</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39;x&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span> <span class="p">},</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">tnew</span> <span class="kt">char</span><span class="p">[]{</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39;x&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span> <span class="p">}</span><span class="err">\</span><span class="n">n</span><span class="p">};</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n  \n#### Acceso a los elementos  \nDe nueva cuenta, y por tratarse de arreglos, usaremos los `[ ]` para acceder a los elementos de nuestros arreglos, de tal manera que es posible escribir algo como esto:   \n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"> <span class="err">\</span><span class="n">nfor</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">escalera</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">tfor</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="p">&lt;</span> <span class="n">escalera</span> <span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Length</span><span class="p">;</span> <span class="n">j</span><span class="p">++)</span> <span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">t</span><span class="p">{</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">t</span><span class="err">\</span><span class="n">tConsole</span><span class="p">.</span><span class="n">Write</span> <span class="p">(</span><span class="n">escalera</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="p">+</span>  <span class="err">\</span><span class="s">&quot; \&quot;);\n\t}\n\tConsole.WriteLine();\n}    \n</span></code></pre></figure>  \n\n#### Lo que sigue\nEn el post siguiente les platicaré sobre los arreglos rectangulares, que son lo más parecido a matrices que podemos encontrar en C#. Estos son similares a los arreglos rectangulares con la pequeña diferencia de que no pueden contener arreglos de distintos tamaños dentro de la misma dimensión."'   
}