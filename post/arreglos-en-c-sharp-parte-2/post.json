{	
	"id" : "/post/arreglos-en-c-sharp-parte-2/",
	"tv" : false,
	"date": "2015-10-22 16:00:00 -0500",
	"title" : "Arreglos en C# (multidimensionales escalonados)",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimagesfeatured.png",
	"tags" :
	["AprendeCSharp"],
	
	"content" : body"En el post anterior les contaba sobre los arreglos <a href=\"/post/arreglos-en-c-sharp-parte-1\">arreglos unidimensionales en C#</a>, y hacia el final los invitaba a leer este, sobre los arreglos multidimensionales, así que sin más:  \n\nLos arreglos escalonados (o *jagged arrays*) son los tipos de arreglos multidimensionales más conocidos, y es que también son compunes en otros lenguajes de programación. Un arreglo escalonado no es más que un arreglo de arreglos.\n\n#### Instanciación  \nPara crear estos arreglos de arreglos, tenemos una sintaxis similar a la creación de arreglos unidimensionales, con `[ ]` para cada dimensión: \n{% highlight csharp %}\t\t\t\nchar[][] gato = new char[3][];\n\nstring [][][] rubik = new string[3][][];\n\nint[][] escalera = new int[3][];\n{% endhighlight %}  \nAcá es importante notar que al instanciar un arraglo multidimensional de esta manera **únicamente estamos indicando el tamaño de la primera dimensión**, 3 en el caso de `gato`, 3 también para `rubik` y 2 para `escalera`. Es tarea nuestra inicializar los arreglos interiores: \n{% highlight csharp %}\t\t\t\nfor(int i = 0; i < 3; i++)\n{\n\tgato[i] = new char[3]; // gato[i] hace referencia a un arreglo\n}\n{% endhighlight %}   \n{% highlight csharp %}\t\t\t\nfor(int i = 0; i < 3; i++)\n{\n\trubik[i] = new string[3][];\n\tfor(int j = 0; j < 3; j++)\n\t{\n\t\trubik[i][j] = new string[3];\n\t}\n}\n{% endhighlight %}  \nCon los arreglos escalonados no hay nada que nos prohíba crear arreglos internos de dimensiones iguales a la de arreglo que las contiene, es más, **podemos crear arreglos internos de distintos tamaños en la misma dimensión**, hagamos algo con nuestro arreglo `escalera`:   \n{% highlight csharp %}\t\t\t\nescalera [0] = new int[1] { 1 };\nescalera [1] = new int[2] { 2, 3 };\nescalera [2] = new int[3] { 4, 5, 6 };\n{% endhighlight %}  \nCon estos arreglos de arreglos también podemos usar la instanciación de colecciones:   \n{% highlight csharp %}\t\nchar[][] gato = \n{\n\tnew char[]{ 'o', 'x', 'o' },\n\tnew char[]{ 'o', 'x', 'o' },\n\tnew char[]{ 'o', 'x', 'o' }\n};\n{% endhighlight %}  \n  \n#### Acceso a los elementos  \nDe nueva cuenta, y por tratarse de arreglos, usaremos los `[ ]` para acceder a los elementos de nuestros arreglos, de tal manera que es posible escribir algo como esto:   \n{% highlight csharp %} \nfor (int i = 0; i < escalera.Length; i++)\n{\n\tfor (int j = 0; j < escalera [i].Length; j++) \n\t{\n\t\tConsole.Write (escalera[i][j] +  \" \");\n\t}\n\tConsole.WriteLine();\n}    \n{% endhighlight %}  \n\n#### Lo que sigue\nEn el post siguiente les platicaré sobre los arreglos rectangulares, que son lo más parecido a matrices que podemos encontrar en C#. Estos son similares a los arreglos rectangulares con la pequeña diferencia de que no pueden contener arreglos de distintos tamaños dentro de la misma dimensión."
}