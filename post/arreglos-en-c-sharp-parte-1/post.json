{	
	"id" : "/post/arreglos-en-c-sharp-parte-1/",
	"tv" : false,
	"date": "2015-10-22 16:00:00 -0500",
	"title" : "Arreglos en C# (unidimensionales)",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimagesfeatured.png",
	"tags" :
	[ 
		"AprendeCSharp"
	],
	"content" : "<p>En C# llamamos arreglo a una colección de objetos, dicha colección tiene longitud definida y esta no puede cambiar con el flujo del programa, esto podrá sonar limitante, pero al trabajar con arreglos se obtiene un mejor desempeño que con cualquier otra colección. Usando el lenguaje podemos crear, recorrer y manipular arreglos de cualquier tipo de objeto.</p>

<h3 id=\"unidimensionales\">Unidimensionales</h3>
<p>Comenzando por lo más básico, los arreglos unidimensionales son colecciones lineales, que nos pueden ayudar a representar una secuencia numérica, letras del alfabeto o un cromosoma dentro de un programa de algoritmos genéticos, entre muchas otras otras.</p>

<h4 id=\"instanciacin\">Instanciación</h4>
<p>Para crear un arreglo haremos uso de la palabra reservada <code>new</code> y los corchetes cuadrados <code>[ ]</code>, también es necesario conocer el tamaño que necesitaremos, puesto que como ya lo mencioné, no es posible cambiar el tamaño una vez creado: 
<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">char</span> <span class="p">[]</span> <span class="n">vocales</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="m">5</span><span class="p">];&lt;/</span><span class="n">p</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="n">p</span><span class="p">&gt;</span><span class="kt">int</span> <span class="p">[]</span> <span class="n">conteo</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">10</span><span class="p">];&lt;/</span><span class="n">p</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="n">p</span><span class="p">&gt;</span><span class="kt">object</span> <span class="p">[]</span> <span class="n">misObjetos</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">[</span><span class="m">3</span><span class="p">];</span></code></pre></figure><br />
Si creamos arreglos de esa manera, cada posición tendrá el valor por default del tipo de dato del arreglo… bueno, mejor usamos nuestro ejemplo:</p>

<ul>
  <li>El arreglo de <code>vocales</code> contendrá 5 <code>\0</code>, que es el valor por default de un <code>char</code>.</li>
  <li>El arreglo <code>conteo</code> contendrá 10 <code>0</code>, que es el valor por default de un entero.</li>
  <li>El arreglo <code>misObjetos</code> contendrá 3 <code>null</code>, que es el valor por default de un <code>object</code>.</li>
</ul>

<p><br /><br />
Además de la instanciación tradicional, también podemos emplear la instanciación de colecciones, la cual nos permite inicializar un arreglo asignándole valores inmediatamente:<br />
<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">char</span> <span class="p">[]</span> <span class="n">vocales</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="m">5</span><span class="p">]</span> <span class="p">{</span> <span class="err">‘</span><span class="n">a</span><span class="err">’</span><span class="p">,</span> <span class="err">‘</span><span class="n">e</span><span class="err">’</span><span class="p">,</span> <span class="err">‘</span><span class="n">i</span><span class="err">’</span><span class="p">,</span> <span class="err">‘</span><span class="n">o</span><span class="err">’</span><span class="p">,</span> <span class="err">‘</span><span class="n">u</span><span class="err">’</span> <span class="p">};&lt;/</span><span class="n">p</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="n">p</span><span class="p">&gt;</span><span class="kt">int</span> <span class="p">[]</span> <span class="n">conteo</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[]</span> <span class="p">{</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">8</span><span class="p">,</span> <span class="m">9</span><span class="p">,</span> <span class="m">0</span> <span class="p">};&lt;/</span><span class="n">p</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="n">p</span><span class="p">&gt;</span><span class="kt">object</span> <span class="p">[]</span> <span class="n">misObjetos</span> <span class="p">=</span> <span class="p">{</span> <span class="err">“</span><span class="m">3</span><span class="err">”</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">99.99</span> <span class="p">};</span></code></pre></figure>
Como podemos ver, tenemos varias opciones para inicializar arreglos unidimensionales:</p>

<ol>
  <li><code>new char[5] { ...</code>, nos permite indicar el tamaño y el tipo explícitamente y posteriormente indicar los valores, si cambiáramos el <code>5</code> por un <code>7</code>sin aumentar la cantidad de valores obtendríamos un error de compilación.</li>
  <li><code>new int[] { 1, 2, ...</code>, nos permite indicar solamente el tipo de dato de los elementos, la cantidad es inferida por el compilador, en este caso podemos incrementar o reducir la cantidad de elementos al momento de inicializar sin ningún problema.</li>
  <li><code>{ \"3\", 1, 99.99 }</code>, al inicializar de esta manera estamos dejandole al compilador la tarea de inferir tanto el tipo de dato del arreglo como la cantidad de elementos que contiene. Dicho sea de paso, el declarar un arreglo así puede resultar un poco confuso de leer.</li>
</ol>

<h4 id=\"acceso-a-los-elementos\">Acceso a los elementos</h4>
<p>Una vez instanciado, podemos acceder a los elementos del arreglo usando nuevamente los corchetes cuadrados <code>[ ]</code> y el índice del elemento al que queremos acceder. Nota importante <strong>los arreglos están indizados en 0</strong> es decir, el primer elemento de un arreglo está en el índice 0.</p>

<p>Retomemos los arreglos del ejemplo pasado. Para acceder a la <code>a</code> dentro del arreglo <code>vocales</code> debemos acceder a la posición <code>0</code>:<br />
<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">vocales</span><span class="p">[</span><span class="m">0</span><span class="p">]);</span> <span class="c1">// a</span></code></pre></figure>
O, digamos que queremos reemplazar la <code>i</code> por una <code>t</code>:<br />
<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="n">vocales</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="err">‘</span><span class="n">t</span><span class="err">’</span><span class="p">;</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">vocales</span><span class="p">[</span><span class="m">2</span><span class="p">]);</span> <span class="c1">// t</span></code></pre></figure></p>

<h4 id=\"propiedades-y-mtodos\">Propiedades y métodos</h4>
<p>A pesar de que los arreglos implementan la interfaz <code>IList</code>, con todo y sus propiedades, la única rescatable para los arreglos unidimensionales es la propiedad <code>Length</code> (o <code>LongLength</code> si metemos más de 2^32-1 elementos en el arreglo), que nos devuelve la longitud del arreglo:
<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">vocales</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span> <span class="c1">// 5&lt;/p&gt;</span>

<span class="p">&lt;</span><span class="n">p</span><span class="p">&gt;</span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">conteo</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span> <span class="c1">// 10&lt;/p&gt;</span>

<span class="p">&lt;</span><span class="n">p</span><span class="p">&gt;</span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">misObjetos</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span> <span class="c1">// 3</span></code></pre></figure></p>

<h5 id=\"posdata\">Posdata</h5>
<p>Sin importar su contenido, los arreglos siempre son tipos por referencia, por lo que es posible tener las siguientes líneas de código:
<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">int</span> <span class="p">[]</span> <span class="n">arreglo</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
<span class="kt">double</span> <span class="p">[]</span> <span class="n">nulo</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span></code></pre></figure></p>

<h4 id=\"lo-que-sigue\">Lo que sigue</h4>
<p>Inicialmente este post conendría todos los tipos de arreglos que permite crear C#, pero al final he decidido separarlos para hacerlo un poco más entendible, puedes visitar el siguiente sobre <a href=\"/post/arreglos-en-c-sharp-parte-2\">arreglos multidimensionales en C#</a>.</p>
"
}