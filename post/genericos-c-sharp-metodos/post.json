{	
	"id" : "/post/genericos-c-sharp-metodos/",
	"tv" : false,
	"date": "2016-06-19 14:00:01 -0500",
	"title" : "Métodos genéricos en C#",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//aprende-c-sharp/generics-es.png",
	"tags" :
	["AprendeCSharp"],
	
	"content" : body"En un <a href=\"../genericos-c-sharp-clases\">post anterior</a> hablé sobre las clases genéricas en C#, ahí mencioné que había otra posibilidad de usar el mismo concepto (de plantillas y marcadores) pero en la creación de métodos, y este post habla sobre ellos.\n\n### Sintaxis\n\nLa sintaxis es casi la misma que al declarar un método tradicional, salvo que de nuevo aparecen los *placeholders* de tipos entre `<` `>`, por ejemplo, en el siguiente método se declara únicamente `T`:\n\n{% highlight csharp %}\nstatic void WriteType<T>()\n{\n    var a = typeof(T);\n    Console.WriteLine(a.Name);\n}\n{% endhighlight %}  \n\n### Uso\n\nEntonces, para llamarlo, tendremos que hacerlo de la siguiente manera:\n\n{% highlight csharp %}\nWriteType<int>(); // Int32\nWriteType<Program>(); // Program\n{% endhighlight %}  \n\nAl igual que con los tipos, una vez indicado el *placeholder* podemos utilizarlo tanto en la firma del método como en el cuerpo del mismo:\n\n{% highlight csharp %}\nstatic T GetDefault<T>(T useless)\n{\n    return default(T);\n}\n{% endhighlight %}  \n\nPara usarlos tenemos dos opciones:  \n  \n  1. Indicar explícitamente los tipos a la hora de realizar la llamada\n  2. Permitir que el compilador infiera a qué tipos nos referimos a partir de los argumentos pasados\n\n{% highlight csharp %}\nvar dflt = GetDefault<int>(10);\nvar dflt2 = GetDefault(4.0); // Se infiere que es double a partir del argumento pasado al método\n// int dflt3 = GetDefault(DateTime.Now); // Error, DateTime no se puede convertir a int implícitamente\n{% endhighlight %}  \n\n### Ejemplos  \n\nUno de los ejemplos más usados para explicar los métodos genéricos es un método que intercambia dos valores dados:\n\n<div class=\"pure-g\">\n<div class=\"pure-u-1 pure-u-md-1-2\">\n{% highlight csharp %}\nstatic void Swap(ref decimal a, ref decimal b)\n{\n    decimal t = a;\n    a = b;\n    b = t;\n}\n{% endhighlight %}  \n</div>\n<div class=\"pure-u-1 pure-u-md-1-2\">\n{% highlight csharp %}\nstatic void Swap(ref int a, ref int b)\n{\n    int t = a;\n    a = b;\n    b = t;\n}\n{% endhighlight %}  \n</div>  \n</div>\n\nHasta aquí todo bien, ya podemos intercambiar de lugar decimales y enteros, pero ¿qué va a pasar cuando tengamos que intercambiar `DateTime` o `doubles`? podríamos copiar y pegar el código del método cambiando únicamente los tipos de dato... o podríamos en su lugar usar un método genérico:\n\n{% highlight csharp %}\nstatic void Swap<T>(ref T a, ref T b)\n{\n    T t = a;\n    a = b;\n    b = t;\n}\n{% endhighlight %}  \n\nEntonces ya podríamos usar el método con cualquier tipo que deseemos:\n\n<div class=\"pure-g\">\n<div class=\"pure-u-1 pure-u-md-1-2\">\n{% highlight csharp %}\nint uno = 1, dos = 2;\nConsole.WriteLine(uno + \" \" + dos);\n\nSwap<int>(ref uno, ref dos);\nConsole.WriteLine(uno + \" \" + dos);\n\nSwap(ref uno, ref dos); // Se infiere int\nConsole.WriteLine(uno + \" \" + dos);\n{% endhighlight %}  \n</div>\n<div class=\"pure-u-1 pure-u-md-1-2\">\n{% highlight csharp %}\nfloat d1 = 10, d2 = 20;\nConsole.WriteLine(d1 + \" \" + d2);\n\nSwap(ref d1, ref d2); // Se infiere float\nConsole.WriteLine(d1 + \" \" + d2);  \n\n  \n  \n{% endhighlight %}  \n</div>  \n</div>  \n\n#### Errores\n\nCuando usamos métodos genéricos es posible incurrir en errores, los más comunes son que el compilador no pueda inferir los tipos a los que nos referimos, como en este caso que estamos usando `Swap` con un `int` y un `float`:   \n\n{% highlight csharp %}\nSwap(uno, d2); // Error, los tipos no pueden ser inferidos\n{% endhighlight %}  \n\nO que intentemos usar un tipo de dato que no corresponde si especificamos explícitamente los tipos:\n\n{% highlight csharp %}\nSwap<int>(ref uno, ref d2); // Error, d2 no es entero\n{% endhighlight %}  \n\n### Restricciones  \n\nAl igual que los tipos genéricos, los métodos también aceptan restricciones usando la palabra reservada `where`, por ejemplo, en el método siguiente se restringe que tanto el tipo `T` como `W` sean `Athlete` o derivados de este. Además de que `T` tenga un constructor público sin parámetros:\n\n{% highlight csharp %}\nstatic T ChangeSport<T, W>(W toCast)\n    where T : Athlete, new()\n    where W : Athlete\n{\n    // ...\n{% endhighlight %}  \n\n## Para cerrar  \n\nEs importante señalar que un método de un tipo genérico no es genérico simplemente por eso, para que un método genérico sea considerado así debe tener al menos un *placeholder* de tipo. También debes considerar que a veces no todo es suceptible de *genericalizar*, es cuestión de analizar bien el problema."
}