{	
	"id" : "/post/learning-xamarin-ios-stanford-cs193p/",
	"tv" : false,
	"date": "2016-12-27 02:00:00 -0600",
	"title" : "Learning Xamarin.iOS at Stanford",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//xamarin-ios/stanford.jpg",
	"tags" :
	["Xamarin","XamariniOS"],
	
	"content" : body"To finish the year in a good manner I decided to ramp up my Xamarin.iOS development skills. So far I had only worked on iOS apps using Xamarin.Forms and I have only made small apps following Apple tutorials <a href=\"https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/\" target=\"_blank\">like this</a>, but for me that is not enough, I wanted to take a course like I did a few years ago when I took one on Android dev, with that in mind <a href=\"https://twitter.com/io_exception/status/807047846063177728\" target=\"_blank\">I asked on Twitter</a> whether NSScreencasts was a good choice for novices.\n\nLuckily I got a several answers of all kind, generally the answers where a big yes, but not for beginners (which I consider myself), a couple of them suggested some books, but three suggested I should took a free Stanford Course with the nuance that it was given using Swift 2, to me it isn't a huge deal as my main focus is to learn the workflow and essentials of iOS dev, and then transfer that knowledge to Xamarin.iOS.\n\nI'm about 3 lectures away from finishing the course, but in this post I'll share my experience so far:\n\n## Syntax differences  \nThis may be because I am a .NET developer since 2008 but, mate: Swift syntax is so weird! and my guess is that is in great part thanks to Obj-C... but anyway, the differences for basic properties, methods, base classes, aren't that big. You can get around them thanks to the great intellisense offered by Xamarin/Visual studio since they are mostly only casing (`tableView` vs `TableView`) distinctions, if you want, you can read my post on basic <a href=\"../xamarin-ios-vs-traditional\" target=\"_blank\">Xamarin.iOS vs Swift differences</a>.\n\nIn other cases you'll have to look for the arguments and return type of a given method to be 90% that you are calling the right method (the other 10% comes from executing and see if it works as expected).\n\n## Enums whith associated values  \nWAIT WHAT? really? wow, there are no such things when using C#... you'll have to work around this issue, C# do have enums but they're *masked* integer types and no other info can be associated with them.\n\nWhat I ended up doing to overcome this issue for the *Calculator assignment* was to create <a href=\"https://github.com/fferegrino/cs193/blob/master/Calculator/CalculatorBrainDictionaries.cs\" target=\"_blank\">a few dictionaries</a>. It got a bit messy, but in the end it worked pretty good.\n\n## Closures  \nClosures in Swift are our good (not so) old Func and Action types in C#. You don't get the nice $1, $2 syntax, but who needs that? A thing to note is that in Swift you the possibility to specify how a local variable will be referenced inside a closure, in order to avoid memory leaks.\n\n## Of vars and properties  \nIn Swift exist properties which are almost, almost like properties in C#, you can see this when using the \"stored properties\":\n\n{% highlight swift %}\nclass AxesDrawer\n{\n    var color = UIColor.blueColor()\n    var minimumPointsPerHashmark: CGFloat = 40\n{% endhighlight %}  \n\nWhich are somewhat like the \"automplmemented properties\" in C#\n\n{% highlight csharp %}\nclass AxesDrawer \n{\n    public UIColor Color { get; set; }\n    public CGFloat MinimumPointsPerHashmark { get; set; }\n{% endhighlight %}  \n\nIn both languages you can have computed properties:  \n\n{% highlight swift %}\n// Swift\nclass AxesDrawer \n{\n    private var _color : UIColor = UIColor.blueColor()\n    var color : UIColor { \n        get { \n            return _color \n        } \n        set { \n            _color = newValue \n        } \n    }\n{% endhighlight %}  \n\n{% highlight csharp %}\n// C#\nclass AxesDrawer \n{\n    UIColor _color = UIColor.Blue;\n    public UIColor Color \n    { \n        get { return _color; } \n        set { _color = value; } \n    }\n{% endhighlight %}  \n\nAnother cool feature that I would enjoy in C# are the property observers (`willSet` and `didSet`) which behavior we can mimic in C# using computed properties but the code does not look as clean as with Apple's language:\n\n{% highlight csharp %}\npublic double _scale = 0.9;\npublic double Scale\n{\n    get { return _scale; }\n    set \n    { \n        // willSet code\n        _scale = value;\n        // didSet code \n    }\n}\n{% endhighlight %}  \n\n\n## Implementing protocols\nWhen implementing protocols, there is a weird thing that happens: At first I thought that Protocols in Swift where like Interfaces in C#... turns out they are not! When using protocols there are some methods or properties that you are not obligated to implement whereas when using an interface you are required to implement all the members defined within it, so the guys at Xamarin came up with this weird solution where you need to implement an *EMPTY* interface that has nothing but metadata that you can use to mimic the protocols behavior (<a href=\"https://developer.xamarin.com/api/type/MonoTouch.UIKit.IUITextViewDelegate/\" target=\"_blank\">see here</a>). For example, take a look at the approach to create a delegate for the UITextField and respond to a protocol's member call:\n\n{% highlight csharp %}\npublic partial class TweetTableViewController : UITableViewController, IUITextFieldDelegate\n{\n    // ...\n\n    [Export(\"textFieldShouldReturn:\")]\n    public bool ShouldReturn(UITextField textField)\n    {\n        // Delegate code\n{% endhighlight %}  \n\n## Swift's extensions to types  \nWhen it comes to extend the capabilities of classes, Swift offers a more range of movement than C# since you can add properties, constructors and make a class adopt a protocol. C# only allows to \"extend\" vía static methods, no other members can be added to a given type.\n\n## Using the iOS interface designer  \nNeither the Android designer nor the iOS designer are perfect in their current form, and as such I think it is awesome that you can use Xcode to create your UI and then have it sync and map every outlet and action in your C# project within Xamarin Studio. What you need to do is to *right click* on your storyboard file and select `Open with Xcode interface builder`.\n\nEvery time you save your interface in Xcode it'll be synced to Xamarin Studio without issues.\n\nThe Xamarin approach will create a WhateverViewController.designer.cs containing a partial definition of your `UIViewController` derivate class, in it all the outlets and actions of your view controller will be stored, each of them with a certain attribute (for outlets the attribute is `[Outlet]`) that tells the designer what they are used for. You are not supposed to mess with this file, however, if you need to take an outlet out of there you can do so... as long as you place it somewhere else without the designer attribute, as I did when I had to perform an action as soon as a view was assigned:  \n\n{% highlight csharp %}\nFaceView _faceView;\n[Outlet]\nprotected FaceView FaceView\n{\n    get { return _faceView; }\n    set\n    {\n        _faceView = value;\n        // didSet:\n        var gesture = new UIPinchGestureRecognizer();\n        gesture.AddTarget(() => _faceView.ChangeScale(gesture));\n        // Ommited for brevity ...\n        UpdateUI();\n    }\n}\n{% endhighlight %}  \n\nDespite the fact of that you must be switching between the Xcode designer and Xamarin's IDE you should worry no more, you are in good hands when it comes to design the interface of your app. \n\nI do have a complaint about the integration and that is because at the moment I was taking the course it was impossible to open a .storyboard file modified with Xcode 8 in Xamarin Studio, but I think they're addressing this problem.\n\n## Custom views  \nJust as you can create custom controls using Swift or Obj-C you can create custom views using C#, there are a few things to take into consideration, though:  \n\nMake sure that your custom view implements a public constructor that takes an `IntPtr` instance as a parameter:\n\n{% highlight csharp %}\npublic FaceView (IntPtr handle) : base (handle)\n{\n}\n{% endhighlight %} \n\nAlso, make sure to register your custom views to be visible at design time in the editor, using the appropiate attributes `Register` and `DesignTimeVisible`:\n\n{% highlight csharp %}\n[Register(\"FaceView\"), DesignTimeVisible(true)]\npublic class FaceView : UIView\n{\n{% endhighlight %}  \n\nIf you want your properties to be available for modification at design time you will need to mark them with yet another couple of attributes (`Export` and `Browsable`):\n\n{% highlight csharp %}\n[Export(\"Color\"), Browsable(true)]\npublic UIColor Color\n{ // ...\n{% endhighlight %}  \n\n## CoreData  \nUh, for what I've been reading CoreData isn't that easy to use with Xamarin... yet it is possible. I didn't try to do the assignments, mainly because I find it too specific for my purposes at the moment. If you want to try, maybe this links points to a sample that uses this feature in Xamarin: <a href=\"https://developer.xamarin.com/samples/monotouch/ThreadedCoreData/\" target=\"_blank\">ThreadedCoreData sample</a>.\n\n## My code  \nIn case you are interested, you can see the code I created & \"translated\" from some of the on class demos and assignments for this course in this <a href=\"https://github.com/fferegrino/cs193\" target=\"_blank\">GitHub repo</a> feel free to reach to me in case of doubts.\n\n## So... where?  \nYou can see the lectures from <a href=\"https://itunes.apple.com/mx/course/developing-ios-9-apps-swift/id1104579961?l=en\" target=\"_blank\">iTunes U</a> or <a href=\"https://www.youtube.com/watch?v=_lRx1zoriPo&list=PLsJq-VuSo2k26duIWzNjXztkZ7VrbppkT\" target=\"_blank\">YouTube</a>.\n  \n## To Paul Hegarty  \nI'm 99.9999% sure that you won't read this, but just in case you do: I want to thank you for this lecture, you cannot imagine the knowledge I have gained by simply sitting in front of a PC listening to you, following your code demos and doing the assignments, even using Xamarin. Also thanks to Stanford University for providing this course for free (even though I'd pay for it, seriously!)\n"
}