{	
	"id" : "/post/linq-en-c-sharp-3/",
	"tv" : false,
	"date": "2016-02-08 14:00:00 -0600",
	"title" : "Linq en C# - tercera parte",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages/linq-en-c-sharp/featured.png",
	"tags" : ["AprendeCSharp"],
	"content": "Inmediatamente después de la [segunda parte de la serie de posts sobre Linq](/post/linq-en-c-sharp-2), les traigo este, que es la tercera parte en donde hablaré sobre cómo trabajar con dos conjuntos de datos diferentes, con ellos se pueden realizar uniones y agrupaciones para obtener más conocimiento de la información que tenemos.\n  \n### Preparando el terreno  \nNuevamente en este post me auxiliaré de los mismos elementos que en el post pasado: Las clases `Lecture`, `Teacher` y `FakeDatabase`   \n   \n  \n## Agrupamientos (group by , GroupBy)  \nCon Linq también podemos realizar agrupamientos de datos, esta función está disponible tanto en la sintaxis de método como en la de consulta y a mi parecer es mucho más entendible en la de consulta. Es importante señalar que cuando ejecutamos un agrupamiento tendremos acceso a una nueva colección de tipo `IGrouping`, y cada uno de esos `IGrouping`s contiene una propiedad `Key` que es del tipo de dato sobre el que ejecutamos el agrupamiento. Podríamos er un ejemplo sencillo si queremos saber cuantas clases tiene cada profesor:  \n\n<div class=\"pure-g\">\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\nvar classesPerTeacherQuery =\n    from lecture in db.Lectures\n    group lecture by lecture.TeacherId into grp\n    select new\n    \n        TeacherId = grp.Key,\n        LectureCount = grp.Count()\n    ;\n</pre>  \n</div>\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\nvar classesPerTeacherMethod = db.Lectures\n    .GroupBy(lecture => lecture.TeacherId)\n    .Select(grp =>\n        new\n        \n            TeacherId = grp.Key,\n            LectureCount = grp.Count()\n        );\n</pre>  \n</div>  \n</div>  \n\nEn este caso estamos agrupando las clases por maestro, a través de su llave `TeacherId`. Como se puede ver, cuando usamos la sintaxis de consulta es necesario especificar otro nombre para la colección resultante del agrupamiento, en este caso la llamamos `grp`, mientras que en la sintaxis de método no es necesario. Posteriormente podemos seguir trabajando con la colección agrupada, como en este caso que estamos creando un tipo anónimo con el Id del profesor y la cantidad de clases que imparten.  \n  \nEn un ejemplo más complejo podríamos agrupar las clases que da cada maestro y luego agruparlas por nivel para después imprimirlas en pantalla:\n\n<pre class=\"csharp\">\nvar groupedLecturesPerLevelAndTeacher =\n    from lecture in db.Lectures\n    group lecture by lecture.TeacherId into group1\n    select new\n    \n        TeacherId = group1.Key,\n        Levels = from level in group1\n                 group level by level.Level into group2\n                 select new\n                 \n                    LevelName = group2.Key,\n                    Lectures = group2.ToList()\n                 \n    ;\n</pre>  \n\nEn este caso se puede decir que estamos haciendo un agrupamiento anidado: Primero estamos agrupando las `Lecture`s por el maestro que las imparte, el resultado de esta agrupación lo estamos colocando en `group1`, después, mediante la cláusula `select` estamos creando un nuevo tipo que tiene como propiedades `TeacherId` y `Level` que es creado a de la agrupación de las clases por la propiedad `Level` (que ponemos en `group2`) para posteriormente crear una colección de objetos con `LevelName` y `Lectures`.\n\nTambién se pueden hacer agrupamientos un poco más complejas cuando usamos la sintaxis de método, ya que permite especificar una instancia de clase que implementa la interfaz `IEqualityComparer<T>` mediante la cual se implementa el método `Equals(T, T)` que indica cómo se van a agrupar los elementos.  \n  \n## Uniones (join, Join)  \nUna de las características más interesantes de Linq es la de poder hacer uniones entre conjuntos de datos a partir de una propiedad en ellos, la forma de hacer los *join* en Linq es muy similar a la forma en que se realizan los `inner join` en SQL puesto que es necesario especificar un campo sobre el que se realizará la unión:\n\nEn las consultas anteriores sobre `db.Lectures` únicamente tenemos acceso a `TeacherId`, pero supongamos que también queremos acceder a la información del profesor asignado a una clase. Es ahí cuando debemos hacer un `join`:   \n\n<div class=\"pure-g\">\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\nvar q5 =\n    from l in db.Lectures\n    group l by l.TeacherId into grouped\n    join t in db.Teachers on grouped.Key equals t.Id\n    select new\n    \n        TeacherName = t.GivenName,\n        TeacherId = t.Id,\n        LectureCount = grouped.Count()\n    ;\n</pre>  \n</div>\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\nvar q5alt = db.Lectures\n    .GroupBy(l => l.TeacherId)\n    .Join(db.Teachers, grouped => grouped.Key, t => t.Id,\n    (grouped, t) => new\n    \n        TeacherName = t.GivenName,\n        TeacherId = t.Id,\n        LectureCount = grouped.Count()\n    );\n</pre>  \n</div>  \n</div>  \n\nDefinitivamente hacer los *join* en la sintaxis de consulta es la mejor opción puesto que se convierten en una instrucción más legible. En el código anterior podemos ver que el *join* se compone de tres palabras:  \n \n - Un alias que va después de la palabra `join`  \n - Un origen de datos que va después de la palabra `in`  \n - Una condición bajo la que se realizará la unión después de la palabra `on`  \n  \nSi has escrito SQL seguramente te resultará conocida esta sintaxis.  \n  \n## Operaciones de un elemento (First, Single, ElementAt)  \nComo vimos antes, podemos usar `Take` para obtener una cantidad fija de elementos de una secuencia, sin embargo, para obtener uno solo es recomendable usar los métodos como `Single`, `First` o `ElementAt` y sus similares para dicha tarea. Estos métodos no están disponibles a través de la sintaxis de consulta, únicamente a través de la de método.  \n  \nPor ejemplo, vamos a trabajar con un conjunto de maestros ordenados por su apellido:\n\n<pre class=\"csharp\">\nvar q6 = from l in db.Teachers\n            orderby l.LastName descending\n            select l;\n</pre>  \n\n### First\n\nSi queremos obtener el primer maestro:\n\n<pre class=\"csharp\">\nvar maestro1 = q6.First();\n</pre> \n\n`First` también acepta una condicional, digamos que queremos obtener el primer maestro que tiene como nombre \"Cosme Fulanito\":\n\n<pre class=\"csharp\">\nvar cosmeFulanito = q6.First(m => m.GivenName == \"Cosme\" && m.LastName == \"Fulanito\");\n</pre> \n\nCon este tipo de operaciones debemos ser muy cuidadosos, porque en el ejemplo pasado, al no existir un maestro llamado \"Cosme Fulanito\", el método `First` lanza una excepción del tipo `InvalidOperationException`, lo cual ocurre si el conjunto sobre el que operamos no contiene elemento alguno que cumpla la condición (o si no indicamos condición basta con que el conjunto esté vacío).  \n  \nPara evitar la excepción podemos usar el método `FirstOrDefault` el cual regresará el valor por default del elemento del conjunto sobre el que trabajamos, hay que recordar que el valor por default de un tipo por referencia es `null`:\n\n<pre class=\"csharp\">\nvar cosmeFulanito2 = q6.FirstOrDefault(m => m.GivenName == \"Cosme\" && m.LastName == \"Fulanito\");\n</pre> \n\n### Single\n\nAdicionalmente a `First`, también existe el método `Single` y `SingleOrDefault` **pero solamente deben ser usados cuando el conjunto sobre el que operan únicamente contiene 1 solo elemento**, ya que de otro modo obtendremos una espantosa excepción, por ejemplo, si ejecutáramos `Single` sobre `q6` obtendríamos una excepción porque tenemos más de 1 maestro en nuestra base de datos falsa:\n\n<pre class=\"csharp\">\nvar maestro3 = q6.Single(); // Excepción porque q6 contiene más de 1 elemento\n</pre> \n \nTal vez te estés preguntando para qué existe `Single` si ya existe `First` y yo al igual que muchos coincido en que todo es cuestión de semántica en nuestro código. Si queremos dejar claro que una consulta a la base de datos, a un XML o a cualquier otra cosa a través de Linq debe siempre regresar un solo resultado debemos usar `Single`, si esperamos obtener el primer resultado de un conjunto más grande debemos usar `First`.  \n  \n### ElementAt  \nNo no siempre vamos a necesitar el primer elemento de una colección, tal vez estemos buscando el segundo, el décimo o el noningentésimo... uno nunca sabe. Para realizar esta tarea tenemos a nuestra mano el método `ElementAt` que obtiene el elemento colocado en la posición especificada mediante un entero:  \n\n<pre class=\"csharp\">\nvar maestroSegundo = q6.ElementAt(2);\n\nvar maestroDecimo = q6.ElementAt(10);\n</pre> \n\nEn este caso también debemos ser cuidadosos ya que, si nuestro conjunto no contiene al menos la cantidad de elementos necesaria para cumplir nuestra petición, obtendremos otra excepción, en este caso una del tipo `ArgumentOutOfRangeException`, así pues que cuando se solicita al maestro 900 obtendremos el error:\n \n<pre class=\"csharp\">\nvar maestroNoningentesimo = q6.ElementAt(900); // Excepción ¡porque q6 no tiene 900 maestros!\n</pre> \n    \n#### Lo que sigue  \nAún quedan algunas cuantas herramientas de Linq por demostrar, entre ellas las intersecciones, uniones y demás operaciones sobre conjuntos que se pueden realizar. Sin duda espero haberte convencido (o demostrado) que el poder de esta característica que nos ofrece .NET es bastante bueno y que no debe pasarse por alto cuando desarrollas. Como siempre, recuerda que todo el código fuente de este post está en la información (cerca del título)."
}