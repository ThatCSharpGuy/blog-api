{	
	"id" : "/post/genericos-c-sharp-clases/",
	"tv" : false,
	"date": "2016-06-12 14:00:01 -0500",
	"title" : "Clases genéricas en C#",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//aprende-c-sharp/generics-es.png",
	"tags" : ["AprendeCSharp"],
	"content": "Más de C#. En este post toca hablar sobre los genéricos\n\nLos genéricos, y más concretamente en este post los tipos genéricos, son un mecanismo de C# que nos ayuda a maximizar la reutilización de código. La reutilización de código se logra a través de el uso de plantillas (*templates*) de código en las cuales se insertan marcadores (*placeholders*) que representarán los tipos de dato que usaremos en nuestra plantilla.\n\n## Sintaxis\n\nLa declaración de tipos genéricos se realiza casi como cualquier otro tipo, con la diferencia de que tenemos que declarar los *placeholders* entre signos `<` y `>`, por ejemplo, \n\n<pre class=\"csharp\">\npublic class Box<T>\n</pre>   \n\nEn la cual le estamos indicando que usaremos un marcador llamado `T`. Que se lee como \"Box de T\". Luego entonces dentro de la declaración de la clase podemos reutilizar el marcador `T` tantas veces como queramos:\n\n<pre class=\"csharp\">\n    public T Content  get; private set; \n\n    public  Box(T content)\n    \n        Content = content;\n    \n</pre>  \n\nPara hacer uso de un tipo genérico la sintaxis es más o menos igual a cualquier tipo por referencia: debemos usar el operador `new`, el constructor de la clase e indicarle dentro de `<` y `>` los tipos con los que queremos que se reemplaze el marcador.\n\n<pre class=\"csharp\">\nvar cajaDeEntero = new Box<int>(5);\nvar cajaDeString = new Box<string>(\"Hola mundo\");\n\nConsole.WriteLine(cajaDeEntero.Content); // 5\nConsole.WriteLine(cajaDeString.Content); // Hola mundo\n</pre>  \n\nTambién podemos anidar declaraciones en los tipos genéricos:\n\n<pre class=\"csharp\">\nvar cajaDeCajas = new Box<Box<string>>(cajaDeString);\nConsole.WriteLine(cajaDeCajas); // [Box: Content=[Box: Content=Hola mundo]]\n</pre>  \n\nNo hay \"límite\" en cuanto al nombre o cantidad de tipos que podemos usar, por ejemplo:\n\n<pre class=\"csharp\">\npublic class ComplexBox<T, Content1, Content2>\n\n    public Content1 C1  get; set; \n    public Content2 C2  get; set; \n    public T Item  get; set; \n\n    public ComplexBox(Content1 c1, Content2 c2)\n    \n        C1 = c1;\n        C2 = c2;\n    \n\n\n// ...\n\nvar cajota = new ComplexBox<double, decimal, float>(1, 2)\n\n    Item = 3\n;\n</pre>  \n\n### Restricción where  \n\nDe entrada, si solo especificamos de esta manera `Box<T>` los genéricos, podríamos crear objetos a partir de `Box` sin limitacio\n\nEs por eso que usando la cláusula *where X : [Condición]* podemos limitar qué tipo de datos aceptará nuestro tipo genérico como *marcadores*, por ejemplo, supongamos que tenemos las clases:\n\n<pre class=\"csharp\">\npublic class LimitedBox<T> where T : struct\n    // ...\n\npublic class LimitedBox<X0,X1> \n    where X0 : struct\n    where X1 : IEquatable<X1>\n    // ...\n\npublic class LimitedBox<T, U, V>\n    where T : struct\n    where U : IEquatable<U>\n    where V : new()\n    // ...\n</pre>  \n\nEstamos limitando a que:\n\n  - `LimitedBox<T>` únicamente acepte en `T`, tipos que sean `struct` como `decimal` y `DateTime`\n  - `LimitedBox<X0, X1>` únicamente acepte en `X0`, tipos que sean `struct` como `decimal` y `DateTime` y en `X1` objetos que implementen la interfaz `IEquatable`\n  - `LimitedBox<T, U, V>` similar al anterior, solo que en el tercer parámetro, `V`, únicamente aceptará objetos que tengan un constructor vacío que se a público\n\nLa lista completa de restricciones se encuentra en <a href=\"https://msdn.microsoft.com/en-us/library/d5x73970.aspx\" target=\"_blank\" rel=\"nofollow\">este enlace</a>.\n\n### Ejemplos  \n\nPero bueno, veamos un ejemplo. \n\nImaginate un programa para gestionar un deportivo, en el que existen equipos de futbol y de béisbol, compuestos por atletas, `Athlete`, (que a su vez se divide en futbolistas, `FootballPlayer`, y por beisbolistas, `BaseballPlayer`):\n\n<pre class=\"csharp\">\npublic class Athlete\n\n    public string Name  get; set; \n    public double Height  get; set; \n    public double Weight  get; set; \n\n</pre>  \n\n<div class=\"pure-g\">\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\npublic class FootballPlayer : Athlete\n\n    public string Position  get; set; \n    public int Goals  get; set;  \n\n</pre>  \n</div>\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\npublic class BaseballPlayer : Athlete\n\n    public string Position  get; set; \n    public int GamesStarted  get; set;   \n\n</pre>  \n</div>  \n</div>\n\nAhora, para crear los equipos podríamos tener clases separadas para representar cada equipo:\n\n<div class=\"pure-g\">\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\npublic class BaseballTeam\n\n    public string CoachName  get; set; \n    public BaseballPlayer[] Members  get; set; \n\n    public BaseballTeam(int maxMembers)\n    \n        Members = new BaseballPlayer[maxMembers];\n    \n\n</pre>  \n</div>\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\npublic class FootballTeam\n\n    public string CoachName  get; set; \n    public FootballPlayer[] Members  get; set; \n\n    public FootballTeam(int maxMembers)\n    \n        Members = new FootballPlayer[maxMembers];\n    \n\n</pre>  \n</div>  \n</div>\n\nY para crear equipos tendríamos que hacer algo así:\n\n<pre class=\"csharp\">\nvar vitesse = new FootballTeam(18); \nvitesse.Members[0] = new FootballPlayer  Name = \"Alex Renato Ibarra Mina\" ;\n        \nvar losAngeles = new BaseballTeam(25);\nlosAngeles.Members[0] = new BaseballPlayer  Name = \"Julio César Urías\" ;\n</pre>  \n\n### Genéricos  \n\nO, para maximizar la reutilización de código, podríamos crear una clase genérica, digamos `Team<T>` (\"Team de T\"), para poder reutilizarla (y no solo con equipos de futbol o beisbol):\n\n<pre class=\"csharp\">\npublic class Team<T>\n\n    public string CoachName  get; set; \n    public T[] Members  get; set; \n\n    public Team(int maxMembers)\n    \n        Members = new T[maxMembers];\n    \n\n</pre>  \n\nY usarlo de esta manera:\n\n<pre class=\"csharp\">\nvar vitesse = new Team<FootballPlayer>(18);\nvitesse.Members[0] = new FootballPlayer  Name = \"Alex Renato Ibarra Mina\" ;\n\nvar losAngeles = new Team<BaseballPlayer>(25);\nlosAngeles.Members[0] = new BaseballPlayer  Name = \"Julio César Urías\" ;\n</pre>  \n\nSi dejamos la clase `Team<T>` como está, podríamos hacer cosas como esta:  \n\n<pre class=\"csharp\">\nvar equipoDeEnteros = new Team<int>(10);\nvar otroEquipo = new Team<object>(1233);\n</pre>  \n\nQue tal vez no tienen mucho sentido en nuestra aplicación. Es por eso que usando la restricción `where` podemos limitar al tipo `Team<T>` para que únicamente acepte `Athlete`s:\n\n<pre class=\"csharp\">\npublic class Team<T> where T : Athlete\n</pre>  \n\n## Ejemplos del Framework\n\nEn el Framework .NET existen numerosos ejemplos de tipos genéricos, siendo el más usado y conocido, las <a href=\"https://msdn.microsoft.com/es-es/library/bb762916(v=vs.110).aspx\" target=\"_blank\" rel=\"nofollow\">colecciones genéricas</a> y las <a href=\"../tuples-c-sharp\">tuplas en C#</a>.\n\n## Para cerrar\n\nUsar los genéricos permiten dos cosas: Incrementar la reutilización de código manteniendo el tipado fuerte y reducir el impacto al desempeño en nuestras apps al evitar el <a href=\"https://msdn.microsoft.com/en-us/library/yz2be5wk.aspx\" target=\"_blank\" rel=\"nofollow\">boxing y unboxing</a>, de ahí la importancia de su existencia.\n\nAdemás, los genéricos existen también para métodos, post sobre el que estaré escribiendo en el futuro."
}