{	
	"id" : "/post/commonmark/",
	"tv" : false,
	"date": "2016-09-05 14:00:01 -0500",
	"title" : "CommonMark.NET",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//commonmark/featured.png",
	"tags" : ["NuGetRecomendado"],
	"content": "<p>De nuevo un <a href=\"#\">#NuGetRecomendado</a>, esta vez hablaré de uno que tiene un caso muy específico de uso.</p>\n\n<p>Seguramente habrás escuchado sobre Markdown, que es un lenguaje de marcado entendible fácilmente para los humanos (a diferencia de XML). Este lenguaje es principalmente usado para la creación de documentos HTML a partir de otros con el formato Markdown.</p>\n\n<p>El formato fue creado por <a href=\"https://web.archive.org/web/20040402080322/http://www.aaronsw.com/weblog/001189\" target=\"_blank\">John Gruber y Aaron Swartz</a> con la idea de tener una forma sencilla de escribir un email, un post de blog (como este que estás leyendo), una respuesta en un foro o sitio web, usando una <a href=\"https://daringfireball.net/projects/markdown/syntax\" target=\"_blank\">sintaxis simple</a> y no tan invasiva con el documento. Una vez escrito el documento es necesario hacerlo pasar por un proceso de conversión a HTML.</p>\n\n<p>Este NuGet realiza precisamente eso: la conversión de Markdown a HTML.</p>\n\n<h2 id=\"cdigo\">Código</h2>\n<p>Para el siguiente ejemplo, vamos a trabajar con el archivo llamado <code>input.md</code> cuyo contenido es:</p>\n\n<pre>\nHello world\n=  \n\nVisita el post del [blog](http://thatcsharpguy.com/post/commonmark) para **saber más** sobre *CommonMark.NET*  \n</pre>\n\n<h3 id=\"convert-strings\">Convert (Strings)</h3>\n<p>Si lo único que quieres es convertir En realidad la api de CommonMark es una de las más sencillas, el siguiente bloque de código convierte una cadena de texto (Markdown) en otra cadena de texto (HTML):</p>\n\n<pre class=\"csharp\">\nvar file = File.ReadAllText(\"input.md\");\nvar exp = CommonMark.CommonMarkConverter.Convert(file);\nConsole.WriteLine(exp);\n</pre>\n\n<p>El resultado:</p>\n\n<pre>\n&lt;h1&gt;Hello world&lt;/h1&gt;\n&lt;p&gt;Visita el post del &lt;a href=&quot;http://thatcsharpguy.com/post/commonmark&quot;&gt;blog&lt;/a&gt; para &lt;strong&gt;saber m&#225;s&lt;/strong&gt; sobre &lt;em&gt;CommonMark.NET&lt;/em&gt;&lt;/p&gt;\n</pre>\n\n<h3 id=\"convert-streams\">Convert (Streams)</h3>\n<p>Habrá ocasiones en las que necesitemos convertir archivos completos y hacerlo usando <em>streams</em> de datos, para esto, el método <code>Convert</code> tiene otra sobrecarga que permite realizar esta tarea. Previamente necesitamos abrir los flujos de datos (yo recomiendo hacerlo con <a href=\"../usos-using-2\">el bloque using</a>):</p>\n\n<pre class=\"csharp\">\nusing (var reader = new StreamReader(\"input.md\"))\nusing (var writer = new StreamWriter(\"output.html\"))\n\n    CommonMark.CommonMarkConverter.Convert(reader, writer);\n\n</pre>\n\n<p>Tras lo cual, si abrimos el archivo <code>output.html</code> con un navegador, veremos algo como lo siguiente:</p>\n\n<p>post_image raw_output.png “Salida”</p>\n\n<p>Sin embargo, de esta forma lo único que estamos haciendo es escribiendo algunas etiquetas HTML en el documento de salida, falta escribir los tags <code>html</code>, <code>head</code>, <code>body</code>… entre otros para que el HTML sea válido.</p>\n\n<h3 id=\"convert-conversin-personalizada\">Convert (conversión personalizada)</h3>\n<p>Para nuestra suerte, el desarrollador de CommonMark, nos permite configurar la forma en la que se <em>renderea</em>\n el resultado de la conversión. Esto, a través de la clase <code>CommonMarkSettings</code> y un derivado de <code>HtmlFormatter</code>:</p>\n\n<pre class=\"csharp\">\nclass CustomHtmlFormatter : CommonMark.Formatters.HtmlFormatter\n\n    // ... \n</pre>\n\n<h4 id=\"writeinline\">WriteInline</h4>\n<p>El método <code>WriteInline</code>, que permite modificar la manera en que se <em>renderea</em> un elemento en HTML. en el ejemplo siguiente se modifica la forma en la que se escriben las etiquetas <code>a</code> para que los enlaces se abran en una nueva pestaña:</p>\n\n<pre class=\"csharp\">\n    protected override void WriteInline(Inline inline, bool isOpening, bool isClosing, out bool ignoreChildNodes)\n    \n        if (inline.Tag == InlineTag.Link) // Es enlace\n        \n            ignoreChildNodes = false; // Queremos seguir procesando los nodos hijo\n\n            //  Revisamos si es la etiqueta de apertura\n            if (isOpening)\n            \n                this.Write(\"&lt;a target=\\\"_blank\\\" href=\\\"\");\n                this.WriteEncodedUrl(inline.TargetUrl);\n                this.Write(\"\\\"&gt;\");\n            \n\n            //  Revisamos si es la etiqueta de cierre\n            if (isClosing)\n            \n                this.Write(\"\");\n            \n        \n        else\n        \n            // Usamos la implementación por default para otro los otros nodos\n            base.WriteInline(inline, isOpening, isClosing, out ignoreChildNodes);\n        \n    \n</pre>\n\n<h4 id=\"writeblock\">WriteBlock</h4>\n\n<p>Pero esta es solo una opción de configuración, ya que por otro lado podemos sobrescribir el método <code>WriteBlock</code> para escribir bloques completos. En este caso, usaremos el método para escribir un documento HTML válido:</p>\n\n<pre class=\"csharp\">\n    protected override void WriteBlock(Block block, bool isOpening, bool isClosing, out bool ignoreChildNodes)\n    \n        // Si es un tag de apertura y es Document\n        if (isOpening &amp;&amp; block.Tag == BlockTag.Document)\n        \n            this.Write(\"<html>\");\n            this.Write(\"<head>\\n&lt;meta charset=\\\"UTF-8\\\"&gt;\\n&lt;link href=\\\"https://github.com/jasonm23/markdown-css-themes/raw/gh-pages/markdown6.css\\\" rel=\\\"stylesheet\\\" &gt;</head>\");\n            this.Write(\"<body>\");\n        \n        // Si es un tag de cierre y es Document\n        else if (isClosing &amp;&amp; block.Tag == BlockTag.Document)\n        \n            this.Write(\"</body></html>\");\n        \n\n        // LLamamos a la implementación por default para procesar los otros nodos\n        base.WriteBlock(block, isOpening, isClosing, out ignoreChildNodes);\n    \n</pre>\n\n<p>Tras lo cual, podrías tener algo como esto:</p>\n\n<p>post_image raw_output_2.png “Salida”</p>\n\n<p>Gran diferencia, ¿no?</p>\n\n<h2 id=\"casos-de-uso\">Casos de uso</h2>\n<p>Esta librería tiene una tarea en específico, y tal vez te resulte complicado encontrarle un uso, pero si como yo, estás <a href=\"#\" target=\"_blank\">creando un visor de Markdown</a> o, estás creando tu <a href=\"https://davidwalsh.name/introduction-static-site-generators\" target=\"_blank\">generador de sitios estáticos</a> (el blog usa jekyll, pero he pensado en crear un generador con C#).</p>\n\n<h2 id=\"conclusin\">Conclusión</h2>\n<p>Como pudiste observar, la API de CommonMark.NET es bastante sencilla de aprender y usar, en donde la cosa se puede tornar un poco complicada es cuando queremos personalizar el resultado final mediante la clase <code>CommonMarkSettings</code>.</p>\n\n<h1 id=\"instalacin\">Instalación</h1>\n<p>En el gestor de paquetes de NuGet: <code>CommonMark.NET</code></p>\n\n<p>O desde la consola:</p>\n\n<p>console titulo \nPM&gt; Install-Package CommonMark.NET\n endconsole</p>\n\n<p>Y al igual que con todos los NuGets, no olvides revisar el código fuente de <em>CommonMark.NET</em> <a href=\"https://github.com/Knagis/CommonMark.NET\" target=\"_blank\">en GitHub</a>, en donde encontrarás gran parte de la <a href=\"https://github.com/Knagis/CommonMark.NET/blob/master/CommonMark/Formatters/HtmlFormatter.cs\" target=\"_blank\">documentación en el código</a>, lo cual es absolutamente fantástico.</p>\n"
}