{	
	"id" : "/post/commonmark/",
	"tv" : false,
	"date": "2016-09-05 14:00:01 -0500",
	"title" : "CommonMark.NET",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//commonmark/featured.png",
	"tags" : ["NuGetRecomendado"],
	"content": "De nuevo un <a href=\"#\">#NuGetRecomendado</a>, esta vez hablaré de uno que tiene un caso muy específico de uso.\n\nSeguramente habrás escuchado sobre Markdown, que es un lenguaje de marcado entendible fácilmente para los humanos (a diferencia de XML). Este lenguaje es principalmente usado para la creación de documentos HTML a partir de otros con el formato Markdown.\n\nEl formato fue creado por <a href=\"https://web.archive.org/web/20040402080322/http://www.aaronsw.com/weblog/001189\" target=\"_blank\">John Gruber y Aaron Swartz</a> con la idea de tener una forma sencilla de escribir un email, un post de blog (como este que estás leyendo), una respuesta en un foro o sitio web, usando una <a href=\"https://daringfireball.net/projects/markdown/syntax\" target=\"_blank\">sintaxis simple</a> y no tan invasiva con el documento. Una vez escrito el documento es necesario hacerlo pasar por un proceso de conversión a HTML.\n\nEste NuGet realiza precisamente eso: la conversión de Markdown a HTML.\n\n## Código  \nPara el siguiente ejemplo, vamos a trabajar con el archivo llamado `input.md` cuyo contenido es:  \n  \n<pre>\nHello world\n=  \n\nVisita el post del [blog](http://thatcsharpguy.com/post/commonmark) para **saber más** sobre *CommonMark.NET*  \n</pre>    \n\n### Convert (Strings)\nSi lo único que quieres es convertir En realidad la api de CommonMark es una de las más sencillas, el siguiente bloque de código convierte una cadena de texto (Markdown) en otra cadena de texto (HTML):\n\n<pre class=\"csharp\">\nvar file = File.ReadAllText(\"input.md\");\nvar exp = CommonMark.CommonMarkConverter.Convert(file);\nConsole.WriteLine(exp);\n</pre>  \n\nEl resultado:  \n\n<pre>\n&lt;h1&gt;Hello world&lt;/h1&gt;\n&lt;p&gt;Visita el post del &lt;a href=&quot;http://thatcsharpguy.com/post/commonmark&quot;&gt;blog&lt;/a&gt; para &lt;strong&gt;saber m&#225;s&lt;/strong&gt; sobre &lt;em&gt;CommonMark.NET&lt;/em&gt;&lt;/p&gt;\n</pre>\n\n### Convert (Streams)\nHabrá ocasiones en las que necesitemos convertir archivos completos y hacerlo usando *streams* de datos, para esto, el método `Convert` tiene otra sobrecarga que permite realizar esta tarea. Previamente necesitamos abrir los flujos de datos (yo recomiendo hacerlo con <a href=\"../usos-using-2\">el bloque using</a>):\n\n<pre class=\"csharp\">\nusing (var reader = new StreamReader(\"input.md\"))\nusing (var writer = new StreamWriter(\"output.html\"))\n\n    CommonMark.CommonMarkConverter.Convert(reader, writer);\n\n</pre>  \n\nTras lo cual, si abrimos el archivo `output.html` con un navegador, veremos algo como lo siguiente:  \n\n post_image raw_output.png \"Salida\" \n\nSin embargo, de esta forma lo único que estamos haciendo es escribiendo algunas etiquetas HTML en el documento de salida, falta escribir los tags `html`, `head`, `body`... entre otros para que el HTML sea válido.  \n\n### Convert (conversión personalizada)\nPara nuestra suerte, el desarrollador de CommonMark, nos permite configurar la forma en la que se *renderea*\n el resultado de la conversión. Esto, a través de la clase `CommonMarkSettings` y un derivado de `HtmlFormatter`:\n\n<pre class=\"csharp\">\nclass CustomHtmlFormatter : CommonMark.Formatters.HtmlFormatter\n\n    // ... \n</pre>  \n\n#### WriteInline  \nEl método `WriteInline`, que permite modificar la manera en que se *renderea* un elemento en HTML. en el ejemplo siguiente se modifica la forma en la que se escriben las etiquetas `a` para que los enlaces se abran en una nueva pestaña:\n\n<pre class=\"csharp\">\n    protected override void WriteInline(Inline inline, bool isOpening, bool isClosing, out bool ignoreChildNodes)\n    \n        if (inline.Tag == InlineTag.Link) // Es enlace\n        \n            ignoreChildNodes = false; // Queremos seguir procesando los nodos hijo\n\n            //  Revisamos si es la etiqueta de apertura\n            if (isOpening)\n            \n                this.Write(\"<a target=\\\"_blank\\\" href=\\\"\");\n                this.WriteEncodedUrl(inline.TargetUrl);\n                this.Write(\"\\\">\");\n            \n\n            //  Revisamos si es la etiqueta de cierre\n            if (isClosing)\n            \n                this.Write(\"</a>\");\n            \n        \n        else\n        \n            // Usamos la implementación por default para otro los otros nodos\n            base.WriteInline(inline, isOpening, isClosing, out ignoreChildNodes);\n        \n    \n</pre>   \n\n#### WriteBlock\n\nPero esta es solo una opción de configuración, ya que por otro lado podemos sobrescribir el método `WriteBlock` para escribir bloques completos. En este caso, usaremos el método para escribir un documento HTML válido:  \n\n<pre class=\"csharp\">\n    protected override void WriteBlock(Block block, bool isOpening, bool isClosing, out bool ignoreChildNodes)\n    \n        // Si es un tag de apertura y es Document\n        if (isOpening && block.Tag == BlockTag.Document)\n        \n            this.Write(\"<html>\");\n            this.Write(\"<head>\\n<meta charset=\\\"UTF-8\\\">\\n<link href=\\\"https://github.com/jasonm23/markdown-css-themes/raw/gh-pages/markdown6.css\\\" rel=\\\"stylesheet\\\" ></head>\");\n            this.Write(\"<body>\");\n        \n        // Si es un tag de cierre y es Document\n        else if (isClosing && block.Tag == BlockTag.Document)\n        \n            this.Write(\"</body></html>\");\n        \n\n        // LLamamos a la implementación por default para procesar los otros nodos\n        base.WriteBlock(block, isOpening, isClosing, out ignoreChildNodes);\n    \n</pre>\n\nTras lo cual, podrías tener algo como esto:\n\n post_image raw_output_2.png \"Salida\" \n\nGran diferencia, ¿no?\n\n## Casos de uso  \nEsta librería tiene una tarea en específico, y tal vez te resulte complicado encontrarle un uso, pero si como yo, estás <a href=\"#\" target=\"_blank\">creando un visor de Markdown</a> o, estás creando tu <a href=\"https://davidwalsh.name/introduction-static-site-generators\" target=\"_blank\">generador de sitios estáticos</a> (el blog usa jekyll, pero he pensado en crear un generador con C#).\n\n## Conclusión  \nComo pudiste observar, la API de CommonMark.NET es bastante sencilla de aprender y usar, en donde la cosa se puede tornar un poco complicada es cuando queremos personalizar el resultado final mediante la clase `CommonMarkSettings`.\n \n# Instalación  \nEn el gestor de paquetes de NuGet: `CommonMark.NET`\n\nO desde la consola: \n\n console titulo \nPM> Install-Package CommonMark.NET\n endconsole \n\nY al igual que con todos los NuGets, no olvides revisar el código fuente de *CommonMark.NET* <a href=\"https://github.com/Knagis/CommonMark.NET\" target=\"_blank\" >en GitHub</a>, en donde encontrarás gran parte de la <a href=\"https://github.com/Knagis/CommonMark.NET/blob/master/CommonMark/Formatters/HtmlFormatter.cs\" target=\"_blank\">documentación en el código</a>, lo cual es absolutamente fantástico.  \n"
}