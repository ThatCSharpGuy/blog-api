{	
	"id" : "/post/multiselect-listview-mvvm/",
	"tv" : false,
	"date": "2016-03-23 02:00:00 -0600",
	"title" : "Multi-select ListView y MVVM",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//xamarin-forms/multiselect-featured.png",
	"tags" :
	["XamarinForms","Xamarin"],
	
	"content" : body"Por fin he vuelto a desarrollar algo con Xamarin.Forms y parte de lo que he tenido que hacer tuvo que ver con implementar una lista que permitiera la selección múltiple de filas y fuera compatible con el patrón MVVM.  \n\nInvestigando un poco encontré que el control `ListView`, que es el más usado para mostrar datos en forma de lista, no permite la selección múltiple y que habría que hacerlo de otra manera. Dentro de la documentación de Xamarin también <a href=\"https://developer.xamarin.com/recipes/cross-platform/xamarin-forms/controls/multiselect/\" target=\"_blank\" rel=\"nofollow\">este artículo</a> en el que explica una forma de hacerlo y en ese está basado este post.  \n  \nPara llevar a cabo la tarea, debemos tomar en cuenta que necesitaremos de algunas clases auxiliares que explicaré a detalle más adelante.\n\n### El modelo  \nPara este ejemplo vamos a mostrar una lista de Pokemons y permitiremos al usuario seleccionar varios de ellos a través de una lista, la clase de nuestro modelo es la siguiente:\n\n{% highlight csharp %}\npublic class Pokemon \n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public double Weight { get; set; }\n    public double Height { get; set; }\n}\n{% endhighlight %}  \n\n### SelectableItemWrapper&lt;T&gt;\nAdicionalmente al modelo, también es necesario esta clase auxiliar que como el nombre lo indica, es una envoltura para nuestro modelo, la definición es la siguiente:\n\n{% highlight csharp %}\npublic class SelectableItemWrapper<T>\n{\n    public bool IsSelected { get; set; }\n    public T Item { get; set; }\n}\n{% endhighlight %}    \n\nLa propiedad `IsSelected` servirá para determinar si el usuario seleccionó el ítem o no, mientras que `Item` contendrá el modelo.\n\n## La vista\n(If you prefer to work with XAML, <a href=\"//thatcsharpguy.com/post/multiselect-listview-mvvm-en\">see this post</a>)\n\nUsaremos dos páginas de Forms, una donde mostraremos todos los Pokemon y otra donde se mostrarán únicamente los que el usuario eligió.  \n\nPara la primera, donde estarán todos los Pokemon, debemos modificar un poco la forma en la que estamos acostumbrados a crear los templates para las celdas de la lista, y es que necesitamos tomar en cuenta que cada fila de la lista estará ligado a un `SelectableItemWrapper<Pokemon>` y no a un `Pokemon`.  \n\nDeclararemos la lista y pondremos la colección `Pokemons`, definida más adelante en el ViewModel, como la fuente de ítems:\n\n{% highlight csharp %}\nvar list = new ListView();\nlist.SetBinding(ListView.ItemsSourceProperty, \"Pokemons\");\n{% endhighlight %}  \n\nComo sabemos, ahora cada uno de los elementos de la colección será una celda en la lista.\n\n#### PokemonSelectableCell\nPara esta celda es necesario que se muestre el nombre, el peso y la altura, además de un control para permitir que dicho pokemon sea seleccionable, es por eso que se crean las propiedades *bindeables* necesarias.  \n\nEs por eso que se crean tres etiquetas para mostrar la información y en este caso se hará uso de `Switch`, que llamaremos `sw`, para marcar la selección de cada uno (intenté usar el <a href=\"https://github.com/XLabs/Xamarin-Forms-Labs/wiki/Checkbox-Control\" target=\"_blank\" rel=\"nofollow\">CheckBox de XLabs</a>, pero encontré un pequeño bug con las listas).  \n\nTu puedes diseñar tu celda como quieras, pero es importante que dentro de ella *bindees* o ligues una propiedad booleana, como `IsToggled` o `Checked`, a la propiedad `IsSelected` de la clase `SelectableItemWrapper`. Bastará con una línea así:\n\n{% highlight csharp %}\n// Important:\nsw.SetBinding(Switch.IsToggledProperty, \"IsSelected\");\n{% endhighlight %}  \n\nEs importante señalar que dicho *binding* está definido en la implementación de la celda y no en el código de la vista.\n\n### Volviendo a la vista\nYa de vuelta en la vista, podemos hacer uso de la celda en nuestra `ListView`, podemos definir los otros *bindings*:\n\n{% highlight csharp %}\nvar template = new DataTemplate(typeof(PokemonSelectableCell));\ntemplate.SetBinding(PokemonSelectableCell.NameProperty, \"Item.Name\");\ntemplate.SetBinding(PokemonSelectableCell.WeightProperty, \"Item.Weight\");\ntemplate.SetBinding(PokemonSelectableCell.HeightProperty, \"Item.Height\");\nlist.ItemTemplate = template;\n{% endhighlight %}  \n\nPodrás notar que la ruta del *binding* no es \"directa\", si no que primero nos estamos refiriendo a la propiedad `Item` y luego a las propiedades \"reales\" y esto es porque estamos *bindeando* un `SelectableItemWrapper<Pokemon>` y no una instancia de `Pokemon`. \n\n### El ViewModel\nPara el ViewModel requeriremos dos colecciones:  \n  \n - Una para contener una lista de todos los elementos \n - Una para contener los elementos seleccionados  \n \n Sus definiciones son las siguientes:\n \n {% highlight csharp %}\nprivate ObservableCollection<SelectableItemWrapper<Pokemon>> _pokemons;\npublic ObservableCollection<SelectableItemWrapper<Pokemon>> Pokemons\n{\n    get { return _pokemons; }\n    set { _pokemons = value; RaisePropertyChanged(); }\n}\n\nprivate ObservableCollection<Pokemon> _selectedPokemons;\npublic ObservableCollection<Pokemon> SelectedPokemons\n{\n    get { return _selectedPokemons; }\n    private set { _selectedPokemons = value; RaisePropertyChanged(); }\n}\n{% endhighlight %}  \n\nLa primera, `Pokemons` es una `ObservableCollection` de `SelectableItemWrapper` de `Pokemon` ya que es la contiene los elementos que serán seleccionables. Mientras que la segunda es una colección como cualquier otra.\n\nEntonces, en el ViewModel podemos obtener todos los elementos seleccionados usando Linq:\n\n{% highlight csharp %}\nObservableCollection<Pokemon> GetSelectedPokemons()\n{\n    var selected = Pokemons\n        .Where(p => p.IsSelected)\n        .Select(p => p.Item)\n        .ToList();   \n    return new ObservableCollection<Pokemon>(selected);\n}\n{% endhighlight %}  \n\nMarcar o desmarcar todos los elementos como seleccionados:\n\n{% highlight csharp %}\nvoid SelectAll(bool select)\n{\n    foreach (var p in Pokemons)\n    {\n        p.IsSelected = select;\n    }\n}\n{% endhighlight %}  \n\nY todo, desde el ViewModel. Recuerda, puedes <a href=\"https://github.com/ThatCSharpGuy/MultiPokeList\" target=\"_blank\">ver el código fuente</a>. Y también puedes ver un ejemplo de la app terminada:\n\n<img src=\"http://i.giphy.com/qpfRFj3MrFqow.gif\" title=\"Multi-select ListView y MVVM\" />\n\n#### Créditos\nLa clase `SelectMultipleBasePage<T>` en la que está completamente basada la información de este post, fue escrita por Glenn Stephens de la  Xamarin University, <a href=\"https://developer.xamarin.com/recipes/cross-platform/xamarin-forms/controls/multiselect/\" target=\"_blank\" rel=\"nofollow\">mira el post original</a>.\n"
}