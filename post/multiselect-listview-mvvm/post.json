{	
	"id" : "/post/multiselect-listview-mvvm/",
	"tv" : false,
	"date": "2016-03-23 02:00:00 -0600",
	"title" : "Multi-select ListView y MVVM",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//xamarin-forms/multiselect-featured.png",
	"tags" : ["XamarinForms","Xamarin"],
	  
	"content": '"Por fin he vuelto a desarrollar algo con Xamarin.Forms y parte de lo que he tenido que hacer tuvo que ver con implementar una lista que permitiera la selección múltiple de filas y fuera compatible con el patrón MVVM.  \n\nInvestigando un poco encontré que el control `ListView`, que es el más usado para mostrar datos en forma de lista, no permite la selección múltiple y que habría que hacerlo de otra manera. Dentro de la documentación de Xamarin también <a href=\"https://developer.xamarin.com/recipes/cross-platform/xamarin-forms/controls/multiselect/\" target=\"_blank\" rel=\"nofollow\">este artículo</a> en el que explica una forma de hacerlo y en ese está basado este post.  \n  \nPara llevar a cabo la tarea, debemos tomar en cuenta que necesitaremos de algunas clases auxiliares que explicaré a detalle más adelante.\n\n### El modelo  \nPara este ejemplo vamos a mostrar una lista de Pokemons y permitiremos al usuario seleccionar varios de ellos a través de una lista, la clase de nuestro modelo es la siguiente:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npublic</span> <span class="k">class</span> <span class="nc">Pokemon</span> <span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span><span class="err">\</span><span class="n">n</span>    <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span><span class="err">\</span><span class="n">n</span>    <span class="k">public</span> <span class="kt">double</span> <span class="n">Weight</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span><span class="err">\</span><span class="n">n</span>    <span class="k">public</span> <span class="kt">double</span> <span class="n">Height</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span><span class="err">\</span><span class="n">n</span><span class="p">}</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\n### SelectableItemWrapper&lt;T&gt;\nAdicionalmente al modelo, también es necesario esta clase auxiliar que como el nombre lo indica, es una envoltura para nuestro modelo, la definición es la siguiente:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npublic</span> <span class="k">class</span> <span class="nc">SelectableItemWrapper</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="k">public</span> <span class="kt">bool</span> <span class="n">IsSelected</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span><span class="err">\</span><span class="n">n</span>    <span class="k">public</span> <span class="n">T</span> <span class="n">Item</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span><span class="err">\</span><span class="n">n</span><span class="p">}</span><span class="err">\</span><span class="n">n</span></code></pre></figure>    \n\nLa propiedad `IsSelected` servirá para determinar si el usuario seleccionó el ítem o no, mientras que `Item` contendrá el modelo.\n\n## La vista\n(If you prefer to work with XAML, <a href=\"//thatcsharpguy.com/post/multiselect-listview-mvvm-en\">see this post</a>)\n\nUsaremos dos páginas de Forms, una donde mostraremos todos los Pokemon y otra donde se mostrarán únicamente los que el usuario eligió.  \n\nPara la primera, donde estarán todos los Pokemon, debemos modificar un poco la forma en la que estamos acostumbrados a crear los templates para las celdas de la lista, y es que necesitamos tomar en cuenta que cada fila de la lista estará ligado a un `SelectableItemWrapper<Pokemon>` y no a un `Pokemon`.  \n\nDeclararemos la lista y pondremos la colección `Pokemons`, definida más adelante en el ViewModel, como la fuente de ítems:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">list</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ListView</span><span class="p">();</span><span class="err">\</span><span class="n">nlist</span><span class="p">.</span><span class="n">SetBinding</span><span class="p">(</span><span class="n">ListView</span><span class="p">.</span><span class="n">ItemsSourceProperty</span><span class="p">,</span> <span class="err">\</span><span class="s">&quot;Pokemons\&quot;);\n</span></code></pre></figure>  \n\nComo sabemos, ahora cada uno de los elementos de la colección será una celda en la lista.\n\n#### PokemonSelectableCell\nPara esta celda es necesario que se muestre el nombre, el peso y la altura, además de un control para permitir que dicho pokemon sea seleccionable, es por eso que se crean las propiedades *bindeables* necesarias.  \n\nEs por eso que se crean tres etiquetas para mostrar la información y en este caso se hará uso de `Switch`, que llamaremos `sw`, para marcar la selección de cada uno (intenté usar el <a href=\"https://github.com/XLabs/Xamarin-Forms-Labs/wiki/Checkbox-Control\" target=\"_blank\" rel=\"nofollow\">CheckBox de XLabs</a>, pero encontré un pequeño bug con las listas).  \n\nTu puedes diseñar tu celda como quieras, pero es importante que dentro de ella *bindees* o ligues una propiedad booleana, como `IsToggled` o `Checked`, a la propiedad `IsSelected` de la clase `SelectableItemWrapper`. Bastará con una línea así:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">n</span><span class="c1">// Important:\nsw.SetBinding(Switch.IsToggledProperty, \&quot;IsSelected\&quot;);\n</span></code></pre></figure>  \n\nEs importante señalar que dicho *binding* está definido en la implementación de la celda y no en el código de la vista.\n\n### Volviendo a la vista\nYa de vuelta en la vista, podemos hacer uso de la celda en nuestra `ListView`, podemos definir los otros *bindings*:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">template</span> <span class="p">=</span> <span class="k">new</span> <span class="n">DataTemplate</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">PokemonSelectableCell</span><span class="p">));</span><span class="err">\</span><span class="n">ntemplate</span><span class="p">.</span><span class="n">SetBinding</span><span class="p">(</span><span class="n">PokemonSelectableCell</span><span class="p">.</span><span class="n">NameProperty</span><span class="p">,</span> <span class="err">\</span><span class="s">&quot;Item.Name\&quot;);\ntemplate.SetBinding(PokemonSelectableCell.WeightProperty, \&quot;Item.Weight\&quot;);\ntemplate.SetBinding(PokemonSelectableCell.HeightProperty, \&quot;Item.Height\&quot;);\nlist.ItemTemplate = template;\n</span></code></pre></figure>  \n\nPodrás notar que la ruta del *binding* no es \"directa\", si no que primero nos estamos refiriendo a la propiedad `Item` y luego a las propiedades \"reales\" y esto es porque estamos *bindeando* un `SelectableItemWrapper<Pokemon>` y no una instancia de `Pokemon`. \n\n### El ViewModel\nPara el ViewModel requeriremos dos colecciones:  \n  \n - Una para contener una lista de todos los elementos \n - Una para contener los elementos seleccionados  \n \n Sus definiciones son las siguientes:\n \n <figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nprivate</span> <span class="n">ObservableCollection</span><span class="p">&lt;</span><span class="n">SelectableItemWrapper</span><span class="p">&lt;</span><span class="n">Pokemon</span><span class="p">&gt;&gt;</span> <span class="n">_pokemons</span><span class="p">;</span><span class="err">\</span><span class="n">npublic</span> <span class="n">ObservableCollection</span><span class="p">&lt;</span><span class="n">SelectableItemWrapper</span><span class="p">&lt;</span><span class="n">Pokemon</span><span class="p">&gt;&gt;</span> <span class="n">Pokemons</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_pokemons</span><span class="p">;</span> <span class="p">}</span><span class="err">\</span><span class="n">n</span>    <span class="k">set</span> <span class="p">{</span> <span class="n">_pokemons</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span> <span class="n">RaisePropertyChanged</span><span class="p">();</span> <span class="p">}</span><span class="err">\</span><span class="n">n</span><span class="p">}</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">nprivate</span> <span class="n">ObservableCollection</span><span class="p">&lt;</span><span class="n">Pokemon</span><span class="p">&gt;</span> <span class="n">_selectedPokemons</span><span class="p">;</span><span class="err">\</span><span class="n">npublic</span> <span class="n">ObservableCollection</span><span class="p">&lt;</span><span class="n">Pokemon</span><span class="p">&gt;</span> <span class="n">SelectedPokemons</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_selectedPokemons</span><span class="p">;</span> <span class="p">}</span><span class="err">\</span><span class="n">n</span>    <span class="k">private</span> <span class="k">set</span> <span class="p">{</span> <span class="n">_selectedPokemons</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span> <span class="n">RaisePropertyChanged</span><span class="p">();</span> <span class="p">}</span><span class="err">\</span><span class="n">n</span><span class="p">}</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\nLa primera, `Pokemons` es una `ObservableCollection` de `SelectableItemWrapper` de `Pokemon` ya que es la contiene los elementos que serán seleccionables. Mientras que la segunda es una colección como cualquier otra.\n\nEntonces, en el ViewModel podemos obtener todos los elementos seleccionados usando Linq:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nObservableCollection</span><span class="p">&lt;</span><span class="n">Pokemon</span><span class="p">&gt;</span> <span class="n">GetSelectedPokemons</span><span class="p">()</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="kt">var</span> <span class="n">selected</span> <span class="p">=</span> <span class="n">Pokemons</span><span class="err">\</span><span class="n">n</span>        <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">IsSelected</span><span class="p">)</span><span class="err">\</span><span class="n">n</span>        <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">Item</span><span class="p">)</span><span class="err">\</span><span class="n">n</span>        <span class="p">.</span><span class="n">ToList</span><span class="p">();</span>   <span class="err">\</span><span class="n">n</span>    <span class="k">return</span> <span class="k">new</span> <span class="n">ObservableCollection</span><span class="p">&lt;</span><span class="n">Pokemon</span><span class="p">&gt;(</span><span class="n">selected</span><span class="p">);</span><span class="err">\</span><span class="n">n</span><span class="p">}</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\nMarcar o desmarcar todos los elementos como seleccionados:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvoid</span> <span class="n">SelectAll</span><span class="p">(</span><span class="kt">bool</span> <span class="k">select</span><span class="p">)</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">p</span> <span class="k">in</span> <span class="n">Pokemons</span><span class="p">)</span><span class="err">\</span><span class="n">n</span>    <span class="p">{</span><span class="err">\</span><span class="n">n</span>        <span class="n">p</span><span class="p">.</span><span class="n">IsSelected</span> <span class="p">=</span> <span class="k">select</span><span class="p">;</span><span class="err">\</span><span class="n">n</span>    <span class="p">}</span><span class="err">\</span><span class="n">n</span><span class="p">}</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\nY todo, desde el ViewModel. Recuerda, puedes <a href=\"https://github.com/ThatCSharpGuy/MultiPokeList\" target=\"_blank\">ver el código fuente</a>. Y también puedes ver un ejemplo de la app terminada:\n\n<img src=\"http://i.giphy.com/qpfRFj3MrFqow.gif\" title=\"Multi-select ListView y MVVM\" />\n\n#### Créditos\nLa clase `SelectMultipleBasePage<T>` en la que está completamente basada la información de este post, fue escrita por Glenn Stephens de la  Xamarin University, <a href=\"https://developer.xamarin.com/recipes/cross-platform/xamarin-forms/controls/multiselect/\" target=\"_blank\" rel=\"nofollow\">mira el post original</a>.\n"'   
}