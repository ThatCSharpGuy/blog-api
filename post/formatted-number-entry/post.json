{	
	"id" : "/post/formatted-number-entry/",
	"tv" : false,
	"date": "2016-08-01 03:00:00 -0500",
	"title" : "Formatted number entry",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//xamarin-forms/formattednumberentry/featured.png",
	"tags" :
	["XamarinForms","Xamarin"],
	
	"content" : body"While developing an app using Xamarin.Forms I faced with the necessity of having a \"formatted textbox\" where the user could enter a given integer number and have it formatted instantly to a comma separated number, for example: `1234567` → `1,234,567`, because our users often found themselves counting the number of zeros they had entered into the small textbox.  \n\nThis doesn't sound too complicated (and it isn't). Using an `Entry` we can easily hook up to the `TextChanged` event and perform the following tasks: \n\n 0. Stop listening for changes on our `Entry` `Text` property \n 1. Take the `Entry` text, lets name it `oldText`\n 2. Parse `oldText` into a number, lets name it `number`\n 3. Format `number`, and place the formatted text in `newText`\n 4. Set the `Text` property of our entry to `newText`\n 5. Start listening for changes on our `Entry` `Text` property\n\n\n I don't want to wire/unwire the event handler every time I use it, so let's create a control that inherits from `Entry` and override the `OnPropertyChanged` method:\n\n{% highlight csharp %}\npublic class FormattedNumberEntry : Entry\n{\n    protected override void OnPropertyChanged(string propertyName = null)\n    {\n        if (nameof(this.Text).Equals(propertyName))\n        {\n            if (!_shouldReactToTextChange) return;\n\n            _shouldReactToTextChange = false;\n\n            var oldText = this.Text;\n            var number = DumbParse(oldText);\n            var newText = $\"{number:#,###}\";\n\n            this.Text = newText;\n\n            _shouldReactToTextChange = true;\n        }\n        base.OnPropertyChanged(propertyName);\n    }\n}\n{% endhighlight %}  \n\nBy the way, you see that `DumbParse` method there? it is just that, a dumb parsing method that ignores non-digit chars:\n\n{% highlight csharp %}\npublic static int DumbParse(string input)\n{\n    var number = 0;\n    int multiply = 1;\n    for (int i = input.Length - 1; i >= 0; i--)\n    {\n        if (Char.IsDigit(input[i]))\n        {\n            number += (input[i] - '0') * (multiply);\n            multiply *= 10;\n        }\n    }\n    return number;\n}\n{% endhighlight %}  \n  \nThis is the final result:\n\n<img src=\"http://i.giphy.com/1zNrHjJ4dawbm.gif\" />\n\nThhat's it, we're done.\n\n\n## Noooooo, wait.\n\nEven though we may think that our mission was accomplished, our brand new control lacks of a good user experience. For example, see what happens when the user tries to erase a number located in the middle:\n\n{% post_image careterror.png \"Error\" %}  \n\nSee how the cursor jumps to the end (or start, depends on the platform)? the same happens after writing a number. Let's fix that.\n\n## Problem  \n\n`Entry` doesn't have a `CursorPosition` property so we need to create a simple <a href=\"https://developer.xamarin.com/guides/xamarin-forms/custom-renderer/\" target=\"_blank\" rel=\"nofollow\">custom renderer</a> since only at native level the underlying controls expose such information. In this case, we will attach an event handler to each platform specific *TextChanged* event and inside such handler we need to:  \n\n 0. Stop listening for changes on our control's `Text` property \n 1. Get the current cursor position\n 2. Take the control's text, lets name it `oldText`\n 3. Parse `oldText` into a number, lets name it `number`\n 4. Format `number`, and place the formatted text in `newText`\n 5. Set the `Text` property of our control to `newText`\n 6. Calculate the new cursor position\n 7. Set the new cursor position\n 8. Start listening for changes on our control's `Text` property\n\n### iOS \nFor iOS we will subscribe to the `EditingChanged` event and work all our magic there:\n\n{% highlight csharp %}\npublic class FormattedNumberEntryRenderer : EntryRenderer\n{\n    protected override void OnElementChanged(ElementChangedEventArgs<Entry> e)\n    {\n        base.OnElementChanged(e);\n\n        if (e.OldElement != null)\n        {\n            Control.EditingChanged -= Control_EditingChanged;\n        }\n        if (e.NewElement != null)\n        {\n            Control.EditingChanged += Control_EditingChanged;\n        }\n    }\n{% endhighlight %}  \n\nNow, in the `Control_EditingChanged`: \n\n{% highlight csharp %}\nvar element = ((FormattedNumberEntry)Element);\n// Oh boy, thank you internet: http://stackoverflow.com/a/34922332\n\n// 1. Stop listening for changes on our control Text property\nif (!element.ShouldReactToTextChanges) return;\nelement.ShouldReactToTextChanges = false;\n\n// 2. Get the current cursor position\nvar selectedRange = Control.SelectedTextRange;\n\n// 3. Take the control’s text, lets name it oldText\nvar oldText = Control.Text;\n\n// 4. Parse oldText into a number, lets name it number\nvar number = FormattedNumberEntry.DumbParse(oldText);\n\n// 5. Format number, and place the formatted text in newText\nvar newText = $\"{number:#,##0}\";\n\n// 6. Set the Text property of our control to newText\nControl.Text = newText;\n\n// 7. Calculate the new cursor position\nvar change = -1 * (oldText.Length - newText.Length);\nvar newPosition = Control.GetPosition(selectedRange.Start, (nint)change);\n\n// 8. Set the new cursor position\nif (newPosition != null) // before we fail miserably\n{\n    Control.SelectedTextRange = Control.GetTextRange(newPosition, newPosition);\n}\n\n// 9. Start listening for changes on our control’s Text property\nelement.ShouldReactToTextChanges = true;\n{% endhighlight %}  \n\nNow works great: \n\n{% post_image iosgood.gif \"iOS working goooooood\" %}\n\n### Android\nFor Android we will subscribe to the `AfterTextChanged` event and create all the formatting there:\n\n{% highlight csharp %}\npublic class FormattedNumberEntryRenderer : EntryRenderer\n{\n    protected override void OnElementChanged(ElementChangedEventArgs<Entry> e)\n    {\n        base.OnElementChanged(e);\n\n        if (e.OldElement != null)\n        {\n            Control.AfterTextChanged -= Control_AfterTextChanged;\n        }\n        if (e.NewElement != null)\n        {\n            Control.AfterTextChanged += Control_AfterTextChanged;\n        }\n    }\n{% endhighlight %}  \n\nAnd then in the `Control_AfterTextChanged` implementation:\n\n{% highlight csharp %}\nvar element = ((FormattedNumberEntry)Element);\n\n// 1. Stop listening for changes on our control Text property\nif (!element.ShouldReactToTextChanges) return;\nelement.ShouldReactToTextChanges = false;\n\n// 2. Get the current cursor position\nvar cursorPosition = Control.SelectionStart;\n\n// 3. Take the control’s text, lets name it oldText\nvar oldText = Control.Text;\n\n// 4. Parse oldText into a number, lets name it number\nvar number = FormattedNumberEntry.DumbParse(oldText);\n\n// 5. Format number, and place the formatted text in newText\nvar newText = $\"{number:#,##0}\";\n\n// 6. Set the Text property of our control to newText\nControl.Text = newText;\n\n// 7. Calculate the new cursor position\nvar change = oldText.Length - newText.Length;\n\n// 8. Set the new cursor position\nControl.SetSelection(cursorPosition - change);\n\n// 9. Start listening for changes on our control’s Text property\nelement.ShouldReactToTextChanges = true;\n{% endhighlight %}   \n\nHere is the final result\n\n{% post_image androidgood.gif \"Android working goooooood\" %}\n\n### Universal Windows Platform  \n\nFor the Windows platforms we need to handle the `TextChanged` event:\n\n{% highlight csharp %}\npublic class FormattedNumberEntryRenderer : EntryRenderer\n{\n    protected override void OnElementChanged(ElementChangedEventArgs<Entry> e)\n    {\n        base.OnElementChanged(e);\n\n        if (e.OldElement != null)\n        {\n            Control.TextChanged -= Control_TextChanged;\n        }\n        if (e.NewElement != null)\n        {\n            Control.TextChanged += Control_TextChanged;\n        }\n    }\n{% endhighlight %}  \n\nThen in `Control_Text` changed:  \n\n{% highlight csharp %}\nvar element = ((FormattedNumberEntry)Element);\n\n// 1. Stop listening for changes on our control Text property\nif (!element.ShouldReactToTextChanges) return;\nelement.ShouldReactToTextChanges = false;\n\n// 2. Get the current cursor position\nvar cursorPosition = Control.SelectionStart;\n\n// 3. Take the control’s text, lets name it oldText\nvar oldText = Control.Text;\n\n// 4. Parse oldText into a number, lets name it number\nvar number = FormattedNumberEntry.DumbParse(oldText);\n\n// 5. Format number, and place the formatted text in newText\nvar newText = $\"{number:#,##0}\";\n\n// 6. Set the Text property of our control to newText\nControl.Text = newText;\n\n// 7. Calculate the new cursor position\nvar change = -1 * (oldText.Length - newText.Length);\nif (cursorPosition + change < 0)\n    change = 0;\n\n// 8. Set the new cursor position\nControl.SelectionStart = cursorPosition + change;\n\n// 9. Start listening for changes on our control’s Text property\nelement.ShouldReactToTextChanges = true;\n{% endhighlight %}  \n\nAnd *voilà*:\n\n{% post_image uwpgood.gif \"Android working goooooood\" %}\n\n## Wrapping up  \nI know, I know, it might seem like a lot of code for such a *simple* task, yet, I couldn't find how to do it \"natively\" let alone using Forms. This kind of small details improve the user experience of our apps and aren't too complicated to implement. As always, feel free to browse the code (<a href=\"https://github.com/ThatCSharpGuy/FormattedNumberEntry\" target=\"_blank\">available on GitHub</a>) or *tweemail* me if in doubt.  \n\n## Future improvements\nThis control isn't perfect, it has a lot of room for improvements:\n\n - Modify the parsing algorithm to allow bigger numbers to be input\n - Allow decimal numbers\n - Save at control level the parsed number. Currently anyone interested in getting the integer value from the control will have to parse the text.\n - The *convert-to-string* method may have issues with globalization \n\nSo go ahead and have cross-platform fun."
}