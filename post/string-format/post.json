{	
	"id" : "/post/string-format/",
	"tv" : false,
	"date": "2016-10-24 14:00:01 -0500",
	"title" : "String.Format",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//aprende-c-sharp/format.jpg",
	"tags" : ["AprendeCSharp"],
	  
	"content": '"El método estático `Format` de la clase `String` nos ayuda en el manejo de las cadenas en C#, específicamente a la hora de la presentación de la información. Antes de continuar, es importante que conozcas la firma del método que estamos a punto de discutir:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npublic</span> <span class="k">static</span> <span class="kt">string</span> <span class="n">Format</span> <span class="p">(</span><span class="kt">string</span> <span class="n">format</span><span class="p">,</span> <span class="k">params</span> <span class="kt">object</span><span class="p">[]</span> <span class="n">args</span><span class="p">);</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\nLo cual significa que recibe una cadena y una colección de objetos y devuelve una cadena. Ahora sí, mejor vemos su funcionamiento, toma por ejemplo la siguiente línea de código:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;Buen día señor {0}\&quot;, \&quot;sol\&quot;));\n</span></code></pre></figure>\n\nQue produce el siguiente resultado en la pantalla:  ```Buen día señor sol```.  \n\nWow, ¿viste lo que ocurrió? ... La cadena \"{0}\" fue reemplazada por \"sol\". Esa es básicamente la función de `Format`: **reemplazar cadenas por valores**. Pero las cadenas no tienen que ser cualquier cosa, sino una cadena \"especial\", que debe contener marcadores (o *placeholders*) que se forman de un índice entero rodeado de las llaves `{` y `}`.  \n\nEl índice indica en qué lugar dentro de la función aparecerá el valor por el cual debe ser reemplazado, en el caso del código anterior `\"sol\"` aparece en el lugar 0 (contando de izquierda a derecha) a partir de que termina la cadena \"original\". En caso de que hubiera más de un parámetro podríamos usar `{1}`, `{2}` y así sucesivamente:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;{0}, {1} y {2}\&quot;, \&quot;uno\&quot;, \&quot;dos\&quot;, \&quot;tres\&quot;)); // Imprime: \&quot;uno, dos y tres\&quot;\nConsole.WriteLine(String.Format(\&quot;{1}, {0} y {2}\&quot;, \&quot;uno\&quot;, \&quot;dos\&quot;, \&quot;tres\&quot;)); // Imprime: \&quot;dos, uno y tres\&quot;\nConsole.WriteLine(String.Format(\&quot;{2}, {0} y {1}\&quot;, \&quot;uno\&quot;, \&quot;dos\&quot;, \&quot;tres\&quot;)); // Imprime: \&quot;tres, uno y dos\&quot;\n</span></code></pre></figure>  \n\nDel código anterior observa cómo a pesar de que parámetros aparecen en el mismo orden, cambia la forma en que aparecen en la pantalla.\n\n## Formato especial  \nAdemás de decidir la ubicación de nuestros objetos en la cadena formateada con las llaves e índices (`{0}`,`{1}`, ...), también podemos darles un formato más específico. Esto se logra modificando un poco el marcador que indica su posición, la modificación consiste en agregar dos puntos a la derecha del índice, seguido del formato que deseamos darle, todo esto dentro de las llaves. Es decir, `{0}` se transformaría en `{0:X}`, o `{2}` se transformaría en `{2:#,##0.00}`, la idea se entiende. De los formatos hablaremos un poco más adelante. \n\n## Formateando enteros\nFormatear enteros es probablemente algo que tendrás que hacer comúnmente, así que por qué no aprender algunas cuantas cosas para hacer que luzcan mejor. Para darle formato a los enteros usando `Format` tenemos varias opciones a nuestro alcance. Por ejemplo, podemos hacer que se el número tenga tantos ceros a la izquierda como deseamos (cinco ceros en este caso): \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;{0:00000}\&quot;, 1300)); // Imprime: \&quot;01300\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:00000}\&quot;, -52)); // Imprime: \&quot;-00052\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:00000}\&quot;, 0)); // Imprime: \&quot;00000\&quot;\n</span></code></pre></figure>   \n\nO, ¿quién no conoce la notación exponencial? pues también la podemos usar para formatear nuestros números, el modificador de formato es la letra `e`: \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;{0:e}\&quot;, 1300)); // Imprime: \&quot;1.300000e+003\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:e}\&quot;, -52)); // Imprime: \&quot;-5.200000e+001\&quot;\n</span></code></pre></figure>   \n\nEl modificador de formato `c` puede resultar muy útil para aplicaciones que manejan cantidades monetarias, ya que se encarga de darles formato y añadirle el signo de la moneda sin necesidad de más esfuerzo del programador:\n\n**NOTA:** Ten especial cuidado con este modificador de formato, ya que modificará el número de acuerdo a la cultura de tu aplicación. \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;{0:c}\&quot;, 1300)); // Imprime: \&quot;$1,300.00\nConsole.WriteLine(String.Format(\&quot;{0:c}\&quot;, -52)); // Imprime: \&quot;($52.00)\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:c}\&quot;, 0)); // Imprime: \&quot;$0.00\&quot;\n</span></code></pre></figure>    \n\nY no podríamos dejar de lado a los números hexadecimales, su modificador es la letra `x` seguido de un número entero que indica el número de posiciones que debe ocupar, mira:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nint</span> <span class="n">r</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span> <span class="n">g</span> <span class="p">=</span> <span class="m">133</span><span class="p">,</span> <span class="n">b</span> <span class="p">=</span> <span class="m">20</span><span class="p">;</span><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;Hex: R{0:x}, G{1:x4}, B{2:x2}\&quot;, r, g, b)); // Imprime: \&quot;Hex: R0, G0085, B14\&quot;\nConsole.WriteLine(\&quot;Hex: {0:x2}{1:x2}{2:x2}\&quot;, r, g, b); // Imprime: \&quot;Hex: 008514\&quot;\n</span></code></pre></figure>  \n\n## Formateando numeros reales  \nAl igual que los enteros, para los números reales (`double`, `decimal` y `float`) también se pueden formatear. Comenzando por el modificador `r` que supuestamente garantiza que un número será convertido a cadena y que posteriormente podremos *parsear* esa cadena de vuelta al número y obtener el mismo valor, aunque esto <a href=\"http://stackoverflow.com/questions/24299692/why-is-a-round-trip-conversion-via-a-string-not-safe-for-a-double?rq=1\" target=\"_blank\">no es del todo cierto</a>. Generalmente se usa `r` para obtener una representación exacta del número:  \n\n**NOTA:** Este modificador de formato únicamente puede ser usado con números `double` y `float`. \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;{0:r}\&quot;, 0.6852871999174d)); // Imprime: \&quot;0.6852871999174\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:r}\&quot;, 0.6852871999174f));  // Imprime: \&quot;0.6852872\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:r}\&quot;, 0.6852871999174m));  // Error, r no está disponible para decimal\n</span></code></pre></figure>  \nTambién podemos especificar cuántos decimales deben aparecer cuando imprimimos el número, usando `0`s para indicar la cantidad de decimales: \n\n**NOTA:** Este modificador de formato redondeará los números a su valor más cercano. \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;{0:#,##0.00}\&quot;, 13000d)); // Imprime: \&quot;13,000.00\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:#,##0.00}\&quot;, 0.6852871999174f));  // Imprime: \&quot;0.69\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:#,##0.00}\&quot;, -0.50m));  // Imprime: \&quot;-0.50\&quot;\n</span></code></pre></figure>  \n\nSi por otro lado estamos trabajando con números que representan porcentajes, podemos hacer uso del modificador `0%`, este modificador tomará el valor y lo multiplicará por 100 e imprimirá el resultado acompañado del símbolo de por ciento:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;{0:0.0%}\&quot;, 13000d)); // Imprime: \&quot;1300000.0%\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:0.0%}\&quot;, 0.6852871999174f));  // Imprime: \&quot;68.5%\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:0.0%}\&quot;, -0.50m));  // Imprime: \&quot;-50.0%\&quot;\n</span></code></pre></figure>  \n\nEl resto de modificadores de formato los puedes encontrar en <a href=\"https://msdn.microsoft.com/en-us/library/0c899ak8(v=vs.110).aspx\" target=\"_blank\">este enlace</a>.    \n\n## Formato condicional\nPara los tipos numéricos, `String.Format` tiene una opción más de formateo, que es útil si quieres hacer distinción entre números positivos, negativos y con valor 0. La sintaxis no es tan distinta a las anteriores, basta con separar con `;` los formatos:  \n\n```  \n\"{0:[formato si positivo];[formato si negativo];[formato si cero]}\"  \n```  \n\nLos usos de este pueden ser muy variados, por ejemplo, imagina que un requerimiento de tu aplicación es poner guiones en lugar de 0 cuando muestres cifras y la palabra MENOS cuando se trata de números negativos:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;{0:#,##0.00;MENOS #,##0.00;—}\&quot;, 13000)); // Imprime: \&quot;13,000.00\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:#,##0.00;MENOS #,##0.00;—}\&quot;, 0));  // Imprime: \&quot;—\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:#,##0.00;MENOS #,##0.00;—}\&quot;, -0.50m));  // Imprime: \&quot;MENOS 0.50\&quot;\n</span></code></pre></figure> \n\nOtro posible uso es para esos sistemas, raros, en donde se utilizan los valores 1 y -1 como booleanos:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;{0:VERDADERO;FALSO;DESCONOCIDO}\&quot;, 1)); // Imprime: \&quot;VERDADERO\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:VERDADERO;FALSO;DESCONOCIDO}\&quot;, 0));  // Imprime: \&quot;DESCONOCIDO\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:VERDADERO;FALSO;DESCONOCIDO}\&quot;, -1));  // Imprime: \&quot;FALSO\&quot;\n</span></code></pre></figure> \n\nTambién puedes hacer cosas como mostrar si un balance es positivo o negativo sin mostrar los números y sin la necesidad de agregar sentencias de control a tu código. Deja que `Format` haga el trabajo.  \n\n## Formateando fechas  \nProbablemente las fechas sean el tipo de dato que más opciones de formato posean. Toma por ejemplo las siguientes opciones de formato:  \n \n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">now</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">;</span><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;{0:d}\&quot;, now)); // Imprime: \&quot;22/10/2016\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:F}\&quot;, now)); // Imprime: \&quot;sábado, 22 de octubre de 2016 09:54:33 a.m.\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:M}\&quot;, now)); // Imprime: \&quot;22 de octubre\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:T}\&quot;, now)); // Imprime: \&quot;09:54:33 a.m.\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:r}\&quot;, now)); // Imprime: \&quot;Sat, 22 Oct 2016 09:54:33 GMT\&quot;\n</span></code></pre></figure> \n\nPero también puedes crear tus formatos propios, por ejemplo:  \n \n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">now</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">;</span><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;{0:dd/MM/yyyy}\&quot;, now)); // Imprime: \&quot;24/10/2016\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:dd-MM-yyyy}\&quot;, now)); // Imprime: \&quot;24-10-2016\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:dd MMM yyyy}\&quot;, now)); // Imprime: \&quot;24 oct. 2016\&quot;\nConsole.WriteLine(String.Format(\&quot;{0:dd &#39;de&#39; MMMM &#39;de&#39; yy}\&quot;, now)); // Imprime: \&quot;24 de octubre de 16\&quot;\n</span></code></pre></figure> \n\nEn la última línea, ¿viste cómo es que \"de\" está escrito entre comillas simples? a esto se le llama *\"escapar\"* una cadena, ya que de otro modo (de haber puesto \"de\" sin comillas simples) el resultado de `Format` habría sido: \"24 24e octubre 24e 16\". Siempre que deseemos que un caracter sea ignorado para cuando se realice el formato, tenemos que *escaparlo*.\n\nPuedes consultar todos los modificadores de formato para fechas en <a href=\"https://msdn.microsoft.com/en-us/library/8kb3ddd4(v=vs.110).aspx\" target=\"_blank\">el sitio de MSDN</a>.  \n\n## Relleno o padding  \nLa posibilidad de agregar relleno a las cadenas formateadas es una de las características que yo acabo de descubrir. Normalmente concatenaba una cadena vacía con la que quería mostrar y obtenía una subcadena para obtener el resultado deseado, sin embargo, podemos irnos olvidando de eso, ya que `Format` también nos lo ofrece. Cambia un poco la sintaxis, pero no es nada del otro mundo: ahora es necesario agregar otro número (separado por una coma), inmediatamente después del índice del parámetro y antes de los `:` en caso de que los contenga. \n\nEl número que agreguemos representará la cantidad de relleno que se deberá agregar, lo mejor es que nos permite agregar *padding* tanto a la izquierda como a la derecha, dependiendo de si el número que agregamos es positivo o negativo:  \n \n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;I|{0,10}|{0,-10}|D\&quot;, 1300));    // Imprime: \&quot;I|      1300|1300      |D\&quot;\nConsole.WriteLine(String.Format(\&quot;I|{0,10}|{0,-10}|D\&quot;, -52));     // Imprime: \&quot;I|       -52|-52       |D\&quot;\nConsole.WriteLine(String.Format(\&quot;I|{0,10}|{0,-10}|D\&quot;, 0));       // Imprime: \&quot;I|         0|0         |D\&quot;\n</span></code></pre></figure> \n\nPara terminar, podemos combinar todos los tipos de formato con *padding* y modificadores para presentar datos de una manera más ordenada, por ejemplo, en una tabla:\n  \n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">data</span> <span class="p">=</span> <span class="k">new</span><span class="p">[]</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="k">new</span> <span class="p">{</span> <span class="n">Dato1</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span> <span class="n">Dato2</span><span class="p">=</span><span class="err">\</span><span class="s">&quot;México\&quot;, Dato3 = DateTime.Now },\n    new { Dato1 = 2, Dato2 = \&quot;Canadá\&quot;, Dato3 = DateTime.Now.AddDays(3) },\n    new { Dato1 = 10, Dato2 = \&quot;Panamá\&quot;, Dato3 = DateTime.Now.AddDays(-2) },\n    new { Dato1 = 0, Dato2 = \&quot;Perú\&quot;, Dato3 = DateTime.Now.AddMonths(-2) }\n};\nforeach (var item in data)\n{\n    Console.WriteLine(\&quot;|{0,10:000}|{1,10}|{2,10:dd-MM}|\&quot;, item.Dato1, item.Dato2, item.Dato3);\n}\n</span></code></pre></figure> \n\nCon lo cual obtendremos algo así:  \n\n<pre>\n|       000|    México|     24-10|  \n|       002|    Canadá|     27-10|  \n|       010|    Panamá|     22-10|  \n|       000|      Perú|     24-08|  \n</pre>\n\nCuando un formato no se pueda aplicar, generalmente cuando el tipo de dato no es compatible con el formato elegido, se obtendrá una excepción del tipo `FormatException`. Generalmente esto no debería ocurrir puesto que tu controlas el código, pero sin duda debes tener cuidado de manejar las excepciones si crees que se podrían presentar.  \n\n## Console.WriteLine  \nPor si te diste cuenta, hay algunos casos en que uso únicamente el método `WriteLine` sin llamar a `Format`, y es que el primero tiene una sobrecarga que ejecuta el segundo, pero imprime directamente el resultado sin necesidad de que tengas que llamarlo tu explícitamente. Muy útil, la verdad.  \n"'   
}