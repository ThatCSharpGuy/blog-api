{	
	"id" : "/post/humaniza-tus-apps/",
	"tv" : false,
	"date": "2016-01-18 13:00:00 -0600",
	"title" : "Humaniza tus apps",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimagesfeatured_es.png",
	"tags" : ["NuGetRecomendado"],
	  
	"content": '"Es un hecho que actualmente cuando una aplicación es lanzada al público no solo es necesario que funcione bien y haga lo que promete, sino que además de todo se vea bien y su interfaz de usuario sea agradable a la persona que la necesita.  \n\nHay muchas cosas que tenemos que hacer para que nuestra aplicación sea agradable al usuario, y una de ellas es hacer que la información que se le presenta esté en un lenguaje más natural, que no parezca generado por una computador (aunque sí lo sea). ¿A qué me refiero con esto? veamos un ejemplo común:\n\nSupongamos que dentro de nuestras aplicaciones queremos mostrar información de un evento que se llevará a cabo, información que tenemos almacenada como `int`s, `DateTime`s y `Decimal`s, y a la hora de mostrarlo al usuario, en la interfaz de nuestra app ponemos algo como:  \n  \n*Número de asistentes: 3* o *Número de asistentes: 1*  \n*El evento será el 20/01/2016*  \n*La duración es de 13:00 a 16:00* \n  \nLo cual no está mal... pero no es muy natural que digamos, y es por eso que muchos optan por mostrar algo como:\n\n*3 asisistente(s)* o *1 asistente(s)*    \n*El evento será el Miércoles, Enero 201, 2016*  \n*La duración es de 13:00 a 16:00* \n\nQue ya es un poco más \"lenguaje humano\" pero tiene ese horrible paréntesis al final, desde luego, pudimos haber evitado eso escribiendo nuestro código con una condicional para revisar la cantidad de asistentes antes de imprimirlo, pero sería tratar de reinventar la rueda. Es por eso que en este post hablaré de **Humanizer**, sus múltiples características y de como podemos pasar de la interfaz anterior a una como esta:  \n\n*3 asistentes*  \n*El evento será en 4 días*    \n*Tiene una duración de 3 horas*  \n\n### Instalando Humanizer  \nHumanizer está en forma de [una Portable Class Library](/post/que-son-portable-class-library/), y disponible a través de NuGet, por lo que es sencillo instalarla en cualquier proyecto, desde una aplicación de consola (como la de este post) hasta una app de Xamarin.iOS. Basta con instalar el paquete `Humanizer.Core` usando la consola del administrador de paquetes:  \n\n<figure class="console"><pre><code>\nPM> Install-Package Humanizer\n</code></pre></figure>\n\nO a través de la interfaz gráfica en donde basta con buscar `Humanizer.Core` e instalarlo.\n\n#### Soporte para otros idiomas\nOriginalmente Humanizer fue creado para funcionar con palabras del idioma inglés, pero afortunadamente gracias a la comunidad Open Source, se han añadido otros, como el español. Para añadirlo es necesario bajar un segundo paquete de NuGet con los recursos en español llamado `Humanizer.Core.es`.\n\nPor default, para el idioma de los textos, Humanizer toma la cultura del hilo que lo ejecuta, para cambiarla puedes usar una línea de código:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nThread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">CurrentUICulture</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CultureInfo</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;es-ES\&quot;);\n</span></code></pre></figure> \n\nSi por las restricciones de tu aplicación no es posible hacer el cambio anterior, no te preocupes, generalmente los métodos que veremos a continuación permiten especificar la cultura en la que queremos que funcionen.\n\n### La clase Event\nPara este código de ejemplo usaré una clase llamada evento, que contiene dos `String` para el nombre y descripción del evento, dos `int` para el número de asistentes y para el número de evento, dos `DateTimes` para las fechas de inicio y fin del evento.  \n\nPara este post, crearé un `Event` llamado `contest` con el que estaremos trabajando a lo largo de este post.\n\n### Números \nPasar de `8` a *\"octavo\"* no suena tan sencillo, sin embargo Humanizer lo hace, basta con llamar el método de extensión `ToOrdinalWords`, o también podemos usar el método `Ordinalize` para obtener una cadena más pequeña, como `8.º`:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">ncontest</span><span class="p">.</span><span class="n">Number</span><span class="p">.</span><span class="n">ToOrdinalWords</span><span class="p">(</span><span class="n">GrammaticalGender</span><span class="p">.</span><span class="n">Masculine</span><span class="p">);</span> <span class="c1">// \&quot;octavo\&quot;\ncontest.Number.ToOrdinalWords(GrammaticalGender.Feminine); // \&quot;octava\&quot;\ncontest.Number.Ordinalize(GrammaticalGender.Neuter); // \&quot;8.º\&quot;\n</span></code></pre></figure>  \n  \nComo podemos ver también nos da diversas opciones en cuanto a qué genero estamos expresando, o si queremos palabras o números ordinalizados.  \n  \nTambién es posible:  \n\n - Pasar de un número a una cadena, así entonces al llamar el método `ToWords` en un número, obtendremos su representación en palabras: `158` → \"ciento cincuenta y ocho\".\n - Pasar de un número arábigo a uno romano usando `ToRoman`: `158` → \"CLVIII\" y viceversa.\n - Manejar números como tamaños de archivo, pasar de megabytes a bits o de kilobytes a terabytes con facilidad\n  \n### Truncar cadenas \nTruncar cadenas es algo importante para cuando queremos mostrar una parte de un texto largo, ya sea para reducir costos en la transferencia de datos o para no llenar de texto la pantalla del usuario, eso de truncar cadenas suena a algo trivial que podemos implementar fácilmente nosotros mismos, sin embargo para truncar cadenas usando Humanizer basta llamar al método de extensión `Truncate`:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">ncontest</span><span class="p">.</span><span class="n">Description</span><span class="p">.</span><span class="n">Truncate</span><span class="p">(</span><span class="m">40</span><span class="p">);</span> <span class="c1">// 40 caracteres, terminando en &#39;…&#39; \ncontest.Description.Truncate(40,\&quot;...\&quot;); // 40 caracteres, terminando en \&quot;...\&quot;\ncontest.Description.Truncate(7,Truncator.FixedNumberOfWords); // 7 palabras, terminando en &#39;…&#39;\n</span></code></pre></figure>    \n\nSe pueden hacer combinaciones como que sean 30 caracteres y termine en \":::\", o que trunque el texto en 10 palabras comenzando por la derecha y que termine en \"...\".   \n\n### Cuantificar\nBueno, no sé si \"cuantificar\" sea la palabra adecuada\nPara evitar esos horribles paréntesis que indican que puede haber uno o más elementos de una categoría podemos usar el método `ToQuantity` que es aplicado sobre una cadena de texto y recibe un entero indicando la cantidad de elementos que queremos mostrar, de este modo ya no tendríamos que poner `asistente(s)`, sino únicamente hacer algo como esto:\n\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="s">&quot;asistente\&quot;.ToQuantity(contest.Attendants, ShowQuantityAs.Words);  // \&quot;cero asistentes\&quot;.\n\&quot;asistente\&quot;.ToQuantity(contest.Attendants); // \&quot;0 asistentes\&quot;\n\&quot;asistente\&quot;.ToQuantity(1, ShowQuantityAs.None); // \&quot;asistente\&quot;\n\&quot;asistente\&quot;.ToQuantity(1, ShowQuantityAs.Numeric); // \&quot;1 asistente\&quot; \n</span></code></pre></figure>  \n\nDesde luego, hay palabras que no serán directamente *pluralizables* o que simplemente no pueden ser cuantificadas, pero esas se pueden agregar previamente al vocabulario:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nVocabularies</span><span class="p">.</span><span class="n">Default</span><span class="p">.</span><span class="n">AddIrregular</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;feliz\&quot;, \&quot;felices\&quot;);\n\nVocabularies.Default.AddUncountable(\&quot;lava\&quot;);\n</span></code></pre></figure>   \n\n### Fechas e intervalos de tiempos  \n<b>Importante:</b> al momento de hacer este post, parece que me encontré con un bug con la localización de las fechas, ya nos entrega el resultado en inglés, <a href=\"https://github.com/Humanizr/Humanizer/issues/513\" target=\"_blank\" rel=\"nofollow\"><i>levanté un issue</i></a> en GitHub y trataré de encontrar el problema.\n  \n#### Fechas\nEn cuanto a las fechas hay muy poco margen de movimiento, una fecha es una fecha, pero qué mejor que darle una referencia más verbal al usuario, como \"en dos semanas\", \"ayer\" o \"dentro de 10 dias\" puede resultar mejor que únicamente mostrar el clásico \"dd/MM/yyyy\". \n\nEn el ejemplo de los eventos, la propiedad `Start` es igual a `new DateTime(2016,2, 29, 10,0,0)` mientras que `End = new DateTime(2016,2,29,17,30,0)`, es por eso que al momento de utilizar `contest.Start.Humanize();` obtuve \"en un mes\".  \n  \nPero para crear un ejemplo más claro:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span> <span class="p">(</span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">Humanize</span><span class="p">(</span><span class="k">false</span><span class="p">));</span> <span class="c1">// \&quot;Ahora\&quot;\nConsole.WriteLine (DateTime.UtcNow.Humanize()); // \&quot;Ahora\&quot;\nConsole.WriteLine (DateTime.UtcNow.AddDays(3).Humanize()); // \&quot;En tres días\&quot;\nConsole.WriteLine (DateTimeOffset.UtcNow.AddMonths(-10).Humanize()); // \&quot;Hace 10 meses\&quot;\n</span></code></pre></figure>   \n\nEl método `Humanize` funciona tanto para tipos `DateTime` como para `DateTimeOffset` y entre sus sobrecargas podemos especificar si estamos manejando una fecha UTC, o contra qué fecha queremos comparar (por default usa `DateTime.UtcNow`).  \n\n#### Intervalos de tiempo\nEn cuanto a intervalos de tiempo, bien podríamos mostrar las fechas separadas por un guión, pero al igual que con las fechas, tal vez sea mejor decir \"una hora\", \"45 minutos\" o \"tres días\".\n\nLos eventos tienen una fecha de inicio y una de finalización, un escenario ideal para simplemente restar `Start` de `End` lo cual nos deja con un `TimeSpan`, sobre el cual podemos ejecutar el método de extensión `Humanize` para obtener una versión legible del intervalo:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">n</span><span class="p">(</span><span class="n">evt</span><span class="p">.</span><span class="n">End</span> <span class="p">-</span> <span class="n">evt</span><span class="p">.</span><span class="n">Start</span><span class="p">).</span><span class="n">Humanize</span><span class="p">(</span><span class="m">3</span><span class="p">);</span> <span class="c1">// \&quot;7 horas, 30 minutos\&quot;\n</span></code></pre></figure>   \n\nOtra vez, el método tiene muchas sobrecargas, entre las que podemos elegir con qué detalle queremos que se muestre la cadena, o cuál es la unidad máxima (o mínima) de tiempo que queremos tomar en cuenta. En el caso del ejemplo, coloqué un  `3` puesto que a lo mucho quiero que se muestren días, horas y minutos.  \n\n#### Mejoras para los desarrolladores\nHumanizer no solo son mejoras para el usuario final, sino también para nosotros los desarrolladores, para manejar fechas incluye una <a href=\"https://es.wikipedia.org/wiki/Interfaz_fluida\" target=\"_blank\" rel=\"nofollow\">interfaz fluida</a> para hacer un poco más legible el código, para poner un ejemplo, tomaré este de la <a href=\"https://github.com/Humanizr/Humanizer#fluent-date\" target=\"_blank\" rel=\"nofollow\">documentación oficial</a>:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nDateTime</span><span class="p">.</span><span class="n">Now</span> <span class="p">+</span> <span class="m">2.D</span><span class="n">ays</span><span class="p">()</span> <span class="p">+</span> <span class="m">3.</span><span class="n">Hours</span><span class="p">()</span> <span class="p">-</span> <span class="m">5.</span><span class="n">Minutes</span><span class="p">();</span><span class="err">\</span><span class="n">n</span></code></pre></figure>    \n\nEs equivalente a \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nDateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">AddDays</span><span class="p">(</span><span class="m">2</span><span class="p">).</span><span class="n">AddHours</span><span class="p">(</span><span class="m">3</span><span class="p">).</span><span class="n">AddMinutes</span><span class="p">(-</span><span class="m">5</span><span class="p">);</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\n### Otras características  \nEn este post dejé afuera la capacidad de Humanizer de trabajar con colecciones, enumeraciones y más posibilidades para trabajar con cadenas. Estas tres y otras características se pueden revisar en el <a href=\"https://github.com/Humanizr/Humanizer#table-of-contents\" target=\"_blank\" rel=\"nofollow\">repositorio de Humanizer en GitHub</a>. \n"'   
}