{	
	"id" : "/post/tuples-c-sharp/",
	"tv" : false,
	"date": "2016-05-16 14:00:01 -0500",
	"title" : "Tuples en C#",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//aprende-c-sharp/tuples.png",
	"tags" : ["AprendeCSharp"],
	  
	"content": '"Seguramente te ha pasado, alguna vez has pensado \"Ojalá pudiera devolver dos cosas desde este método\" y si bien recuerdas que los <a href=\"../metodos-c-sharp\">métodos en C#</a> únicamente pueden tener un solo tipo de retorno, es posible devolver más de dos valores haciendo uso de la clase genérica `Tuple`.  \n\nPodemos ver a `Tuple` (o tupla) como un auxiliar para el programador, que **permite \"agrupar\" otros tipos dato dentro de uno solo**, para así tratarlos como uno solo, esto, a través de varias clases genéricas definidas de la siguiente manera:  \n\n - `Tuple<T1>`\n - `Tuple<T1, T2>`\n - `Tuple<T1, T2, T3>`\n - `Tuple<T1, T2, T3, T4>`\n - `Tuple<T1, T2, T3, T4, T5>`\n - `Tuple<T1, T2, T3, T4, T5, T6>`\n - `Tuple<T1, T2, T3, T4, T5, T6, T7>`\n - `Tuple<T1, T2, T3, T4, T5, T6, T7, TRest>`\n \n ## Creando tuplas\n \nA través de los tipos `T#` se define el contenido de la clase, siendo así que para crear una tupla que contiene un entero y dos cadenas debemos usar:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;(</span><span class="m">1</span><span class="p">,</span> <span class="err">\</span><span class="s">&quot;A\&quot;, \&quot;B\&quot;);\n</span></code></pre></figure>\n\nO, por ejemplo, si quisiéramos crear algo más complejo como una clase que contiene un entero, un decimal, un objeto, otro entero, un booleano y un flotante, tendríamos que hacer algo como esto:    \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">t1</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">decimal</span><span class="p">,</span> <span class="kt">object</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">float</span><span class="p">&gt;(</span><span class="m">3</span><span class="p">,</span> <span class="m">1.5</span><span class="n">m</span><span class="p">,</span> <span class="k">new</span> <span class="p">{</span> <span class="n">emoji</span> <span class="p">=</span> <span class="err">\</span><span class="s">&quot;:grin:\&quot; }, 5, true, 7.5f);\n</span></code></pre></figure>\n\nUhhmm, la sintaxis se pone un poco complicada, ¿no? para eliminar esta sintaxis complicada, podemos usar el método estático `Create` de la clase `Tuple` para crear tuplas:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">t1</span> <span class="p">=</span> <span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">1.5</span><span class="n">m</span><span class="p">,</span> <span class="k">new</span> <span class="p">{</span> <span class="n">emoji</span> <span class="p">=</span> <span class="err">\</span><span class="s">&quot;:grin:\&quot; }, 5, true, 7.5f);\n</span></code></pre></figure>\n\nEste método, inferirá de los tipos de dato a partir de los parámetros pasados como argumentos.\n\n## Accediendo a los miembros\nUna vez creada la clase (ya sea con el constructor o el método estático), podemos acceder a cada uno de los datos a través de las propiedades llamadas  `Item#`, donde # es el número de la propiedad a la que nos referimos:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">Item1</span><span class="p">);</span> <span class="c1">// 1 -&gt; int\nConsole.WriteLine(t.Item2 + \&quot; - \&quot; + t.Item3 ); // \&quot;A - B\&quot; -&gt; string\n</span></code></pre></figure>\n\nEs importante señalar que las propiedades de la clase `Tuple` son de solo lectura, y que una vez asignadas en el constructor, no pueden ser modificadas:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">n</span><span class="c1">// t1.Item4 = 7; // Error, solo lectura\n</span></code></pre></figure>\n\n## Ejemplos de uso  \n\n### Como parámetros de método\nPodríamos pensar en un método como este: \n  \n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nstring</span> <span class="n">MegaMetodoArgumentos</span><span class="p">(</span><span class="kt">int</span> <span class="n">studentId</span><span class="p">,</span> <span class="kt">int</span> <span class="n">classroomId</span><span class="p">,</span> <span class="kt">string</span> <span class="n">type</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">sum</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">active</span><span class="p">)</span><span class="err">\</span><span class="n">n</span></code></pre></figure>\n\nPara llamarlo necesitaríamos escribir algo como esto:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nMegaMetodoArgumentos</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="err">\</span><span class="s">&quot;MX\&quot;, 3.1m, true);\n</span></code></pre></figure>\n\nO, también podríamos haber escrito el método de la siguiente manera:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nstring</span> <span class="n">MegaMetodoTuple</span><span class="p">(</span><span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="kt">decimal</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">args</span><span class="p">)</span><span class="err">\</span><span class="n">n</span></code></pre></figure>\n\nE invocarlo así:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">tuple</span> <span class="p">=</span> <span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="err">\</span><span class="s">&quot;MX\&quot;, 3.1m, true);\nMegaMetodoTuple(tuple);  \n</span></code></pre></figure>\n\n### Como valores de retorno\n\nEl beneficio se nota más cuando se usa una tupa como valor de retorno, imaginemos un método en el que convertimos tomamos un color definido en hexadecimal y lo convertimos a su representación RGB en decimal.\n\nPodríamos usar [parámetros de salida](http://thatcsharpguy.com/post/out-ref-c-sharp/):  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nprivate</span> <span class="k">static</span> <span class="k">void</span> <span class="n">SplitColors</span><span class="p">(</span><span class="kt">string</span> <span class="n">hex</span><span class="p">,</span> <span class="k">out</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="k">out</span> <span class="kt">int</span> <span class="n">g</span><span class="p">,</span> <span class="k">out</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="n">r</span> <span class="p">=</span> <span class="n">Int32</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">hex</span><span class="p">.</span><span class="n">Substring</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">2</span><span class="p">),</span> <span class="n">NumberStyles</span><span class="p">.</span><span class="n">HexNumber</span><span class="p">);</span><span class="err">\</span><span class="n">n</span>    <span class="n">g</span> <span class="p">=</span> <span class="n">Int32</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">hex</span><span class="p">.</span><span class="n">Substring</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">),</span> <span class="n">NumberStyles</span><span class="p">.</span><span class="n">HexNumber</span><span class="p">);</span><span class="err">\</span><span class="n">n</span>    <span class="n">b</span> <span class="p">=</span> <span class="n">Int32</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">hex</span><span class="p">.</span><span class="n">Substring</span><span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="m">2</span><span class="p">),</span> <span class="n">NumberStyles</span><span class="p">.</span><span class="n">HexNumber</span><span class="p">);</span><span class="err">\</span><span class="n">n</span><span class="p">}</span><span class="err">\</span><span class="n">n</span></code></pre></figure>\n\nPero también podríamos usar una tupla como valor de retorno:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nprivate</span> <span class="k">static</span> <span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">SplitColors</span><span class="p">(</span><span class="kt">string</span> <span class="n">hex</span><span class="p">)</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="kt">int</span> <span class="n">r</span> <span class="p">=</span> <span class="n">Int32</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">hex</span><span class="p">.</span><span class="n">Substring</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">2</span><span class="p">),</span> <span class="n">NumberStyles</span><span class="p">.</span><span class="n">HexNumber</span><span class="p">);</span><span class="err">\</span><span class="n">n</span>    <span class="kt">int</span> <span class="n">g</span> <span class="p">=</span> <span class="n">Int32</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">hex</span><span class="p">.</span><span class="n">Substring</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">),</span> <span class="n">NumberStyles</span><span class="p">.</span><span class="n">HexNumber</span><span class="p">);</span><span class="err">\</span><span class="n">n</span>    <span class="kt">int</span> <span class="n">b</span> <span class="p">=</span> <span class="n">Int32</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">hex</span><span class="p">.</span><span class="n">Substring</span><span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="m">2</span><span class="p">),</span> <span class="n">NumberStyles</span><span class="p">.</span><span class="n">HexNumber</span><span class="p">);</span><span class="err">\</span><span class="n">n</span>    <span class="k">return</span> <span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span><span class="err">\</span><span class="n">n</span><span class="p">}</span><span class="err">\</span><span class="n">n</span></code></pre></figure>\n\nEntonces para llamarlo, simplemente necesitaríamos escribir lo siguiente:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nstring</span> <span class="n">color</span> <span class="p">=</span> <span class="err">\</span><span class="s">&quot;3C8A3F\&quot;;\nvar colors = SplitColors(color);\nConsole.WriteLine(\&quot;{0} es R:{1} G:{2} B:{3}\&quot;, color, colors.Item1, colors.Item2, colors.Item3);\n</span></code></pre></figure>\n\n## Tuplas de 8 elementos\nSi volvemos a las definiciones de las clases `Tuple` puedes ver que existen hasta 8 versiones genéricas disponibles. Sin embargo, la octava una peculiaridad: el octavo valor no se almacena dentro de \"Item8\", sino dentro de otra tupla (a la que accedemos desde la propiedad `Rest`):  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">megaTuple</span> <span class="p">=</span> <span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">8</span><span class="p">);</span><span class="err">\</span><span class="n">n</span><span class="c1">//Console.WriteLine(miniTuple.Item8); // Item8 no existe, entonces tenemos que usar Rest:\nConsole.WriteLine(megaTuple.Rest.Item1); \n</span></code></pre></figure>\n\n## Ejemplo de la vida real\nMmm... en realidad no existe alguna api dentro del framework de .NET que haga uso de tuplas, pero en específico se recomienda para:\n\n - Representar un set de datos, por ejemplo, un registro en una base de datos\n - Proveer acceso fácil, y manipulación de, un set de datos\n - Regresar múltiples valores de un método sin usar parámetros por referencia\n - Enviar múltiples valores a un método\n \n## Lo que sigue\nRevisa el <a href=\"https://github.com/ThatCSharpGuy/aprende-c-sharp/tree/master/Tuples\" target=\"_blank\" rel=\"nofollow\">código que acompaña al post</a> y juegues un poco con él, sé que tal vez el asunto de los genéricos en C# puede causar un poco de confusión y es un tema que estoy planeando cubrir en un post futuro.\n"'   
}