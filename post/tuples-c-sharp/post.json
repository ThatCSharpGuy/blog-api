{	
	"id" : "/post/tuples-c-sharp/",
	"tv" : false,
	"date": "2016-05-16 14:00:01 -0500",
	"title" : "Tuples en C#",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//aprende-c-sharp/tuples.png",
	"tags" :
	["AprendeCSharp"],
	
	"content" : body"Seguramente te ha pasado, alguna vez has pensado \"Ojalá pudiera devolver dos cosas desde este método\" y si bien recuerdas que los <a href=\"../metodos-c-sharp\">métodos en C#</a> únicamente pueden tener un solo tipo de retorno, es posible devolver más de dos valores haciendo uso de la clase genérica `Tuple`.  \n\nPodemos ver a `Tuple` (o tupla) como un auxiliar para el programador, que **permite \"agrupar\" otros tipos dato dentro de uno solo**, para así tratarlos como uno solo, esto, a través de varias clases genéricas definidas de la siguiente manera:  \n\n - `Tuple<T1>`\n - `Tuple<T1, T2>`\n - `Tuple<T1, T2, T3>`\n - `Tuple<T1, T2, T3, T4>`\n - `Tuple<T1, T2, T3, T4, T5>`\n - `Tuple<T1, T2, T3, T4, T5, T6>`\n - `Tuple<T1, T2, T3, T4, T5, T6, T7>`\n - `Tuple<T1, T2, T3, T4, T5, T6, T7, TRest>`\n \n ## Creando tuplas\n \nA través de los tipos `T#` se define el contenido de la clase, siendo así que para crear una tupla que contiene un entero y dos cadenas debemos usar:  \n\n{% highlight csharp %}\nvar t = new Tuple<int, string, string>(1, \"A\", \"B\");\n{% endhighlight %}\n\nO, por ejemplo, si quisiéramos crear algo más complejo como una clase que contiene un entero, un decimal, un objeto, otro entero, un booleano y un flotante, tendríamos que hacer algo como esto:    \n\n{% highlight csharp %}\nvar t1 = new Tuple<int, decimal, object, int, bool, float>(3, 1.5m, new { emoji = \":grin:\" }, 5, true, 7.5f);\n{% endhighlight %}\n\nUhhmm, la sintaxis se pone un poco complicada, ¿no? para eliminar esta sintaxis complicada, podemos usar el método estático `Create` de la clase `Tuple` para crear tuplas:  \n\n{% highlight csharp %}\nvar t1 = Tuple.Create(3, 1.5m, new { emoji = \":grin:\" }, 5, true, 7.5f);\n{% endhighlight %}\n\nEste método, inferirá de los tipos de dato a partir de los parámetros pasados como argumentos.\n\n## Accediendo a los miembros\nUna vez creada la clase (ya sea con el constructor o el método estático), podemos acceder a cada uno de los datos a través de las propiedades llamadas  `Item#`, donde # es el número de la propiedad a la que nos referimos:  \n\n{% highlight csharp %}\nConsole.WriteLine(t.Item1); // 1 -> int\nConsole.WriteLine(t.Item2 + \" - \" + t.Item3 ); // \"A - B\" -> string\n{% endhighlight %}\n\nEs importante señalar que las propiedades de la clase `Tuple` son de solo lectura, y que una vez asignadas en el constructor, no pueden ser modificadas:  \n\n{% highlight csharp %}\n// t1.Item4 = 7; // Error, solo lectura\n{% endhighlight %}\n\n## Ejemplos de uso  \n\n### Como parámetros de método\nPodríamos pensar en un método como este: \n  \n{% highlight csharp %}\nstring MegaMetodoArgumentos(int studentId, int classroomId, string type, decimal sum, bool active)\n{% endhighlight %}\n\nPara llamarlo necesitaríamos escribir algo como esto:  \n\n{% highlight csharp %}\nMegaMetodoArgumentos(10, 3, \"MX\", 3.1m, true);\n{% endhighlight %}\n\nO, también podríamos haber escrito el método de la siguiente manera:  \n\n{% highlight csharp %}\nstring MegaMetodoTuple(Tuple<int, int, string, decimal, bool> args)\n{% endhighlight %}\n\nE invocarlo así:  \n\n{% highlight csharp %}\nvar tuple = Tuple.Create(10, 3, \"MX\", 3.1m, true);\nMegaMetodoTuple(tuple);  \n{% endhighlight %}\n\n### Como valores de retorno\n\nEl beneficio se nota más cuando se usa una tupa como valor de retorno, imaginemos un método en el que convertimos tomamos un color definido en hexadecimal y lo convertimos a su representación RGB en decimal.\n\nPodríamos usar [parámetros de salida](http://thatcsharpguy.com/post/out-ref-c-sharp/):  \n\n{% highlight csharp %}\nprivate static void SplitColors(string hex, out int r, out int g, out int b)\n{\n    r = Int32.Parse(hex.Substring(0, 2), NumberStyles.HexNumber);\n    g = Int32.Parse(hex.Substring(2, 2), NumberStyles.HexNumber);\n    b = Int32.Parse(hex.Substring(4, 2), NumberStyles.HexNumber);\n}\n{% endhighlight %}\n\nPero también podríamos usar una tupla como valor de retorno:  \n\n{% highlight csharp %}\nprivate static Tuple<int, int, int> SplitColors(string hex)\n{\n    int r = Int32.Parse(hex.Substring(0, 2), NumberStyles.HexNumber);\n    int g = Int32.Parse(hex.Substring(2, 2), NumberStyles.HexNumber);\n    int b = Int32.Parse(hex.Substring(4, 2), NumberStyles.HexNumber);\n    return Tuple.Create(r, g, b);\n}\n{% endhighlight %}\n\nEntonces para llamarlo, simplemente necesitaríamos escribir lo siguiente:  \n\n{% highlight csharp %}\nstring color = \"3C8A3F\";\nvar colors = SplitColors(color);\nConsole.WriteLine(\"{0} es R:{1} G:{2} B:{3}\", color, colors.Item1, colors.Item2, colors.Item3);\n{% endhighlight %}\n\n## Tuplas de 8 elementos\nSi volvemos a las definiciones de las clases `Tuple` puedes ver que existen hasta 8 versiones genéricas disponibles. Sin embargo, la octava una peculiaridad: el octavo valor no se almacena dentro de \"Item8\", sino dentro de otra tupla (a la que accedemos desde la propiedad `Rest`):  \n\n{% highlight csharp %}\nvar megaTuple = Tuple.Create(1, 2, 3, 4, 5, 6, 7, 8);\n//Console.WriteLine(miniTuple.Item8); // Item8 no existe, entonces tenemos que usar Rest:\nConsole.WriteLine(megaTuple.Rest.Item1); \n{% endhighlight %}\n\n## Ejemplo de la vida real\nMmm... en realidad no existe alguna api dentro del framework de .NET que haga uso de tuplas, pero en específico se recomienda para:\n\n - Representar un set de datos, por ejemplo, un registro en una base de datos\n - Proveer acceso fácil, y manipulación de, un set de datos\n - Regresar múltiples valores de un método sin usar parámetros por referencia\n - Enviar múltiples valores a un método\n \n## Lo que sigue\nRevisa el <a href=\"https://github.com/ThatCSharpGuy/aprende-c-sharp/tree/master/Tuples\" target=\"_blank\" rel=\"nofollow\">código que acompaña al post</a> y juegues un poco con él, sé que tal vez el asunto de los genéricos en C# puede causar un poco de confusión y es un tema que estoy planeando cubrir en un post futuro.\n"
}