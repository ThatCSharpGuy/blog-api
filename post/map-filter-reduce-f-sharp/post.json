{	
	"id" : "/post/map-filter-reduce-f-sharp/",
	"tv" : false,
	"date": "2016-07-25 14:00:00 -0500",
	"title" : "Map, reduce y filter en F#",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//map-reduce-filter/featured.png",
	"tags" : ["AprendeFSharp","ProgramaciónFuncional"],
	  
	"content": '" > Este es post es una reedición del post de <a href=\"https://twitter.com/giovanni_cortes\" target=\"_blank\">Giovanni Cortés</a> llamado <a href=\"https://giovannicortes.com/swift/map-filter-reduce-en-swift/\" target=\"_blank\">Map, filter y reduce en Swift</a>, te invito a visitarlo.  \n\n > También existe este post pero relacionado con C#, <a href=\"../map-filter-reduce-c-sharp\">visítalo aquí</a>.  \n  \nF# es un gran lenguaje, y unas de las cosas que me gusta de él es que está orientado completamente a la programación funcional. Comparte varias características con lenguajes como Elixir y otras pocas con lenguajes como Swift.\n\nUna de las características es que las funciones son tratadas como tipos, pueden aceptar funciones como parámetros y retornar funciones. A menudo a las funciones que toman como parámetros otras funciones son llamadas *funciones de orden superior*.\n\nEn este artículo vamos a enfocarnos en tres funciones que vienen incluídas en F# y que son muy poderosas cuando queremos manejar colecciones.\n\n## Map\nImaginemos que tenemos un arreglo de números enteros y a todos los elementos queremos elevarlo al cuadrado.\n\nGeneralmente haríamos una función con un bucle como el siguiente:\n\n<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><span class="err">\</span><span class="n">nlet</span> <span class="n">array</span> <span class="o">=</span> <span class="o">[|</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">6</span><span class="o">;</span> <span class="mi">7</span><span class="o">;</span> <span class="mi">8</span><span class="o">;</span> <span class="mi">9</span><span class="o">;</span> <span class="mi">10</span> <span class="o">|]</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">nlet</span> <span class="n">squareArray</span> <span class="n">arr</span> <span class="o">=</span> <span class="err">\</span><span class="n">n</span>    <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="bp">()</span><span class="err">\</span><span class="n">n</span>    <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">arr</span> <span class="k">do</span><span class="err">\</span><span class="n">n</span>        <span class="n">result</span><span class="o">.</span><span class="n">Add</span><span class="o">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">)</span><span class="err">\</span><span class="n">n</span>    <span class="n">result</span><span class="o">.</span><span class="n">ToArray</span><span class="bp">()</span><span class="err">\</span><span class="n">n</span>   <span class="err">\</span><span class="n">nlet</span> <span class="n">squaredArray</span> <span class="o">=</span> <span class="n">squareArray</span> <span class="n">array</span>  <span class="c1">// [4, 9, 16, 25, 36, 49, 64, 81, 100]\n</span></code></pre></figure>  \n\nLa función `map` resuelve el problema de transformar los elementos de un arreglo pasándoles una función. Esta función itera sobre cada elemento y a cada uno de ellos les aplica la función que nosotros pasemos como parámetro, esto nos ahorra usar mucho los *for...in...do* y además de que es más elegante. `map` retorna un arreglo de la misma longitud que el arreglo al cual le aplicamos la transformación.\n\nEl código anterior quedaría así:\n\n<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><span class="err">\</span><span class="n">nlet</span> <span class="n">array</span> <span class="o">=</span> <span class="o">[|</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">6</span><span class="o">;</span> <span class="mi">7</span><span class="o">;</span> <span class="mi">8</span><span class="o">;</span> <span class="mi">9</span><span class="o">;</span> <span class="mi">10</span> <span class="o">|]</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">nlet</span> <span class="n">squaredArray</span> <span class="o">=</span> <span class="err">\</span><span class="n">n</span>    <span class="n">array</span><span class="err">\</span><span class="n">n</span>    <span class="o">|&gt;</span> <span class="nn">Array</span><span class="p">.</span><span class="n">map</span><span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">)</span>  <span class="c1">// [4, 9, 16, 25, 36, 49, 64, 81, 100]\n</span></code></pre></figure>  \n\nEn este caso pasamos la función como una <a href=\"#\" target=\"_blank\" rel=\"nofollow\">expresión lambda</a> `fun x -> x * x`, donde `x` es cada elemento del arreglo pasado como parámetro de la expresión, y `x * x` es el cuerpo de la función, de esa forma pudimos transformar los elementos del arreglo sin crear ningún bucle.\n\n## Filter\nAl igual que `map`, `filter` es una función que itera sobre los arreglos. Como su nombre lo indica, filtra los elementos de un arreglo de acuerdo a la función que nosotros le pasemos.\n\n`filter` retorna un arreglo con los elementos filtrados del arreglo original, pudiendo ser de igual longitud, menor o vacío.\n\nSupongamos que tenemos un arreglo que representa los nombres de imágenes con diferentes extensiones y queremos obtener solo los jpg:\n\n<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><span class="err">\</span><span class="n">nlet</span> <span class="n">images</span> <span class="o">=</span> <span class="o">[|</span> <span class="err">\</span><span class="n">n</span>    <span class="err">\</span><span class="s">&quot;hello.jpg</span><span class="se">\&quot;\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">world.jpg</span><span class="se">\&quot;</span><span class="s"> </span><span class="se">\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">hola.png</span><span class="se">\&quot;</span><span class="s"> </span><span class="se">\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">mundo.png</span><span class="se">\&quot;\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">cats.jpg</span><span class="se">\&quot;</span><span class="s"> </span><span class="se">\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">dogs.png</span><span class="se">\&quot;</span><span class="s"> |]</span><span class="se">\n\n</span><span class="s">let getJpgImages images : string array = </span><span class="se">\n</span><span class="s">    let result = new List&lt;string&gt;()</span><span class="se">\n</span><span class="s">    for x : string in images do</span><span class="se">\n</span><span class="s">        if (x.EndsWith(</span><span class="se">\&quot;</span><span class="s">.jpg</span><span class="se">\&quot;</span><span class="s">)) then result.Add(x)</span><span class="se">\n</span><span class="s">    result.ToArray()</span><span class="se">\n\n</span><span class="s">let jpgImages = getJpgImages images // [</span><span class="se">\&quot;</span><span class="s">hello.jpg</span><span class="se">\&quot;</span><span class="s">, </span><span class="se">\&quot;</span><span class="s">world.jpg</span><span class="se">\&quot;</span><span class="s">, </span><span class="se">\&quot;</span><span class="s">cats.jpg</span><span class="se">\&quot;</span><span class="s">]</span><span class="se">\n</span><span class="s"></span></code></pre></figure>  \n\nAhora usemos la función `filter`:\n\n<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><span class="err">\</span><span class="n">nlet</span> <span class="n">images</span> <span class="o">=</span> <span class="o">[|</span> <span class="err">\</span><span class="n">n</span>    <span class="err">\</span><span class="s">&quot;hello.jpg</span><span class="se">\&quot;\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">world.jpg</span><span class="se">\&quot;</span><span class="s"> </span><span class="se">\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">hola.png</span><span class="se">\&quot;</span><span class="s"> </span><span class="se">\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">mundo.png</span><span class="se">\&quot;\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">cats.jpg</span><span class="se">\&quot;</span><span class="s"> </span><span class="se">\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">dogs.png</span><span class="se">\&quot;</span><span class="s"> |]</span><span class="se">\n\n</span><span class="s">let jpgImages = </span><span class="se">\n</span><span class="s">    images</span><span class="se">\n</span><span class="s">    |&gt; Array.filter(fun image -&gt; image.EndsWith(</span><span class="se">\&quot;</span><span class="s">.jpg</span><span class="se">\&quot;</span><span class="s">)) // [</span><span class="se">\&quot;</span><span class="s">hello.jpg</span><span class="se">\&quot;</span><span class="s">, </span><span class="se">\&quot;</span><span class="s">world.jpg</span><span class="se">\&quot;</span><span class="s">, </span><span class="se">\&quot;</span><span class="s">cats.jpg</span><span class="se">\&quot;</span><span class="s">]</span><span class="se">\n</span><span class="s"></span></code></pre></figure>  \n\nAl igual que `map`, no tuvimos que crear ni un *for...in...do*, ni tampoco tuvimos que agregar el elemento que estamos filtrando, solamente pasamos nuestra expresión y `filter` hace todo por nosotros.\n\n**NOT** Cabe destacar que F# infiere el tipo de la variable gracias al arreglo original, por eso podemos usar el método `EndsWith` a cada elemento porque se sabe que es un tipo cadena.\n\n### Reduce\nAl contrario que `map` y `filter`, `reduce` nos retorna un solo valor, que es la combinación de los elementos del arreglo al cual le aplicamos la función.\n\nProsigamos con el ejemplo de los números, si queremos sumar todos los elementos de un arreglo, haríamos algo como esto:\n\n<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><span class="err">\</span><span class="n">nlet</span> <span class="n">array</span> <span class="o">=</span> <span class="o">[|</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">6</span><span class="o">;</span> <span class="mi">7</span><span class="o">;</span> <span class="mi">8</span><span class="o">;</span> <span class="mi">9</span><span class="o">;</span> <span class="mi">10</span> <span class="o">|]</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">nlet</span> <span class="n">sum</span> <span class="n">arr</span> <span class="o">:</span> <span class="n">int</span> <span class="o">=</span> <span class="err">\</span><span class="n">n</span>    <span class="k">let</span> <span class="nv">mutable</span> <span class="n">result</span> <span class="o">:</span> <span class="n">int</span> <span class="o">=</span> <span class="mi">0</span><span class="err">\</span><span class="n">n</span>    <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">arr</span> <span class="k">do</span><span class="err">\</span><span class="n">n</span>        <span class="n">result</span> <span class="o">&lt;-</span> <span class="n">result</span> <span class="o">+</span> <span class="n">x</span><span class="err">\</span><span class="n">n</span>    <span class="n">result</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">nlet</span> <span class="n">arraySum</span> <span class="o">=</span> <span class="n">sum</span><span class="o">(</span><span class="n">array</span><span class="o">);</span> <span class="c1">// 54\n</span></code></pre></figure>  \n\nCuando usamos `reduce`, no solamente tenemos que pasar una función, si no también un acumulador, que es el valor inicial de nuestro contador, si es trabajo con enteros generalmente es 0, si son cadenas se pasa una cadena vacía. Depende de lo que quieras hacer.\n\nAhora el ejemplo con `reduce`:\n\n<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><span class="err">\</span><span class="n">nlet</span> <span class="n">array</span> <span class="o">=</span> <span class="o">[|</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">6</span><span class="o">;</span> <span class="mi">7</span><span class="o">;</span> <span class="mi">8</span><span class="o">;</span> <span class="mi">9</span><span class="o">;</span> <span class="mi">10</span> <span class="o">|]</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">nlet</span> <span class="n">arraySum</span> <span class="o">=</span> <span class="err">\</span><span class="n">n</span>    <span class="n">array</span><span class="err">\</span><span class="n">n</span>    <span class="o">|&gt;</span> <span class="nn">Array</span><span class="p">.</span><span class="n">reduce</span><span class="o">(</span><span class="k">fun</span> <span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span> <span class="c1">// 54\n</span></code></pre></figure>  \n\nEn este caso,  el acumulador toma el valor inicial de 0, ese valor se pasa como parámetro a la expresión lambda, al cual le pusimos como nombre `acc`. `x` es cada elemento del arreglo, y el cuerpo de nuestra lambda es la suma del acumulador y cada elemento del arreglo.\n\nComo ves, esta función es un poco más elaborada, pero una vez que le entiendas, puedes hacer muchas cosas interesantes.\n\n## Combinando todo  \n\nAhora que ya sabemos el uso de estas funciones, vamos a crear un pequeño programa donde usaremos las tres al mismo tiempo.\n\n<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><span class="err">\</span><span class="n">n</span><span class="c1">// Suponiendo que tenemos la siguiente estructura de ciudades\ntype City = \n    struct\n        val Name : string\n        val Population : int\n        new(name : string, population : int) = \n            { Population = population\n              Name = name }\n    end\n\n\n// Vamos a definir varios ejemplos de ciudades, y meterlos en un arreglo\nlet paris = new City(\&quot;Paris\&quot;, 2243)\nlet madrid = new City(\&quot;Madrid\&quot;, 3216)\nlet amsterdam = new City(\&quot;Amsterdam\&quot;, 811)\nlet berlin = new City(\&quot;Berlin\&quot;, 3397)\n\nlet cities = [|paris;madrid;amsterdam;berlin|]\n\n// Como tenemos las ciudades con poca población, vamos a escribir una función\n// que nos ayude a escalar la población\nlet scale(city : City ) : City =\n    new City ( city.Name, city.Population * 1000)\n\n// Ya teniendo todo, vamos a escribir todas las ciudades cuya población\n// sea mayor a 1 millón de habitantes\nlet citiesFilter = \n    cities\n    |&gt; Array.filter(fun city -&gt; city.Population &gt; 1000)\n    |&gt; Array.map(scale)\n    |&gt; Array.fold(fun result c -&gt; result + sprintf \&quot;\\n%s: %d\&quot; c.Name c.Population ) \&quot;City population\&quot;\n\nSystem.Console.WriteLine(citiesFilter)\n\n// City population\n// Paris: 2243000\n// Madrid: 3216000\n// Berlin: 3397000\n</span></code></pre></figure>  \n\nListo, tenemos nuestro programa funcionando y filtrando las ciudades, sin necesidad de usar bucles, además que gracias al acumulador usado como cadena, podemos imprimir nuestras ciudades en un lindo formato.\n\nEspero te haya convencido de que empieces a usar estas funciones en tu programa, verás cómo vas a ir haciendo un código mucho más elegante y funcional.\n"'   
}