{	
	"id" : "/post/xamarin-userdialogs/",
	"tv" : false,
	"date": "2017-01-17 13:00:01 -0600",
	"title" : "UserDialogs en Xamarin Forms",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//xamarin-forms/userdialogs/featured.jpg",
	"tags" : ["Xamarin","XamarinForms","NuGetRecomendado"],
	"content": "<p>Creo que todos estamos de acuerdo en que Xamarin.Forms es fantástico… sin embargo no soluciona todos nuestros problemas cuando desarrollamos.</p>\n\n<p>Una de las principales “fallas” es la falta de una forma avanzada de mostrar mensajes al usuario. Sí, sí, con Xamarin.Forms tenemos los métodos <code>DisplayAlert</code>:</p>\n\n<pre class=\"csharp\">\nawait DisplayAlert(\"Traditional alert\", \"Traditional message\", \"It's not so cool\");\n\nvar result = await DisplayAlert(\"Traditional alert\", \"Traditional message?\", \"OK\", \"Cancel\");\nTraditionalPromptLabel.Text = string.Format(\"Result 0\", result);\n</pre>\n\n<p>Estos métodos solamente muestran un mensaje sencillo y permiten que el usuario responda con un valor booleano, y además requieren de tener una referencia a la página en la que queremos mostrar la alerta.</p>\n\n<p>Es por eso que cuando queremos obtener más información de quien está usando nuesta app podemos recurrir a un paquete de NuGet que nos permitirá hacer operaciones como:</p>\n\n<h2 id=\"mostrar-un-mensaje-toast\">Mostrar un mensaje “Toast”</h2>\n<p>Con <em>UserDialogs</em> podemos mostrar mensajes en varias plataformas de manera que en Android lo hacemos con la popular <code>Toast</code>:</p>\n\n<pre class=\"csharp\">\nUserDialogs.Instance.Toast(\"Toast message: &lt;3\", TimeSpan.FromMilliseconds(millis));\n</pre>\n\n<p>post_image toast.png “Login prompt”</p>\n\n<h2 id=\"mostrar-un-error\">Mostrar un error</h2>\n<pre class=\"csharp\">\nUserDialogs.Instance.ShowError(\"¡Error!\", millis);\n</pre>\n\n<h2 id=\"mostrar-un-mensaje-de-xito\">Mostrar un mensaje de éxito</h2>\n<pre class=\"csharp\">\nUserDialogs.Instance.ShowSuccess(\"¡Éxito!\", millis);\n</pre>\n\n<p>Pero no solo eso, también podemos recibir información a través de UserDialogs</p>\n\n<h2 id=\"promptasync\">PromptAsync</h2>\n<p>Solicitar información del usuario, ya sea que estés buscando un nombre, un teléfono, un password…</p>\n\n<pre class=\"csharp\">\nvar promptConfig = new PromptConfig();\npromptConfig.InputType = InputType.Name;\npromptConfig.IsCancellable = true;\npromptConfig.Message = \"Write your name\";\nvar result = await UserDialogs.Instance.PromptAsync(promptConfig);\nif (result.Ok)\n\n    PromptedTextLabel.Text = result.Text;\n\n</pre>\n\n<p>post_image text.png “Text prompt”</p>\n\n<h2 id=\"promptdateasync\">PromptDateAsync</h2>\n<p>Solicitar una fecha, presentando un control muy familiar dependiendo de la plataforma en que se ejecute:</p>\n\n<pre class=\"csharp\">\nvar result = await UserDialogs.Instance.DatePromptAsync(\n    \"Select date\",\n    DateTime.Now);\nif (result.Ok)\n    SelectedDateLabel.Text = String.Format(\"0:dd MMMM yyyy\", result.SelectedDate);\n</pre>\n\n<p>post_image calendar.png “Calendar prompt”</p>\n\n<h2 id=\"prompttimeasync\">PromptTimeAsync</h2>\n<p>Al igual que con la fecha, este diálogo presenta un contol para seleccionar una hora</p>\n\n<pre class=\"csharp\">\nvar result = await UserDialogs.Instance.TimePromptAsync(\n    \"Select time\",\n    DateTime.Now.TimeOfDay);\nif (result.Ok)\n    SelectedTimeLabel.Text = String.Format(\"0:hh-mm\", new DateTime(result.SelectedTime.Ticks));\n</pre>\n\n<p>post_image time.png “Time prompt”</p>\n\n<h2 id=\"promptloginasync\">PromptLoginAsync</h2>\n<p>Si quieres algo un poco más compuesto como una “pantalla” de <em>login</em>, también puedes usar esta pequeña librería:</p>\n\n<pre class=\"csharp\">\nvar loginResult = await UserDialogs.Instance.LoginAsync(\"Login\", \"Please sign in\");\nif (loginResult.Ok)\n\n    PromptedLoginLabel.Text = String.Format(\"0:1\", loginResult.Value.UserName, loginResult.Value.Password);\n\n</pre>\n\n<p>post_image login.png “Login prompt”</p>\n\n<h2 id=\"inyeccin-de-dependencias\">Inyección de dependencias</h2>\n<p>Como mencioné anteriormente el mecanismo de diálogos que provee Forms por default requieren de tener una referencia a la página en la que estamos trabajando, sin embargo <em>UserDialogs</em> no, y eso lo hace ideal para usarlo en conjunto con una solución de <a href=\"http://thatcsharpguy.com/tv/inyeccion-dependencias/\" target=\"_blank\">inyección de dependencias</a>.</p>\n\n<h2 id=\"personalizacin\">Personalización</h2>\n<p>En este post mostré únicamente las opciones más sencillas de esta librería, sin embargo también podemos personalizarla casi tanto como deseamos, es por eso que te propongo que <a href=\"https://github.com/ThatCSharpGuy/UserDialogs-Sample\" target=\"_blank\">descargues el código</a> de ejemplo y practiques con él.</p>\n\n<h1 id=\"instalacin\">Instalación</h1>\n<p>Como siempre, hay que buscar en el gestor de paquetes de NuGet: <code>Acr.UserDialogs</code></p>\n\n<p>O desde la consola:</p>\n\n<p>console titulo \nPM&gt; Install-Package Acr.UserDialogs\n endconsole</p>\n\n<p>Recuerda que si lo usas en Xamarin.Forms debes instalar Acr.UserDialogs en todos tus proyectos (núcleo y clientes) para que funcione correctamente.</p>\n"
}