{	
	"id" : "/post/sobrecarga-operadores/",
	"tv" : false,
	"date": "2016-12-20 13:00:02 -0600",
	"title" : "Sobrecarga de operadores",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages/aprende-c-sharp/sobrecarga.jpg",
	"tags" : ["AprendeCSharp"],
	  
	"content": '"Hoy toca hablar de una de las características menos usadas (porque en teoría es mejor no usarlas) de C#. \n\nSobrecargar operadores nos ayudará a emplear los operadores comunes como `+`, `-`, `==` para nuestros los tipos de dato que creamos para nuestra aplicación. Pero antes de entrar en el tema, pongámonos un poco festivos y creemos una clase llamada `Toy` que representará un juguete, el cual debe tener un precio y un nombre:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npublic</span> <span class="k">class</span> <span class="nc">Toy</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span><span class="err">\</span><span class="n">n</span>    <span class="k">public</span> <span class="kt">double</span> <span class="n">Price</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span><span class="err">\</span><span class="n">n</span>    <span class="c1">// ...\n</span></code></pre></figure>  \n\nCreamos unos cuantos juguetes:   \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">buzzLightyear</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Toy</span> <span class="p">{</span> <span class="n">Name</span> <span class="p">=</span> <span class="err">\</span><span class="s">&quot;Buzz\&quot;, Price = 20 };\nvar woody = new Toy { Name = \&quot;Woody\&quot;, Price = 20 };\nvar dory = new Toy { Name = \&quot;Dory\&quot;, Price = 15 };\nvar marlin = new Toy { Name = \&quot;Marlin\&quot;, Price = 15 };\nvar nemo = new Toy { Name = \&quot;Nemo\&quot;, Price = 15 };\nvar mikey = new Toy { Name = \&quot;Michelangelo\&quot;, Price = 25 };\nvar leo = new Toy { Name = \&quot;Leonardo\&quot;, Price = 25 };\nvar donny = new Toy { Name = \&quot;Donatello\&quot;, Price = 25 };\nvar raph = new Toy { Name = \&quot;Raphael\&quot;, Price = 25 };\nvar splinter = new Toy { Name = \&quot;Master Splinter\&quot;, Price = 30 };\n</span></code></pre></figure>  \n\n## Intro  \n\nAhora, en la aplicación que estamos desarrollando necesitamos saber si dos juguetes son iguales, o si uno es más caro que el otro. Nos queda claro que siempre podríamos hacer comparaciones como `buzzLightyear.Price > woody.Price` para saber si uno vale más que el otro... pero, ¿y si mejor sobrecargamos el operador `>` para poder comparar los juguetes directamente?\n\nPara sobrecargar un operador es necesario escribir unas líneas de código parecidas a cuando definimos un método público estático en una clase:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npublic</span> <span class="k">static</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="p">&lt;(</span><span class="n">Toy</span> <span class="n">a</span><span class="p">,</span> <span class="n">Toy</span> <span class="n">b</span><span class="p">)</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">Price</span> <span class="p">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Price</span><span class="p">;</span><span class="err">\</span><span class="n">n</span><span class="p">}</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\nComo puedes ver tenemos los modificadores `public` y `static`, junto con el tipo de retorno (que es `bool`) y la palabra clave `operator` seguida del operador que queremos sobrecargar. Este \"método\" recibe dos parámetros de los cuales uno de ellos debe ser el tipo en el que está definido (en este caso `Toy`).\n\nPor ejemplo, podríamos sobrecargar `<` de esta manera: \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npublic</span> <span class="k">static</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="p">&lt;(</span><span class="n">Toy</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">price</span><span class="p">)</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\nPara poder comparar un `Toy` contra un valor de tipo doble: `leo < 10d`, es importante que tomes en cuenta que únicamente puedes comparar \"Toy < Double\" y no \"Double < Toy\", para esto deberías sobrecargar nuevamente el operador pero invirtiendo el orden de los parámetros (`<(double price, Toy a)`).\n\n### Operadores sobrecargables  \nLos operadores que pueden ser sobrecargados son los siguientes:  \n\n<table>\n    <tr>\n        <td><b>Operadores</b></td>\n        <td><b>Tipo</b></td>\n    </tr>\n    <tr>\n        <td>+, -, !, ~, ++, --, true, false</td>\n        <td>Unarios</td>\n    </tr>\n    <tr>\n        <td>+, -, *, /, %, &amp;, |, ^, &lt;&lt;, &gt;&gt;</td>\n        <td>Binarios</td>\n    </tr>\n    <tr>\n        <td>==, !=, &lt;, &gt;, &lt;=, &gt;=</td>\n        <td>Comparación*</td>\n    </tr>\n</table>\n\n### *Operadores complementarios\nLos operadores de comparación son un caso muy peculiar, ya que es necesario siempre sobrecargarlos en pares: `=` y `!=`, `<` y `>`, `<=` y `>=`. Es decir, en nuestro ejemplo anterior también debemos crear una sobrecarga así: \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npublic</span> <span class="k">static</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="p">&gt;(</span><span class="n">Toy</span> <span class="n">a</span><span class="p">,</span> <span class="n">Toy</span> <span class="n">b</span><span class="p">)</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="c1">// ...\n</span></code></pre></figure>   \n\nYa que de no hacerlo, nuestro programa no compilaría.\n\nEn el código de ejemplo que puedes descargar de GitHub están todos los operadores de comparación sobrecargados, gracias a lo cual podemos ejecutar código como el siguiente:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">dory</span><span class="p">.</span><span class="n">Name</span> <span class="p">+</span> <span class="err">\</span><span class="s">&quot;&gt;\&quot; + woody.Name + \&quot;: \&quot; + (dory &gt; woody));\nConsole.WriteLine(dory.Name + \&quot;&lt;\&quot; + woody.Name + \&quot;: \&quot; + (dory &lt; woody));\nConsole.WriteLine(buzzLightyear.Name + \&quot;==\&quot; + woody.Name + \&quot; = \&quot; + (buzzLightyear == woody));\nConsole.WriteLine(dory.Name + \&quot;==\&quot; + woody.Name + \&quot;: \&quot; + (dory == woody));\nConsole.WriteLine(splinter.Name + \&quot;&gt;=\&quot; + woody.Name + \&quot;: \&quot; + (splinter &gt;= woody));\nConsole.WriteLine(leo.Name + \&quot;&lt;=\&quot; + raph.Name + \&quot;: \&quot; + (leo &lt;= raph));\n</span></code></pre></figure>  \n\nQue imprimirá: \n\n<pre>\nDory>Woody: False\nDory<Woody: True\nBuzz==Woody = True\nDory==Woody: False\nMaster Splinter>=Woody: True\nLeonardo<=Raphael: True\n</pre>\n\n## Más sobrecargas    \nAhora, supón que tu aplicación también debe poder generar paquetes de juguetes, que representaremos con la clase `Bundle` (que <a href=\"../yield-c-sharp\">implementa IEnumerable</a>):  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npublic</span> <span class="k">class</span> <span class="nc">Bundle</span> <span class="p">:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Toy</span><span class="p">&gt;</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="k">public</span> <span class="kt">int</span> <span class="n">Size</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span><span class="err">\</span><span class="n">n</span>    <span class="k">public</span> <span class="kt">int</span> <span class="n">ToyCount</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_storage</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span><span class="err">\</span><span class="n">n</span>    <span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Toy</span><span class="p">&gt;</span> <span class="n">_storage</span><span class="p">;</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">n</span>    <span class="k">public</span> <span class="n">Bundle</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span><span class="err">\</span><span class="n">n</span>    <span class="p">{</span><span class="err">\</span><span class="n">n</span>        <span class="n">Size</span> <span class="p">=</span> <span class="n">size</span><span class="p">;</span><span class="err">\</span><span class="n">n</span>        <span class="n">_storage</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Toy</span><span class="p">&gt;(</span><span class="n">Size</span><span class="p">);</span><span class="err">\</span><span class="n">n</span>    <span class="p">}</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">n</span>    <span class="k">public</span> <span class="kt">bool</span> <span class="n">TryAddToy</span><span class="p">(</span><span class="n">Toy</span> <span class="n">t</span><span class="p">)</span><span class="err">\</span><span class="n">n</span>    <span class="p">{</span><span class="err">\</span><span class="n">n</span>        <span class="k">if</span> <span class="p">(</span><span class="n">ToyCount</span> <span class="p">&gt;=</span> <span class="n">Size</span><span class="p">)</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span><span class="err">\</span><span class="n">n</span>        <span class="n">_storage</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="err">\</span><span class="n">n</span>        <span class="k">return</span> <span class="k">true</span><span class="p">;</span><span class="err">\</span><span class="n">n</span>    <span class="p">}</span><span class="err">\</span><span class="n">n</span>    <span class="c1">// ...\n</span></code></pre></figure>  \n\nComo puedes ver, existe un método llamado `TryAddToy` que nos ayudará a agregar un nuevo juguete al paquete, pero... ¿no sería genial que pudiéramos \"sumar\" juguetes y que de ellos resulte un paquete nuevo?\n\nEs entonces cuando aparece nuevamente la sobrecarga de operadores como una alternativa que nos permite realizar lo que queremos. Los pasos a seguir son muy similares a sobrecargar los otros operadores, con la diferencia de que el tipo de retorno puede ser cualquiera:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npublic</span> <span class="k">static</span> <span class="n">Bundle</span> <span class="k">operator</span> <span class="p">+(</span><span class="n">Toy</span> <span class="n">a</span><span class="p">,</span> <span class="n">Toy</span> <span class="n">b</span><span class="p">)</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="n">Bundle</span> <span class="n">bundle</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Bundle</span><span class="p">(</span><span class="m">2</span><span class="p">);</span><span class="err">\</span><span class="n">n</span>    <span class="n">bundle</span><span class="p">.</span><span class="n">TryAddToy</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="err">\</span><span class="n">n</span>    <span class="n">bundle</span><span class="p">.</span><span class="n">TryAddToy</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="err">\</span><span class="n">n</span>    <span class="k">return</span> <span class="n">bundle</span><span class="p">;</span><span class="err">\</span><span class="n">n</span><span class="p">}</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\nNuevamente `public static`, el tipo de retorno que en este caso es `Bundle`, la palabra `operator` y el operador a sobrecargar seguido de los dos parámetros (de los cuales al menos uno tiene que ser el tipo de dato en el que está definido).\n\nUna vez hecho esto, podemos escribir código como el siguiente:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nBundle</span> <span class="n">toyStoryBundle</span> <span class="p">=</span> <span class="n">buzzLightyear</span> <span class="p">+</span> <span class="n">woody</span><span class="p">;</span><span class="err">\</span><span class="n">nConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">toyStoryBundle</span><span class="p">);</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\nY se compilará y ejecutará sin problema, dejando como resultado el siguiente:  \n\n<pre>\nBundle (2/2) [Buzz, Woody]\n</pre>\n\nAl igual que con la comparación, también podemos sumar objetos de distinto tipo, siempre prestando atención al orden de los parámetros, de tal manera que podemos definir sumas de este modo dentro de la clase `Bundle`:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">npublic</span> <span class="k">static</span> <span class="n">Bundle</span> <span class="k">operator</span> <span class="p">+(</span><span class="n">Bundle</span> <span class="n">bundle</span><span class="p">,</span> <span class="n">Toy</span> <span class="n">t</span><span class="p">)</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="kt">var</span> <span class="n">newBundle</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Bundle</span><span class="p">(</span><span class="n">bundle</span><span class="p">.</span><span class="n">Size</span> <span class="p">+</span> <span class="m">1</span><span class="p">);</span><span class="err">\</span><span class="n">n</span>    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">toy</span> <span class="k">in</span> <span class="n">bundle</span><span class="p">)</span><span class="err">\</span><span class="n">n</span>    <span class="p">{</span><span class="err">\</span><span class="n">n</span>        <span class="n">newBundle</span><span class="p">.</span><span class="n">TryAddToy</span><span class="p">(</span><span class="n">toy</span><span class="p">);</span><span class="err">\</span><span class="n">n</span>    <span class="p">}</span><span class="err">\</span><span class="n">n</span>    <span class="n">newBundle</span><span class="p">.</span><span class="n">TryAddToy</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="err">\</span><span class="n">n</span>    <span class="k">return</span> <span class="n">newBundle</span><span class="p">;</span><span class="err">\</span><span class="n">n</span><span class="p">}</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">npublic</span> <span class="k">static</span> <span class="n">Bundle</span> <span class="k">operator</span> <span class="p">+(</span><span class="n">Toy</span> <span class="n">t</span><span class="p">,</span> <span class="n">Bundle</span> <span class="n">bundle</span><span class="p">)</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span>    <span class="k">if</span> <span class="p">(!</span><span class="n">bundle</span><span class="p">.</span><span class="n">TryAddToy</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="err">\</span><span class="n">n</span>        <span class="k">throw</span> <span class="k">new</span> <span class="n">InvalidOperationException</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;Bundle is already full!\&quot;);\n    return bundle;\n}\n</span></code></pre></figure>  \n\nComo te puedes dar cuenta a pesar de que parece que se sobrecarga el mismo operador, los métodos realizan distintas acciones, que podemos probar con el siguiente código:\n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">findingNemoBundle</span> <span class="p">=</span> <span class="n">dory</span> <span class="p">+</span> <span class="n">marlin</span> <span class="p">+</span> <span class="n">nemo</span><span class="p">;</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\nEl orden de ejecución es el siguiente:  \n\n 1. `dory + marlin` generan un nuevo `Bundle` de tamaño 2\n 2. A este nuevo bundle se le suma `nemo`\n 3. Obtenemos un nuevo `Bundle` de tamaño 3\n\nSi quisieramos ejecutar algo como esto:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">findingNemoBundle</span> <span class="p">=</span> <span class="n">dory</span> <span class="p">+</span> <span class="p">(</span><span class="n">marlin</span> <span class="p">+</span> <span class="n">nemo</span><span class="p">);</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\nObtendríamos un nuevo orden de ejecución:  \n\n 1. `marlin + nemo` generan un nuevo `Bundle` de tamaño 2\n 2. A este nuevo bundle se le suma `dory`\n 3. Obtenemos una excepción ya que esta sobrecarga no permite añadir un juguete si el paquete ya no tiene espacio.\n\n### Operadores de asignación  \nLos operadores de asignación (`+=`, `/=`, ...) no son sobrecargables, pero dependein implícitamente de lo que hagas con los operadores binarios (`+`, `/`, ...)\nya que esto:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">ntortugasNinja</span> <span class="p">+=</span> <span class="n">raph</span><span class="p">;</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\nSe convierte en esto:  \n\n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">ntortugasNinja</span> <span class="p">=</span> <span class="n">tortugasNinja</span> <span class="p">+</span> <span class="n">raph</span><span class="p">;</span><span class="err">\</span><span class="n">n</span></code></pre></figure>  \n\n## Un consejo  \nSí la sobrecarga de operadores es fantástica y puede hacer que tu código se vea más limpio y con mayor contexto. Sin embargo, debes tener en cuenta que como todo en esta vida, debes usarlo con medida ya que en caso de abusar podrías hacer que el programa que estás haciendo se vuelva ilegible y poco mantenible.  \n\nAh, y no olvides que el orden de los parámetros en la sobrecarga importa mucho.  \n\n"'   
}