{	
	"id" : "/post/tipos-nullables-en-c-sharp/",
	"tv" : false,
	"date": "2015-10-14 15:30:00 -0500",
	"title" : "Tipos nullables en C#",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimagesfeatured.png",
	"tags" : ["AprendeCSharp"],
	  
	"content": '"En un post anterior hablaba acerca de los tipos de dato en C#, y me doy cuenta que se me olvidó mencionar una característica importante de los tipos de dato, y para rectificar mi error voy a tomar la clasificación por referencia y valor de la que les platicaba.  \n\n### Apuntando a la nada  \n  \nLos tipos por referencia son *nullables* por definición. ¿Qué implica que sean *nullables*? pues nada más y nada menos que puedan tener un valor `null` o en términos prácticos, nungún valor. Esto se puede explicar desde el nombre mismo, al ser referencias estas **pueden estar referenciando a un valor o a la nada** (a `null`).\n\nPor otro lado, los **tipos por valor siempre tienen un valor** (valga la redundancia) asignado. Es así que un `int`, `bool`, `double`, etcétera nunca podrán valer *null*. Y es que estos no hacen referencia a ningún valor, sino que son el valor mismo.  \n  \nMuchas veces esta limitante nos lleva a inventarnos *números mágicos* como por ejemplo usar el <code>-1</code> para decir que un entero no tiene valor, o lógicas extrañas dentro de nuestro programa como decir que si un `DateTime` vale `DateTime.MinValue` es porque no tiene valor.  También nos complica un poco la vida cuando se trabaja con bases de datos en donde los datos pueden tener un valor o estar indefinidos.\n  \n### La estructura Nullable&lt;T&gt;  \nPara nuestra fortuna, C# nos ofrece los *nullable types*, que son instancias de la estructura `Nullable<T>` (si no estás familiarizado con la sintaxis `<>` pronto la explicaré en un post, es maravillosa), donde `T` es un tipo por valor.  \n\nPodemos ver esta estructura como una especie de caja para nuestros tipos por valor, dicha caja provee métodos para saber si contiene un valor y obtener el valor que contiene.  \n\n\n#### Trabajando con Nullable&lt;T&gt;  \nLa sintaxis de estos tipos no es muy complicada, y es que además de la declaración convencional:  \n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nNullable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">enteroNullable</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span><span class="err">\</span><span class="n">nNullable</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;</span> <span class="n">puedeValerNull</span> <span class="p">=</span> <span class="m">9.9</span><span class="p">;</span><span class="err">\</span><span class="n">n</span></code></pre></figure>\nTambién podemos usar el símbolo (<code>?</code>) en la declaración de la variable para indicar que se trata de un tipo nullable:  \n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nint</span><span class="p">?</span> <span class="n">enteroNullable</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span><span class="err">\</span><span class="n">ndouble</span><span class="p">?</span> <span class="n">puedeValerNull</span> <span class="p">=</span> <span class="m">9.9</span><span class="p">;</span><span class="err">\</span><span class="n">n</span></code></pre></figure>\nAunque en este punto debemos ser cuidadosos, ya que la sintaxis es un poco confusa, ya sabemos, <code>Nullable</code> es una estructura y las estructuras no pueden tener un valor `null`...  ¿entonces qué sucede al momento de asignar un valor a `enteroNullable` en  el código anterior?  \nComo dije anteriormente, los tipos nullables son como una caja, al asignarle <code>null</code> estamos creando una caja que puede contener un <code>int</code> pero que al momento estamos dejando vacía. Podemos entonces trabajar con nuestra variable:  \n\n\n<figure><img src='/postimages/post/tipos-nullables-en-c-sharp/post.jsonboxes.png' alt='Tipos por valor images_set' /></figure>\n\n##### Obteniendo un el valor (o una excepción)  \nPara obtener el valor contenido dentro de un *nullable*, tenemos a nuestra disposición la propiedad <code>Value</code>, que debemos usar con cuidado, puesto que en caso de que el *nullable* no tenga un valor asignado, lanzará una exepción del tipo `InvalidOperationException`. \n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nenteroNullable</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span><span class="err">\</span><span class="n">n</span><span class="c1">// int enteroExcepcional = enteroNullable.Value; \n// Este código lanza una excepcion ^\n\nenteroNullable = 5;\nint sinExcepciones = enteroNullable.Value;\n</span></code></pre></figure>    \n\n##### Comprobando si tiene un valor  \nSi lo que queremos es evitarnos manejar exepciones, conocer si nuestra variable tiene un valor asignado con la propiedad `HasValue` \n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nif</span><span class="p">(</span><span class="n">enteroNullable</span><span class="p">.</span><span class="n">HasValue</span><span class="p">)</span><span class="err">\</span><span class="n">n</span><span class="p">{</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">tConsole</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">\</span><span class="s">&quot;La caja está llena\&quot;);\n}\nelse \n{\n\tConsole.WriteLine(\&quot;La caja está vacía :(\&quot;);\n}\n</span></code></pre></figure>    \n  \n##### Obteniendo un valor por default  \nSi lo que de verdad nos interesa es obtener un valor de nuestra variable, podemos usar `GetValueOrDefaut`, que es un método que podemos usar para asegurarnos que no nos encontraremos con una exepción al consultar el valor. Lo que nos devolverá el método es:  \n  \n - El valor contenido dentro del *nullable*, si tiene alguno\n - El valor por default del tipo de nuestro *nullable*, si este no tiene alguno o el valor que usemos como parámetro en nuestro método `GetValueOrDefaut`.\n \n<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="err">\</span><span class="n">nenteroNullable</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">nint</span> <span class="n">defaultValue</span> <span class="p">=</span> <span class="n">enteroNullable</span><span class="p">.</span><span class="n">GetValueOrDefault</span><span class="p">();</span><span class="err">\</span><span class="n">n</span><span class="c1">// defaultValue == 0\n\nint noTanDefaultValue = enteroNullable.GetValueOrDefault(8);\n// noTanDefaultValue == 8\n\nenteroNullable = 100; // Le asignamos un valor a la variable\nint realValue = enteroNullable.GetValueOrDefault();\n// realValue == 100\n</span></code></pre></figure>      \n  \n<br />\nAhora sí: en futuros post seguré explorando algunos detalles escenciales de C#, como arreglos, métodos y clases.\n\n"'   
}