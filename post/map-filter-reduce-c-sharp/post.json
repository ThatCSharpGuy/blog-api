{	
	"id" : "/post/map-filter-reduce-c-sharp/",
	"tv" : false,
	"date": "2016-07-25 14:00:00 -0500",
	"title" : "Map, reduce y filter en C#",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//map-reduce-filter/featured.png",
	"tags" : ["AprendeCSharp","ProgramaciónFuncional"],
	  
	"content": '" > Este es post es una reedición del post de <a href=\"https://twitter.com/giovanni_cortes\" target=\"_blank\">Giovanni Cortés</a> llamado <a href=\"https://giovannicortes.com/swift/map-filter-reduce-en-swift/\" target=\"_blank\">Map, filter y reduce en Swift</a>, te invito a visitarlo.  \n\n > También existe este post pero relacionado con F#, <a href=\"../map-filter-reduce-f-sharp\">visítalo aquí</a>.\n\nC# es un gran lenguaje, y unas de las cosas que me gusta de él, es que puedes programar funcionalmente aún si el lenguaje no es 100% funcional. Comparte algunas de sus características con lenguajes como Swift y F#.\n\nUna de las características es que las los métodos pueden ser tratadas como tipos, pueden aceptar métodos como parámetros y retornar métodos. A menudo a los métodos que toman como parámetros otros métodos son llamados *funciones de orden superior*.\n\nEn este artículo vamos a enfocarnos en tres métodos que vienen incluídos en el framework (dentro de System.Linq) y que son muy poderosos cuando queremos manejar colecciones.\n\n## Map (Select)\nImaginemos que tenemos un arreglo de números enteros y a todos los elementos queremos elevarlo al cuadrado.\n\nGeneralmente haríamos una método con un bucle como el siguiente:\n\n<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="o">{</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">10</span> <span class="o">};</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">nstatic</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">SquareArray</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">arr</span><span class="o">)</span><span class="err">\</span><span class="n">n</span><span class="o">{</span><span class="err">\</span><span class="n">n</span>    <span class="n">var</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="bp">()</span><span class="o">;</span><span class="err">\</span><span class="n">n</span>    <span class="n">foreach</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span> <span class="k">in</span> <span class="n">arr</span><span class="o">)</span><span class="err">\</span><span class="n">n</span>        <span class="n">result</span><span class="o">.</span><span class="n">Add</span><span class="o">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">);</span><span class="err">\</span><span class="n">n</span>    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">ToList</span><span class="bp">()</span><span class="o">;</span><span class="err">\</span><span class="n">n</span><span class="o">}</span><span class="err">\</span><span class="n">n</span>   <span class="err">\</span><span class="n">nvar</span> <span class="n">squaredArray</span> <span class="o">=</span> <span class="n">SquareArray</span><span class="o">(</span><span class="n">array</span><span class="o">);</span> <span class="c1">// [4, 9, 16, 25, 36, 49, 64, 81, 100]\n</span></code></pre></figure>  \n\nEl método `Select` resuelve el problema de transformar los elementos de un arreglo pasándoles una método. Este método itera sobre cada elemento y a cada uno de ellos les aplica el método que nosotros pasemos como parámetro, esto nos ahorra usar mucho los *foreach* y además de que es más elegante. `Select` retorna un una colección de la misma longitud que la coleccion a la cual le aplicamos la transformación.\n\nEl código anterior quedaría así:\n\n<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="o">{</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">10</span> <span class="o">};</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">nvar</span> <span class="n">squaredArray</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">Select</span><span class="o">(</span><span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">).</span><span class="n">ToArray</span><span class="bp">()</span><span class="o">;</span> <span class="c1">// [4, 9, 16, 25, 36, 49, 64, 81, 100]\n</span></code></pre></figure>  \n\nEn este caso pasamos la el método como una <a href=\"#\" target=\"_blank\" rel=\"nofollow\">expresión lambda</a> `x => x * x`, donde `x` es cada elemento del arreglo pasado como parámetro de la expresión, y `x * x` es el cuerpo del método, de esa forma pudimos transformar los elementos del arreglo sin crear ningún bucle.\n\n## Filter (Where)\nAl igual que `Select`, `Where` es un método que itera sobre los arreglos. Como su nombre lo indica, filtra los elementos de un arreglo de acuerdo a la función que nosotros le pasemos.\n\n`Where` retorna una colección con los elementos filtrados de la colección original, pudiendo ser de igual longitud, menor o vacía.\n\nSupongamos que tenemos una colección que representa los nombres de imágenes con diferentes extensiones y queremos obtener solo los jpg:\n\n<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">images</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span> <span class="o">{</span><span class="err">\</span><span class="n">n</span>    <span class="err">\</span><span class="s">&quot;hello.jpg</span><span class="se">\&quot;</span><span class="s">,</span><span class="se">\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">world.jpg</span><span class="se">\&quot;</span><span class="s">,</span><span class="se">\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">hola.png</span><span class="se">\&quot;</span><span class="s">,</span><span class="se">\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">mundo.png</span><span class="se">\&quot;</span><span class="s">,</span><span class="se">\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">cats.jpg</span><span class="se">\&quot;</span><span class="s">,</span><span class="se">\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">dogs.png</span><span class="se">\&quot;\n</span><span class="s">};</span><span class="se">\n\n</span><span class="s">public static List&lt;string&gt; GetJpgImages(List&lt;string&gt; images)</span><span class="se">\n</span><span class="s">{</span><span class="se">\n</span><span class="s">    var results = new List&lt;string&gt;();</span><span class="se">\n</span><span class="s">    foreach (var image in images)</span><span class="se">\n</span><span class="s">        if (image.EndsWith(</span><span class="se">\&quot;</span><span class="s">.jpg</span><span class="se">\&quot;</span><span class="s">))</span><span class="se">\n</span><span class="s">            results.Add(image);</span><span class="se">\n</span><span class="s">    return results;</span><span class="se">\n</span><span class="s">}</span><span class="se">\n\n</span><span class="s">var jpgImages = GetJpgImages(images); // [</span><span class="se">\&quot;</span><span class="s">hello.jpg</span><span class="se">\&quot;</span><span class="s">, </span><span class="se">\&quot;</span><span class="s">world.jpg</span><span class="se">\&quot;</span><span class="s">, </span><span class="se">\&quot;</span><span class="s">cats.jpg</span><span class="se">\&quot;</span><span class="s">]</span><span class="se">\n</span><span class="s"></span></code></pre></figure>  \n\nAhora usemos el método `Where`:\n\n<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">images</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span> <span class="o">{</span><span class="err">\</span><span class="n">n</span>    <span class="err">\</span><span class="s">&quot;hello.jpg</span><span class="se">\&quot;</span><span class="s">,</span><span class="se">\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">world.jpg</span><span class="se">\&quot;</span><span class="s">,</span><span class="se">\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">hola.png</span><span class="se">\&quot;</span><span class="s">,</span><span class="se">\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">mundo.png</span><span class="se">\&quot;</span><span class="s">,</span><span class="se">\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">cats.jpg</span><span class="se">\&quot;</span><span class="s">,</span><span class="se">\n</span><span class="s">    </span><span class="se">\&quot;</span><span class="s">dogs.png</span><span class="se">\&quot;\n</span><span class="s">};</span><span class="se">\n\n</span><span class="s">var jpgImages = images</span><span class="se">\n</span><span class="s">                .Where(image =&gt; image.EndsWith(</span><span class="se">\&quot;</span><span class="s">.jpg</span><span class="se">\&quot;</span><span class="s">))</span><span class="se">\n</span><span class="s">                .ToList(); // [</span><span class="se">\&quot;</span><span class="s">hello.jpg</span><span class="se">\&quot;</span><span class="s">, </span><span class="se">\&quot;</span><span class="s">world.jpg</span><span class="se">\&quot;</span><span class="s">, </span><span class="se">\&quot;</span><span class="s">cats.jpg</span><span class="se">\&quot;</span><span class="s">]</span><span class="se">\n</span><span class="s"></span></code></pre></figure>  \n\nAl igual que con `Select`, no tuvimos que crear ni un *foreach*, ni tampoco tuvimos que agregar el elemento que estamos filtrando, solamente pasamos nuestra expresión y `Where` hace todo por nosotros.\n\n### Reduce (Aggregate)\nAl contrario que `Select` y `Where`, `Aggregte` nos retorna un solo valor, que es la combinación de los elementos de la colección a la cual le aplicamos la el método.\n\nProsigamos con el ejemplo de los números, si queremos sumar todos los elementos de una lista, haríamos algo como esto:\n\n<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="o">{</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">10</span> <span class="o">};</span>   <span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">npublic</span> <span class="k">static</span> <span class="n">int</span> <span class="n">Sum</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">arr</span><span class="o">)</span><span class="err">\</span><span class="n">n</span><span class="o">{</span><span class="err">\</span><span class="n">n</span>    <span class="n">var</span> <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="err">\</span><span class="n">n</span>    <span class="n">foreach</span> <span class="o">(</span><span class="n">var</span> <span class="n">value</span> <span class="k">in</span> <span class="n">arr</span><span class="o">)</span><span class="err">\</span><span class="n">n</span>        <span class="n">acc</span> <span class="o">+=</span> <span class="n">value</span><span class="o">;</span><span class="err">\</span><span class="n">n</span>    <span class="k">return</span> <span class="n">acc</span><span class="o">;</span><span class="err">\</span><span class="n">n</span><span class="o">}</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">nvar</span> <span class="n">arraySum</span> <span class="o">=</span> <span class="n">Sum</span><span class="o">(</span><span class="n">array</span><span class="o">);</span> <span class="c1">// 54\n</span></code></pre></figure>  \n\nCuando usamos una de las variaciones de `Aggregate`, no solamente tenemos que pasar una el metodo acumulador, si no también un acumulador, que es el valor inicial de nuestro contador, si es trabajo con enteros generalmente es 0, si son cadenas se pasa una cadena vacía. Depende de lo que quieras hacer.\n\nAhora el ejemplo con `Aggregate`:\n\n<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><span class="err">\</span><span class="n">nvar</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="o">{</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">10</span> <span class="o">};</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">nvar</span> <span class="n">arraySum</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">Aggregate</span><span class="o">((</span><span class="n">acc</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="o">);</span> <span class="c1">// 54\n</span></code></pre></figure>  \n\nEn este caso, el acumulador toma el valor inicial de 0, ese valor se pasa como parámetro a la expresión lambda, al cual le pusimos como nombre `acc`. `x` es cada elemento de la colección, y el cuerpo de nuestra lambda es la suma del acumulador y cada elemento del arreglo.\n\nComo ves, este método es un poco más elaborado, pero una vez que le entiendas, puedes hacer muchas cosas interesantes.\n\n## Combinando todo  \n\nAhora que ya sabemos el uso de estos métodos, vamos a crear un pequeño programa donde usaremos los tres al mismo tiempo.\n\n<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><span class="err">\</span><span class="n">n</span><span class="c1">// Suponiendo que tenemos la siguiente estructura de ciudades\nstruct City\n{\n    public string Name ;\n    public int Population;\n}\n\n\n// Vamos a definir varios ejemplos de ciudades, y meterlos en un arreglo\nvar paris = new City { Name = \&quot;Paris\&quot;, Population = 2243 };\nvar madrid = new City { Name = \&quot;Madrid\&quot;, Population = 3216 };\nvar amsterdam = new City { Name = \&quot;Amsterdam\&quot;, Population = 811 };\nvar berlin = new City { Name = \&quot;Berlin\&quot;, Population = 3397 };\n\nvar cities = new City[] { paris, madrid, amsterdam, berlin };\n\n// Como tenemos las ciudades con poca población, vamos a escribir una función\n// que nos ayude a escalar la población\nstatic City Scale(City city) \n{\n    return new City { Name = city.Name, Population = city.Population * 1000 };\n}\n\n// Ya teniendo todo, vamos a escribir todas las ciudades cuya población\n// sea mayor a 1 millón de habitantes\n\nvar citiesFilter = cities.Where(city =&gt; city.Population &gt; 1000)\n                         .Select(Scale)\n                         .Aggregate(\&quot;City population\&quot;, \n                            (result, c) =&gt; {\n                                return result + $\&quot;\\n{c.Name}: {c.Population}\&quot;;});\n\nConsole.WriteLine(citiesFilter);\n\n// City population\n// Paris: 2243000\n// Madrid: 3216000\n// Berlin: 3397000\n</span></code></pre></figure>  \n\nListo, tenemos nuestro programa funcionando y filtrando las ciudades, sin necesidad de usar bucles, además que gracias al acumulador usado como cadena, podemos imprimir nuestras ciudades en un lindo formato.\n\nEspero te haya convencido de que empieces a usar estos métodos en tu programa, verás cómo vas a ir haciendo un código mucho más elegante y funcional, si quieres saber más sobre Linq, te invito a revisar <a href=\"#\">esta serie de posts</a>.\n"'   
}