{	
	"id" : "/post/params-c-sharp/",
	"tv" : false,
	"date": "2016-04-18 14:00:00 -0500",
	"title" : "params en C#",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages//aprende-c-sharp/params.png",
	"tags" : ["AprendeCSharp"],
	"content": "Justamente la semana pasada escribí sobre cuál es la sintaxis de <a href=\"../metodos-c-sharp\">los métodos en C#</a>, y ese fue más bien un post introductorio y es por eso que necesita ser ampliado. Esta vez toca hablar de la palabra `params` y cómo nos puede facilitar a la hora de escribir el código si es que vamos a trabajar con arreglos.\n\n### params  \nLa palabra reservada `params` se usa en la declaración de los parámetros de un método, se antepone al tipo de dato que vamos a declarar y tiene una peculiaridad, solamente se puede anteponer a parámetros que sean arreglos, por ejemplo a `string[]`, `Persona[]`.\n\nEsto es porque lo que nos ayuda a escribir es un método que recibe una cantidad variable de argumentos del mismo tipo y los \"introduce\" un un arreglo sin tener que declararlo explícitamente.\n\nMira los ejemplos para que te quede un poco más claro:\n\n### Ejemplos\n\n#### Como único parámetro\n\nPara comenzar, tomemos los siguientes métodos:\n<pre class=\"csharp\">\npublic static void Metodo1Params(params bool [] a)\n\n        Console.WriteLine(\"M1Params recibió \" + a.Length + \" booleanos\");\n\n\npublic static void Metodo1Arrays(bool [] a)\n\n    if (a == null)\n    \n        a = new bool[] ;\n    \n    Console.WriteLine(\"M1Arrays recibió \" + a.Length + \" booleanos\");\n\n</pre>  \n\nLos dos realizan exactamente lo mismo, sin embargo, para ejecutar cada uno, requerimos de una sintaxis un poco distinta:\n\n<pre class=\"csharp\">\nMetodo1Arrays(null); // Imprime: M1Arrays recibió 0 booleanos\nMetodo1Params(); // Imprime: M1Params recibió 0 booleanos\n</pre>\n\nPodemos pasar variables:\n\n<pre class=\"csharp\">\nbool cierto = true;\n// Metodo1Arrays(cierto); // Nope, necesita un arreglo\nMetodo1Arrays(new bool[]  cierto ); // Imprime: M1Arrays recibió 1 booleanos\nMetodo1Params(cierto); // Imprime: M1Params recibió 1 booleanos\n</pre>\n\nComo puedes ver, no podemos llamar `Metodo1Arrays` indicando únicamente el argumento que queremos, nosotros tenemos que crear el arreglo para llamarlo, en el siguiente ejemplo está un poco más claro:\n\n<pre class=\"csharp\">\nMetodo1Arrays(new [] cierto, false, true, cierto ); // M1Arrays recibió 4 booleanos\nMetodo1Params(cierto, false, true, cierto); // M1Params recibió 4 booleanos\n</pre>  \n\n#### En conjunto con otros\n\nPodemos declarar un método con varios parámetros, y usar `params` dentro de ellos, siempre y cuando el que marquemos sea el último parámetro de la lista.\n\n<pre class=\"csharp\">\npublic static void Metodo2Params(int a, char b, params decimal[] c)\n\n    Console.WriteLine(\"Metodo3Params: \" + c.Length);\n\n\npublic static void Metodo2Arrays(int a, char b, decimal[] c)\n\n    Console.WriteLine(\"Metodo3Array: \" + c.Length);\n\n</pre>  \n\nEl hecho de que hayamos marcado algo con `params` no quiere decir que tengamos que no podamos simplemente enviar un arreglo en lugar de una lista de valores separados por coma:\n\n<pre class=\"csharp\">\nvar array = new decimal[] 1,2,3;\nMetodo2Arrays(1, 'A', array);\nMetodo2Params(1, 'B', array);\n</pre>  \n\nLa diferencia en la cantidad de código que tenemos que escribir se hace más notoria cuando tenemos que mandar cero elementos:\n\n<pre class=\"csharp\">\nMetodo2Arrays(1, 'C', new decimal [] );\nMetodo2Params(1, 'D');\n</pre>  \n\nY también cuando vamos a mandar varios:\n\n<pre class=\"csharp\">\nMetodo2Arrays(1, 'E', new [] 2.1m, 13m, 15m );\nMetodo2Params(1, 'E', 2.1m, 13m, 15m);\n</pre>  \n\n#### Arreglos multidimensionales\n\nY también podemos crear cosas más complejas, como usar arreglos multidimensionales como parámetros:\n\n<pre class=\"csharp\">\npublic static void PromediaCalificacionesArray(decimal [][] calificaciones)\n\n    for(int i = 0; i < calificaciones.Length;i++)\n    \n        // Mejor usemos LINQ:\n        decimal promedio = calificaciones[i].Average();\n        Console.WriteLine(\"(Arrays) Calificación alumno \" + i + \": \" + promedio);\n    \n\n\npublic static void PromediaCalificacionesParams(params decimal [][] calificaciones)\n\n    for(int i = 0; i < calificaciones.Length;i++)\n    \n        decimal promedio = calificaciones[i].Average();\n        Console.WriteLine(\"(Params) Calificación alumno \" + i + \": \" + promedio);\n    \n\n</pre>\n\nY las llamadas al método:\n\n<pre class=\"csharp\">\ndecimal[] alumno1 = new decimal []  10m, 9.2m, 7m, 3.5m, 10m ;\nvar alumno2 = new [] 8.5m, 9.3m, 8.6m, 9.9m, 10m ;\n\nPromediaCalificacionesArray(new [] alumno1, alumno2 );\nPromediaCalificacionesParams(alumno1, alumno2);\n</pre>    \n\n### Ejemplo de la vida real\nUno de los máximos exponentes del uso de `params` es el método estático `String.Format`, que *formatea* una cadena y a la cual le podemos pasar una lista de argumentos. La firma de dicho método es:\n\n<pre class=\"csharp\">\npublic static string Format(\n\tstring format,\n\tparams object[] args\n)\n</pre>  \n\n### Ejemplos de lo que no se puede hacer\n\nNo podemos marcar un tipo de dato que no sea un arreglo con params, como es el caso de `char a` en el siguiente fragmento:\n\n<pre class=\"csharp\">\npublic static void Metodo1Params(params char a) // Invalido, debe ser un arreglo\n</pre>\n\nUn parámetro marcado con `params` debe ser siempre el último parámetro del método, esto para evitar confusiones a la hora de ejecutarlo:\n\n<pre class=\"csharp\">\npublic static void Metodo3Params(int a, params decimal[] b, char c)\n\n    Console.WriteLine(\"Metodo3Params: \" + b.Length);\n\n</pre> \n\nTampoco podemos declarar dos métodos con el mismo nombre y los mismos parámetros, ya que técnicamente la firma del método es la misma.\n\n<pre class=\"csharp\">\npublic static void Metodo4(params decimal[] b) //...\n\npublic static void Metodo4(decimal[] b) //...\n</pre>\n\n### Lo que sucede internamente\n\nCuando marcamos un parámetro como params, el compilador se encarga de tratarlo internamente como un arreglo: convierte nuestra lista variable de argumentos en un arreglo o crea un arreglo vacío si no enviamos nada. Así que esta palabra reservada es parte de la \"azúcar sintáctica\" que nos ofrece C#.\n\n\n### Lo que sigue\nPuede que características como la que se describe en este post no tengan mucho (o a veces nada) de impacto en el desempeño de un programa al momento de ejecutarse, sin embargo, no por eso debemos descartarlas como una poderosa herramienta de programación que puede ayudar a darle más significado al código. Como todo, también debes usarlo con moderación y en casos en los que tenga sentido."
}