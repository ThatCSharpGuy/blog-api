{	
	"id" : "/post/linq-en-c-sharp-2/",
	"tv" : false,
	"date": "2016-02-01 14:00:00 -0600",
	"title" : "Linq en C# - segunda parte",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimages/linq-en-c-sharp/featured.png",
	"tags" : ["AprendeCSharp"],
	"content": "Hace algunos cuantos posts [les hablaba de Linq en C#](/post/linq-en-c-sharp), y este post es una especie de continuación, para que, si aún no has integrado esta poderosa herramienta dentro de tus tareas de desarrollo, por fin te animes a hacerlo. \n  \n### Preparando el terreno  \nPara este post me auxiliaré de tres elementos.  \n\n - Las clases `Lecture`, `Teacher` que representarán nuestros objetos de negocios. Un profesor (`Teacher`) imparte una o más clases (`Lecture`).  \n - `FakeDatabase` que como su nombre lo indica, pretende ser una simulación de un almacenaje de datos con soporte para Linq. Hay que recordar que existen varias implementaciones: Linq to objects, Linq to SQL, Linq to XML, ...  \n   \n## Dos sintaxis  \nPara usar Linq, tenemos disponibles dos formas de hacerlo: mediante el uso de la sintaxis de método o mediante la sintaxis de consulta, ambas son en su mayor parte intercambiables, sin embargo hay algunas funciones que únicamente son accesibles mediante la sintaxis de método. Diferenciarlas es sencillo, una son los métodos tradicionales mientras que la otra hace uso de palabras especiales como `from`, `in`, `select`.  \n\nPor ejemplo, estas dos operaciones con Linq hacen lo mismo:  \n\n<div class=\"pure-g\">\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\nfrom lecture in db.Lectures\ngroup lecture by lecture.TeacherId into grouped\njoin teacher in db.Teachers \n    on grouped.Key equals teacher.Id\nwhere teacher.LastName == \"Williams\"\nselect new  TeacherId = grouped.Key, \n             Name = teacher.GivenName ;\n</pre>\n</div>\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\ndb.Lectures\n.GroupBy (lecture => lecture.TeacherId)\n.Join (db.Teachers,\n        g => g.Key, t => t.Id,\n        (g, t) => new Grouped = g, Teacher = t)\n.Where (an => an.Teacher.LastName == \"Williams\")\n.Select (an => new  TeacherId = an.Grouped.Key,\n                     Name = an.Teacher.GivenName );\n</pre>\n</div>\n</div>  \n  \nTal vez con solo ver los ejemplos anteriores ya tengas tu favorito, pero no te dejes llevar todavía, los dos tienen sus fortalezas. Sin olvidar que hay operaciones únicamente disponibles en la sintaxis de método, para mí la sintaxis de método tiene el poder de las [expresiones lambda](/post/lambdas-en-c-sharp) y la sintaxis de consulta es más legible al ojo humano. \n  \nSin importar por cual nos decidamos, el compilador siempre toma las consultas en Linq y las transforma a métodos, puesto que **elegir una sobre otra es únicamente cuestión de gustos** y necesidad del programador ya que **no existe un beneficio en desempeño entre una y otra**. De hecho, la <a href=\"https://msdn.microsoft.com/en-us/library/bb397676.aspx\" target=\"_blank\">recomendación de Microsoft es</a>:  \n  \n> Usa sintaxis de consulta en donde sea posible y sintaxis de método cuando sea necesario.  \n  \nYo no la sigo al pie de la letra, de nuevo: cuestión de gustos. Porque a mi parecer hay algunas consultas que son más sencillas de escribir y leer como métodos, como un simple filtrado con `Where`, o en ocasiones la combinación de ambas facilita la lectura.\n  \n## Proyecciones (Select, select) \nLa finalidad de usar Linq es el hacer consultas, el resultado de nuestras consultas está definido por las proyecciones que hacemos sobre los datos, dichas proyecciones están definidas por la cláusula `select` o el método `Select`.  \n  \nCon ellos se puede modelar los resultados de una consulta en un [tipo anónimo](/post/anonimos-en-c-sharp) o en un tipo previamente creado por nosotros. Por ejemplo, en la consulta anterior, el resultado era un conjunto de elementos que tenían las propiedades  `int TeacherId` y `string Name`. Es posible que usando los métodos de Linq, muchas veces se omita la proyección y es cuando se realiza una \"proyección implícita\", mientras que usando consultas siempre es necesario hacer un *select*.  \n\nSolo por decir, así como en la consulta se crea un tipo anónimo con\n\n<pre class=\"csharp\">\nnew  TeacherId = grouped.Key, Name = teacher.GivenName ;\n</pre>  \n\nIgual se pudo haber creado un objeto de `Teacher` con  \n\n<pre class=\"csharp\">\nnew Teacher  TeacherId = grouped.Key, GivenName = teacher.GivenName ;\n</pre>  \n  \n## Operadores de agregación  \nPromedios, sumas, mínimos... de todo. Usualmente metemos esto dentro de un `for` más unas cuantas variables auxiliares y tenemos el resultado, con Linq, eso se acaba.  \n\n### Conteo (Count)     \nSupongamos que queremos contar la cantidad de profesores cuyo nombre comienza con `L`, entonces debemos utilizar el método `Count` (no está disponible en la sintaxis de consulta), y se hace de la siguiente manera:\n\n<pre class=\"csharp\">\nvar profesoresConL = db.Teachers.Count(p => p.GivenName.StartsWith(\"L\"));\n</pre>  \n  \nLa llamada al método `Count` se puede hacer sin parámetros o pasando un `Func` que actúa como condicional  para indicar qué elementos dentro de la colección deben ser considerados para la cuenta.  \n  \n### Suma (Sum) \n¿Cuantos años en total suman los profesores que tienen menos de 30? fácil, con más Linq. En este caso es necesario aplicar una función de filtrado antes de hacer la sumatoria, el filtrado se puede hacer con la sintaxis de consulta, pero la sumatoria debe ser con la de método:\n\n<div class=\"pure-g\">\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\nvar edadMasMenos30 = db.Teachers\n    .Where (t => t.Age < 30)\n    .Sum (t => t.Age);\n</pre>  \n</div>\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\nvar menosDe30Total1 = (from t in db.Teachers\n                        where t.Age < 30\n                        select t.Age).Sum ();\n</pre>  \n</div>  \n</div>  \n\n### Mínimos y máximos (Min, Max) \nNo todos los profesores tienen correo electrónico, ¿tendrá algo que ver con la edad? con los métodos `Min` y `Max` podemos obtener los valores máximos y mínimos dentro de un conjunto de resultados:  \n  \n<pre class=\"csharp\">\nvar edadMinSinEmail = (from t in db.Teachers\n                        where t.Email == \"\"\n                        select t).Min (t => t.Age);\n\nvar edadMaxSinEmail = db.Teachers\n    .Where (t => t.Email == \"\")\n    .Max (t => t.Age);  \n</pre>  \n  \n### Promedio (Average) \nMmm... ¿Qué tal si probamos con los promedios de edad?, podemos usar el método `Average` para obtenerlo, primero filtramos los resultados para después obtener el promedio:  \n  \n<pre class=\"csharp\">\nvar promedioEdadSMail = (from t in db.Teachers\n    where t.Email == \"\"\n    select t).Average (t => t.Age);\n\nvar promedioEmailCMail = db.Teachers\n    .Where (t => t.Email != \"\")\n    .Average (t => t.Age);\n</pre>   \n\nTambién existe una función llamada `Aggregate` que nos da flexibilidad para integrar nuestra propia funcionalidad de agregación.\n\n## Cuantificadores  \nOtro lugar en donde metíamos un `bool`, un ciclo `for`, un condicional y problema resuelto. Usando Linq lo único que necesitamos es la condición. \n  \n### Todos los elementos (All) \nPodemos usar el método `All` para verificar que todos los elementos dentro del conjunto cumplen con la condición especificada, **si todos cumplen la condición**, el método nos regresará `true`. Por ejemplo, si quisiéramos saber si todos los maestros tienen más de 18 años:  \n  \n<pre class=\"csharp\">\nbool todosMayores = db.Teachers.All(teacher => teacher.Age > 18);\n</pre>   \n\n### Algún elemento (Any)\nContrario a `All`, el método `Any` devolverá `true` cuando exista **al menos un elemento que cumpla con la condición** que se le pasa como argumento. Por ejemplo, si queremos saber si existe algún maestro que se llame Cosme Fulanito:  \n  \n<pre class=\"csharp\">\nbool existeCosmeFulanito = db.Teachers.Any(teacher => teacher.GivenName == \"Cosme\"\n                            && teacher.LastName == \"Fulanito\");\n</pre>   \n\nOtra de las funciones de `Any` es evitarnos el \"molesto\" condicional de `.Count > 0`. Porque si llamamos `Any` sin pasar ningún condicional, este nos devolverá `true` siempre que nuestra secuencia contenga algún elemento. Digamos que antes de seguir queremos saber si hay clases registradas:\n  \n<pre class=\"csharp\">\nbool hayClases = db.Lectures.Any();  \n</pre>   \n\n## Ordenamiento (OrderBy, orderby) \nCon Linq también es posible ordenar nuestros conjuntos de datos. Solo hay que recordar que generalmente el ordenamiento operará solo de manera temporal y que el ordenamiento no permanecerá una vez que hemos dejado de trabajar con los datos.\n\nPara ordenar podemos usar tanto la cláusula `orderby` y especificarle la propiedad a usar como referencia o el método `OrderBy` y usar una expresión lambda para el mismo fin. Vamos a ordenar a los maestros por la longitud de su apellido: \n\n<div class=\"pure-g\">\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\nvar maestrosOrdenados1 = db.Teachers\n    .OrderBy(t => t.LastName.Length);\n</pre>  \n</div>\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\nvar maestrosOrdenados2 = \n        from t in db.Teachers\n        orderby t.LastName.Length\n        select t;\n</pre>  \n</div>  \n</div> \n\nTambién tenemos disponible la cláusula `descending` y el método `OrderByDescending` que invertirán el ordenamiento, se usan así:  \n\n<div class=\"pure-g\">\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\n.OrderByDescending(t => t.LastName.Length);\n</pre>  \n</div>\n<div class=\"pure-u-1 pure-u-md-1-2\">\n<pre class=\"csharp\">\norderby t.LastName.Length descending\n</pre>  \n</div>  \n</div> \n \n¿Pero qué ocurre cuando queremos tomar en cuenta dos propiedades para realizar el ordenamiento? pues para eso podemos usar el método `ThenBy` o `ThenByDescending` para especificar otra condición de ordenamiento.\n\n<pre class=\"csharp\">\nvar maestrosOrdenados3 = db.Teachers\n    .OrderBy(t => t.LastName.Length)\n    .ThenByDescending(t => t.GivenName);\n</pre>  \n  \n## Operadores de partición  \nLos operadores de partición son especialmente útiles para paginar los resultados, estos permiten considerar (o no considerar) cierta cantidad de elementos al inicio de la secuencia que los contiene.  \n  \n### Toma (Take)  \nEl método `Take` recibe un entero como parámetro que especifica la cantidad de elementos que son requeridos de toda la secuencia sobre la que opera, en caso de que haya menos de los requeridos únicamente devolverá los que encontró. Por ejemplo, si quisiéramos tomar los primeros 5 maestros más jóvenes, menores de 20 años:\n\n<pre class=\"csharp\">\nvar cincoMenores20 = (from t in db.Teachers\n                      where t.Age < 20\n                      orderby t.Age\n                      select t).Take (5);\n</pre>  \n  \n### Salta (Skip)  \nPodríamos verlo como el contrario de `Take`, ya que `Skip` igualmente toma un entero, pero este entero indica cuántos elementos de la secuencia debe ignorar antes de comenzar a tomar en cuenta. Supongamos que necesitamos tomar todos los maestros mayores de 30 años, comenzando por los mayores, pero ignorar a los primeros 4:\n\n<pre class=\"csharp\">\nvar otrosMaestros = db.Teachers\n    .Where(t=> t.Age > 30)\n    .OrderByDescending(t => t.Age)\n    .Skip(4);\n</pre>  \n\nTambién existe un método que se llama `TakeWhile` y otro que se llama `SkipWhile`, ambos requieren de una condición sobre la que se decidirá a partir de cuándo comenzar a tomar (o dejar de ignorar) los elementos de la secuencia.  \n\n#### Lo que sigue  \nUna vez que hemos visto el poder de Linq con estos ejemplos relativamente sencillos, no queda más que seguir y aprender sobre agrupamientos, uniones, intersecciones y otras cuantas cosas un poco más complejas. Lo visto aquí sigue sin ser lo más impresionante de esta herramienta. Recuerda que puedes encontrar el código fuente en la información del post. "
}