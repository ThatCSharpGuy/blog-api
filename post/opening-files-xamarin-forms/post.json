{	
	"id" : "/post/opening-files-xamarin-forms/",
	"tv" : false,
	"date": "2016-01-08 15:00:00 -0600",
	"title" : "Opening files in Xamarin.Forms",
	"author" : "Antonio Feregrino Bolaños",
	"featured_image": "http://thatcsharpguy.com/postimagesfeatured.png",
	"tags" :
	["Xamarin","XamarinForms"],
	
	"content" : body"Do you want your app to receive files from other applications?  \n\nLet's set a practical example: I built a simple [markdown viewer in Xamarin.Forms](/MrkViewer) and what I wanted my app to do was to show up in the available options when a `.md` file were about to be opened. This is a pretty straightforward task when developing platform specific projects... but when using Xamarin.Forms you may not know where to start, to be honest, I wasn't.  \n  \n### Starting point\nFirst fo all, remember that **all Xamarin.Forms apps are nothing but native apps**, there is no magic regarding them. They all start in the same point whether it is a MainActivity for Xamarin.Android, an App.xaml for Windows Phone or an AppDelegate form Xamarin.iOS and when dealing with incoming files the same applies. So, with that in mind, let's start.\n\n## Xamarin.Forms  \nLet's create a sample application that will show the name and content of the received file, just create class to hold the data, for this sample it'll only contain a `Name` and `Content` property, but you can extend it later to fit your needs. \n\n{% highlight csharp %}\npublic class IncomingFile\n{\n\tpublic string Name { get; set; }\n\tpublic string Content { get; set; }\n}\n{% endhighlight %}\n\nNext, create a page (in this sample `FilePage.xaml`) with two labels (for the file name and file content), give them a name and add the next method in the code behind: \n\n{% highlight csharp %}\npublic void SetIncomingFile(IncomingFile file)\n{\n\tFileName.Text = file.Name;\n\tFileContent.Text = file.Content;\n}\n{% endhighlight %}\n\nThen, in your Forms app starting point (generally App.cs) create a property of type IncomingFile, don't just use an autoimplemented property, create a backing field for it. Somewhat like this:\n{% highlight csharp %}\nprivate IncomingFile _incomingFile;\n\npublic IncomingFile IncomingFile\n{\n\tget { return _incomingFile; }\n\tset \n\t{\n\t\t_incomingFile \t= value; \n\t\t(MainPage as FilePage).SetIncomingFile (_incomingFile);\n\t}\n}\n{% endhighlight %}\n\nNotice how everytime the IncomingFile property is modified, the method `SetIncomingFile` of `FilePage` is called. We will be using this property to set the file from within each platform code. So, let's dive right into it.\n\n## Windows 8.1  \nI'll start with Windows 8.1, since it was my main target with MrkViewer, check the getting started on <a href=\"https://developer.xamarin.com/guides/cross-platform/xamarin-forms/windows/\" target=\"_blank\">how to create a Windows App</a> for more info. I won't cover Windows Phone or UWP apps because they are similar to Win 8.1.\n  \nFirst of all: you must create a file association inside your application manifest, double click the `appxmanifest` file, a window will open, from there select the Declarations tab and using the dropdow list select `File Type Associations` and click add.  \n\n\n<div class=\"pure-g\">\n<div class=\"pure-u-lg-1-3\">\n{% post_image appxmanifest.png \"The appxmanifest file\" %}\n</div>\n<div class=\"pure-u-lg-1-3\">\n{% post_image file-assoc.png \"Add new File Type Association\" %}\n</div>  \n</div>\n<br />\nAfter clicking `Add` a form will appear to the right, we'll keep things simple. Fill in the form the following fields:  \n\n - **Display name**: Markdown\n - **Name**: md\n - **File type**: .md (don't forget the leading dot)\n\nAnd that's about it. Next, we'll have to get the file when our app is launched for that purpose.  \n  \nIn Windows 8.1 different methods are called depending on what kind of event launched our app, when our app is opened as the result of a File Type Association, the starting poit of the app will be the `OnFileActivated` method inside the `App` class. Let's override it: \n\n{% highlight csharp %}\nprotected override void OnFileActivated(FileActivatedEventArgs e)\n{\n    base.OnFileActivated(e);\n    // ...\n{% endhighlight %}  \n  \nThe reference to the recently opened file is inside the `FileActivatedEventArgs`, to find it use something like this:\n\n{% highlight csharp %}\nStorageFile file = null;\nif (e.Files.Count == 1)\n{\n    file = e.Files[0] as StorageFile;\n}\n{% endhighlight %}  \n\nLaunching an app to receive a file is not so different than launching it normally, so after we get the reference to the desired file, we must let the launching process continue as usually, for that copy the code inside the `OnLaunched` from `Frame rootFr...` to `if (rootF...`  and paste it after the code above.\n\n{% highlight csharp %}\n    file = e.Files[0] as StorageFile;\n} //\n\nFrame rootFrame = Window.Current.Content as Frame;\nif (rootFrame == null)\n{\n    rootFrame = new Frame();\n    rootFrame.Language = Windows.Globalization.ApplicationLanguages.Languages[0];\n    rootFrame.NavigationFailed += OnNavigationFailed;\n\n    Xamarin.Forms.Forms.Init(e); // <- DON'T FORGET TO INITIALIZE FORMS\n\n    Window.Current.Content = rootFrame;\n}\n{% endhighlight %}  \n  \nNow all we have to do is to navigate to the generated `MainPage` passing the file as a navigation parameter:\n\n{% highlight csharp %}\n// Pass the recently opened file ----vvvv\nrootFrame.Navigate(typeof(MainPage), file);\nWindow.Current.Activate();\n{% endhighlight %}  \n\nAs you may guess, there is still work to do inside the Windows 8 generated  `MainPage`, and that's true. We still need to get the file passed as navigation parameter. First of all, instead of calling the forms app in this way `LoadApplication(new YOUR_NAMESPACE.App());`, create a field of type `new YOUR_NAMESPACE.App`, like\n\n{% highlight csharp %}\nFileReceiver.App _app;\n{% endhighlight %}  \n\nAnd then call the `LoadApplication` using that field\n\n{% highlight csharp %}\n_app = new FileReceiver.App();\nLoadApplication(_app);\n{% endhighlight %}  \n\nNow the final step: override the `OnNavigatedTo` method inside the `MainPage` class, but we need to be extra careful here, since this method will be called regardless of how was the app launched, so take that in consideration:\n\n{% highlight csharp %}\nprotected override async void OnNavigatedTo(NavigationEventArgs e)\n{\n    StorageFile storageFile = e.Parameter as StorageFile;\n    if (storageFile != null)\n    {\n        string content = await FileIO.ReadTextAsync(storageFile);\n        var incomingFile = new IncomingFile\n        {\n            Name = storageFile.DisplayName,\n            Content = content\n        };\n        _app.IncomingFile = incomingFile;\n    }\n    base.OnNavigatedTo(e);\n}\n{% endhighlight %}  \n\n<br />\n\n## Android\nAs with Windows, in Android you must tell the OS that your app is ready to receive a certain kind of files, and to do so, you must edit the `AndroidManifest.xml` file. Remember that for Xamarin.Android there are two ways to work with the manifest:\n\n - Editing the XML\n\t\t\n{% highlight xml %}\n<activity  android:icon=\"@drawable/icon\" android:label=\"FileReceiver\"  name=\"Something.MainActivity\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <category android:name=\"android.intent.category.BROWSABLE\" />\n        <data android:scheme=\"file\" />\n        <data android:mimeType=\"*/*\" />\n        <data android:pathPattern=\".*\\\\.md\" />\n    </intent-filter>\n</activity>\n{% endhighlight %}\n\t\t\n - Using class level attributes\n\t\t\n{% highlight csharp %}\n[Activity(Label = \"FileReceiver\",\n        MainLauncher = true, Icon = \"@drawable/icon\")]\n    [IntentFilter(\n        new[] { Intent.ActionView },\n        Categories = new[]\n        { \n            Intent.CategoryDefault,\n            Intent.CategoryBrowsable,\n        },\n        DataScheme = \"file\",\n        DataMimeType = \"*/*\",\n        DataPathPattern = \".*\\\\.md\"\n    )]\n{% endhighlight %}\n\nFor this sample let's take the attribute approach. Then, once the `MainActivity.cs` file is open, separate the `LoadApplication` method and the instantiation of the Forms app: \n\n{% highlight csharp %}\nvar application = new App ();\n\nLoadApplication (application);\n{% endhighlight %}  \n\nIn Android, every time an app is launched to receive a file, the `OnCreate` method is executed as if it were launched manually by the user, no special method is called or something, to know if the app was launched to receive a file we'll have to look at the Activity's Intent action and type:  \n\n{% highlight csharp %}\nstring action = Intent.Action;\nstring type = Intent.Type;\n\nif (Intent.ActionView.Equals(action) && !String.IsNullOrEmpty(type))\n{\n\t// This app was launched to receive a file ...\n{% endhighlight %}  \n\nAfter we are sure that the app was to receive a file, we can safely get an `Uri` to the file by getting the Intent data, reading it and then creating an instance of the previously defined `IncomingFile` class:  \n\n{% highlight csharp %}\nAndroid.Net.Uri fileUri = Intent.Data;\n\nstring fileContent = File.ReadAllText(fileUri.Path);\nstring fileName = fileUri.LastPathSegment;\n\nvar incomingFile = new IncomingFile { Name = fileName, Content = fileContent }; \n{% endhighlight %}  \n\nWe have finally handled a file receiving within the Xamarin.Android project, the last thing we have to do is to set the `IncomingFile` property of the Forms app, a call to `application.IncomingFile` will do the trick:  \n\n{% highlight csharp %}\napplication.IncomingFile = incomingFile;\n{% endhighlight %}  \n\n<br />\n\n## iOS  \nWe already know that we need to register our app somehow to let the os know about the existence of our app, and in iOS the wa to do this is vía the `Info.plist` file. When I started  to implement this I struggled a bit because I think the docummentation a bit too vague.  \n  \nAny way, in your app, open the Info.plist file, and at the bottom part click on the `Advanced tab`, now, we have to fill in some information about the type of files we want to open in our app, for Markdown files we must add a new *Document Type* with the following values:  \n  \n - **Name**: Markdown document\n - **Types**: net.daringfireball.markdown  \n  \nNow, since `net.daringfireball.markdown` is not a known type for iOS, we have to register it in the same UI we declared the filetype association, click add in *Exported UTIs*, once available, put this values on the text fields:  \n  \n - **Description**: Markdown document\n - **Identifier**: net.daringfireball.markdown\n - **Conforms To**: public.plain-text  \n\nThere is a few lines we need to add in order to make this work, like adding `.md` as a file extension for the files... just to be sure, open the `Info.plist` with an XML editor and make sure it looks <a href=\"https://github.com/fferegrino/xf-file-receiver/blob/master/FileReceiver.iOS/Info.plist#L52\" target=\"blank\">somewhat like this in code</a> or take a look at the following image.\n\n{% post_image file-assoc-ios.png \"Add new File Type Association in iOS\" %}  \n  \nNow, the most fun part, the code.  \n  \nAs with the Windows version of our app, we need to separate the call to `LoadApplicaton` from the instatiation of the Forms app, again, create a Field inside the `AppDelegate` class of type `new YOUR_NAMESPACE.App`, like:\n\n{% highlight csharp %}\nFileReceiver.App _app;\n{% endhighlight %} \n\nNow, inside the `FinishedLaunching` method, instantiate the `_app` field and call `LoadApplication` using it as a parameter:\n{% highlight csharp %}\n_app = new App ();\nLoadApplication(_app);\n{% endhighlight %}  \n\nWhen our app is launched to open a file, a method is called in the `AppDelegate` class, it's name is `OpenUrl`. In order to handle the icoming file, we must override it. The method receives an `NSUrl` as an argument, and that is the url of our file.  \n  \nI will use the `File.ReadAllText` static method inside the `System.IO` to get the content of the app that has to be opened by the app, such method takes a file path (in the form of string) as a parameter and returns the text contained by that same file.  \n  \nBe careful here because there is a catch with the url you are given inside your method: it has the protocol `file://` at the beginning of the url, so you need to remove it before sending the path to the `ReadAllText` method, in this case, I just trimmed the first 7 characters of the url:\n\n{% highlight csharp %}\n// Remove \"file://\" at the beginning of the url:\nstring filePath = url.AbsoluteString.Substring(7);\n{% endhighlight %}  \n  \nNow it is safe to read all the text inside the file and pass it to the Forms application:\n\n{% highlight csharp %}\n// Get the file name\nvar fileName = url.PathComponents [url.PathComponents.Length - 1];\n\nvar fileContent = System.IO.File.ReadAllText (filePath);\n_app.IncomingFile = new IncomingFile \n{\n    Name =  fileName,\n    Content = fileContent\n};\n{% endhighlight %}  \n\nIn iOS you are responsible to clean all the files that your app opens in this way, my recommendation is that you delete the file after reading it.  \n  \n## Wrapping up  \nAs you can see, it is not hard to enable your Xamarin.Forms app to open certain kind of files, all you have to do is tell the operating system (through configuration files) that your app is capable of opening that kind of files, and then write some code at the beginning of your app to handle the incoming file. "
}